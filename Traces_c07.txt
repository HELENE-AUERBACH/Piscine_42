Sujet en Anglais : https://cdn.intra.42.fr/pdf/pdf/73930/en.subject.pdf
Sujet en Francais : https://cdn.intra.42.fr/pdf/pdf/73931/fr.subject.pdf

e3r11p9% cd
e3r11p9% cd c_07
e3r11p9% ls
ex00
e3r11p9% cd ex00 
e3r11p9% ls
ft_strdup.c
e3r11p9% cat ft_strdup.c 
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_strdup.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: hauerbac <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2023/02/22 14:07:10 by hauerbac          #+#    #+#             */
/*   Updated: 2023/02/22 14:07:13 by hauerbac         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

int	ft_strlen(char *str)
{
	int	i;

	i = 0;
	while (str && str[i] != '\0')
		i++;
	return (i);
}

char	*ft_strncpy(char *dest, char *src, unsigned int n)
{
	unsigned int	i;

	if (src && dest && n > 0)
	{
		i = 0;
		while (i < n && src[i] != '\0')
		{
			dest[i] = src[i];
			i++;
		}
		while (i < n)
		{
			dest[i] = '\0';
			i++;
		}
	}
	return (dest);
}

char	*ft_strdup(char *src)
{
	int		src_len;
	char	*ptr;

	if (src)
	{
		src_len = ft_strlen(src);
		ptr = (char *) malloc(src_len * sizeof(char));
		if (ptr)
		{
			ft_strncpy(ptr, src, src_len + 1);
			return (ptr);
		}
	}
	return (NULL);
}
e3r11p9% norminette -R CheckForbiddenSourceHeader ft_strdup.c 
ft_strdup.c: OK!
e3r11p9% vi test_ft_strdup.c 
e3r11p9% cat test_ft_strdup.c 
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   test_ft_strdup.c                                   :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: hauerbac <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2023/02/22 16:07:32 by hauerbac          #+#    #+#             */
/*   Updated: 2023/02/22 16:07:35 by hauerbac         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

char	*ft_strdup(char *src);

int	main(void)
{
	printf("\"%s\" duplicated : \"%s\"\n", "Toto", ft_strdup("Toto"));
	retrun (0);
}
e3r11p9% vi test_ft_strdup.c 
e3r11p9% cat test_ft_strdup.c
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   test_ft_strdup.c                                   :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: hauerbac <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2023/02/22 16:07:32 by hauerbac          #+#    #+#             */
/*   Updated: 2023/02/22 16:08:20 by hauerbac         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include <stdio.h>

char	*ft_strdup(char *src);

int	main(void)
{
	printf("\"%s\" duplicated : \"%s\"\n", "Toto", ft_strdup("Toto"));
	return (0);
}
e3r11p9% norminette -R CheckForbiddenSourceHeader test_ft_strdup.c 
test_ft_strdup.c: OK!
e3r11p9% gcc -Wall -Wextra -Werror -o test_ft_strdup ft_strdup.c test_ft_strdup.c 
ft_strdup.c: In function â€˜ft_strdupâ€™:
ft_strdup.c:52:18: error: implicit declaration of function â€˜mallocâ€™ [-Werror=implicit-function-declaration]
   52 |   ptr = (char *) malloc(src_len * sizeof(char));
      |                  ^~~~~~
ft_strdup.c:52:18: error: incompatible implicit declaration of built-in function â€˜mallocâ€™ [-Werror]
ft_strdup.c:1:1: note: include â€˜<stdlib.h>â€™ or provide a declaration of â€˜mallocâ€™
  +++ |+#include <stdlib.h>
    1 | /* ************************************************************************** */
ft_strdup.c:59:10: error: â€˜NULLâ€™ undeclared (first use in this function)
   59 |  return (NULL);
      |          ^~~~
ft_strdup.c:1:1: note: â€˜NULLâ€™ is defined in header â€˜<stddef.h>â€™; did you forget to â€˜#include <stddef.h>â€™?
  +++ |+#include <stddef.h>
    1 | /* ************************************************************************** */
ft_strdup.c:59:10: note: each undeclared identifier is reported only once for each function it appears in
   59 |  return (NULL);
      |          ^~~~
ft_strdup.c:60:1: error: control reaches end of non-void function [-Werror=return-type]
   60 | }
      | ^
cc1: all warnings being treated as errors
e3r11p9% vi ft_strdup.c                                   
e3r11p9% cat ft_strdup.c                                     
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_strdup.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: hauerbac <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2023/02/22 14:07:10 by hauerbac          #+#    #+#             */
/*   Updated: 2023/02/22 16:11:29 by hauerbac         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include <stdlib.h>

int	ft_strlen(char *str)
{
	int	i;

	i = 0;
	while (str && str[i] != '\0')
		i++;
	return (i);
}

char	*ft_strncpy(char *dest, char *src, unsigned int n)
{
	unsigned int	i;

	if (src && dest && n > 0)
	{
		i = 0;
		while (i < n && src[i] != '\0')
		{
			dest[i] = src[i];
			i++;
		}
		while (i < n)
		{
			dest[i] = '\0';
			i++;
		}
	}
	return (dest);
}

char	*ft_strdup(char *src)
{
	int		src_len;
	char	*ptr;

	if (src)
	{
		src_len = ft_strlen(src);
		ptr = (char *) malloc(src_len * sizeof(char));
		if (ptr)
		{
			ft_strncpy(ptr, src, src_len + 1);
			return (ptr);
		}
	}
	return (NULL);
}
e3r11p9% norminette -R CheckForbiddenSourceHeader ft_strdup.c                    
ft_strdup.c: OK!
e3r11p9% gcc -Wall -Wextra -Werror -o test_ft_strdup ft_strdup.c test_ft_strdup.c
e3r11p9% ls -al
total 32
drwxr-xr-x 2 hauerbac 2023_paris  4096 Feb 22 16:12 .
drwxr-xr-x 3 hauerbac 2023_paris  4096 Feb 22 13:57 ..
-rw-r--r-- 1 hauerbac 2023_paris  1512 Feb 22 16:11 ft_strdup.c
-rwxr-xr-x 1 hauerbac 2023_paris 16144 Feb 22 16:12 test_ft_strdup
-rw-r--r-- 1 hauerbac 2023_paris  1041 Feb 22 16:08 test_ft_strdup.c
e3r11p9% ./test_ft_strdup 
"Toto" duplicated : "Toto"
e3r11p9% vi test_ft_strdup.c                                                     
e3r11p9% norminette -R CheckForbiddenSourceHeader test_ft_strdup.c               
test_ft_strdup.c: Error!
Error: SPACE_EMPTY_LINE     (line:  20, col:   1):	Space on empty line
e3r11p9% vi test_ft_strdup.c                                      
e3r11p9% cat test_ft_strdup.c                                     
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   test_ft_strdup.c                                   :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: hauerbac <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2023/02/22 16:07:32 by hauerbac          #+#    #+#             */
/*   Updated: 2023/02/22 16:16:37 by hauerbac         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include <stdio.h>

char	*ft_strdup(char *src);

int	main(void)
{
	char	*duplicated;

	duplicated = ft_strdup("Toto");
	printf("\"%s\" duplicated : \"%s\"\n", "Toto", duplicated);
	free(duplicated);
	duplicated = ft_strdup("");
	printf("\"%s\" duplicated : \"%s\"\n", "", duplicated);
	free(duplicated);
	duplicated = ft_strdup("1");
	printf("\"%s\" duplicated : \"%s\"\n", "", duplicated);
	return (0);
}
e3r11p9% norminette -R CheckForbiddenSourceHeader test_ft_strdup.c
test_ft_strdup.c: OK!
e3r11p9% gcc -Wall -Wextra -Werror -o test_ft_strdup ft_strdup.c test_ft_strdup.c
test_ft_strdup.c: In function â€˜mainâ€™:
test_ft_strdup.c:23:2: error: implicit declaration of function â€˜freeâ€™ [-Werror=implicit-function-declaration]
   23 |  free(duplicated);
      |  ^~~~
test_ft_strdup.c:23:2: error: incompatible implicit declaration of built-in function â€˜freeâ€™ [-Werror]
test_ft_strdup.c:14:1: note: include â€˜<stdlib.h>â€™ or provide a declaration of â€˜freeâ€™
   13 | #include <stdio.h>
  +++ |+#include <stdlib.h>
   14 | 
cc1: all warnings being treated as errors
e3r11p9% vi test_ft_strdup.c                                     
e3r11p9% cat test_ft_strdup.c                                     
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   test_ft_strdup.c                                   :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: hauerbac <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2023/02/22 16:07:32 by hauerbac          #+#    #+#             */
/*   Updated: 2023/02/22 16:17:16 by hauerbac         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include <stdio.h>
#include <stdlib.h>

char	*ft_strdup(char *src);

int	main(void)
{
	char	*duplicated;

	duplicated = ft_strdup("Toto");
	printf("\"%s\" duplicated : \"%s\"\n", "Toto", duplicated);
	free(duplicated);
	duplicated = ft_strdup("");
	printf("\"%s\" duplicated : \"%s\"\n", "", duplicated);
	free(duplicated);
	duplicated = ft_strdup("1");
	printf("\"%s\" duplicated : \"%s\"\n", "", duplicated);
	return (0);
}
e3r11p9% norminette -R CheckForbiddenSourceHeader test_ft_strdup.c               
test_ft_strdup.c: OK!
e3r11p9% gcc -Wall -Wextra -Werror -o test_ft_strdup ft_strdup.c test_ft_strdup.c
e3r11p9% ./test_ft_strdup                                        
"Toto" duplicated : "Toto"
"" duplicated : ""
"" duplicated : "1"
e3r11p9% vi test_ft_strdup.c                                     
e3r11p9% cat test_ft_strdup.c                                     
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   test_ft_strdup.c                                   :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: hauerbac <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2023/02/22 16:07:32 by hauerbac          #+#    #+#             */
/*   Updated: 2023/02/22 16:17:59 by hauerbac         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include <stdio.h>
#include <stdlib.h>

char	*ft_strdup(char *src);

int	main(void)
{
	char	*duplicated;

	duplicated = ft_strdup("Toto");
	printf("\"%s\" duplicated : \"%s\"\n", "Toto", duplicated);
	free(duplicated);
	duplicated = ft_strdup("");
	printf("\"%s\" duplicated : \"%s\"\n", "", duplicated);
	free(duplicated);
	duplicated = ft_strdup("1");
	printf("\"%s\" duplicated : \"%s\"\n", "1", duplicated);
	return (0);
}
e3r11p9% norminette -R CheckForbiddenSourceHeader test_ft_strdup.c               
test_ft_strdup.c: OK!
e3r11p9% gcc -Wall -Wextra -Werror -o test_ft_strdup ft_strdup.c test_ft_strdup.c
e3r11p9% ./test_ft_strdup                                       
"Toto" duplicated : "Toto"
"" duplicated : ""
"1" duplicated : "1"
e3r11p9% cd ..
e3r11p9% mkdir ex01
e3r11p9% cd ex01
e3r11p9% vi ft_range.c
e3r11p9% cat ft_range.c 
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_range.c                                         :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: hauerbac <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2023/02/22 17:26:36 by hauerbac          #+#    #+#             */
/*   Updated: 2023/02/22 17:26:46 by hauerbac         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include <stdlib.h>

char	*ft_strncpy(char *dest, char *src, unsigned int n)
{
	unsigned int	i;

	if (src && dest && n > 0)
	{
		i = 0;
		while (i < n && src[i] != '\0')
		{
			dest[i] = src[i];
			i++;
		}
		while (i < n)
		{
			dest[i] = '\0';
			i++;
		}
	}
	return (dest);
}

int	*ft_range(int min, int max)
{
	int	range_len;
	int	*ptr;
	int	i;
	int	value;

	if (min >= max)
	{
		range_len = max - min;
		ptr = (int *) malloc(range_len * sizeof(int));
		if (ptr)
		{
			value = min;
			i = 0;
			while (i < range_len && value < max)
				ptr[i++] = value++;
			return (ptr);
		}
	}
	return (NULL);
}
e3r11p9% norminette -R CheckForbiddenSourceHeader ft_range.c                     
ft_range.c: OK!
e3r11p9% vi test_ft_range.c 
e3r11p9% cat test_ft_range.c 
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   test_ft_range.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: hauerbac <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2023/02/22 17:56:00 by hauerbac          #+#    #+#             */
/*   Updated: 2023/02/22 17:56:03 by hauerbac         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>

int	*ft_range(int min, int max);


void	ft_putnbr(int nb)
{
	long	nb_in_long;
	int		digit_to_char;

	nb_in_long = nb;
	if (nb_in_long < 0)
	{
		write(1, "-", 1);
		nb_in_long = nb_in_long * -1;
	}
	if (nb_in_long < 10)
	{
		digit_to_char = nb_in_long + '0';
		write(1, &digit_to_char, 1);
	}
	else
	{
		ft_putnbr(nb_in_long / 10);
		ft_putnbr(nb_in_long % 10);
	}
}

void	ft_print_int_tab(int *tab, int size)
{
	int	i;

	if (tab && size > 0)
	{
		i = 0;
		while (i < size)
		{
			if (i == 0)
				write(1, "[", 1);
			ft_putnbr(tab[i]);
			if (i < size - 1)
				write(1, ", ", 2);
			if (i == size - 1)
				write(1, "]", 1);
			i++;
		}
	}
}

int	main(void)
{
	int	min;
	int	max;
	int	*tab;

	min = 3;
	max = 8;
	tab = ft_range(min, max);
	printf("Pour min = %d et max = %d, tab =\n", min, max);
	ft_print_int_tab(tab, max - min);
	free(tab);
	min = 42;
	max = 42;
	tab = ft_range(min, max);
	printf("\nPour min = %d et max = %d, tab =\n", min, max);
	ft_print_int_tab(tab, max - min);
	free(tab);
	return (0);
	min = -42;
	max = 43;
	tab = ft_range(min, max);
	printf("\nPour min = %d et max = %d, tab =\n", min, max);
	ft_print_int_tab(tab, max - min);
	free(tab);
	min = 42;
	max = -1;
	tab = ft_range(min, max);
	printf("\nPour min = %d et max = %d, tab =\n", min, max);
	ft_print_int_tab(tab, max - min);
	free(tab);
	return (0);
}
e3r11p9% norminette -R CheckForbiddenSourceHeader test_ft_range.c 
test_ft_range.c: Error!
Error: CONSECUTIVE_NEWLINES (line:  19, col:   1):	Consecutive newlines
Error: TOO_MANY_LINES       (line:  96, col:   1):	Function has more than 25 lines
e3r11p9% vi test_ft_range.c                                     
e3r11p9% cat test_ft_range.c                                     
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   test_ft_range.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: hauerbac <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2023/02/22 17:56:00 by hauerbac          #+#    #+#             */
/*   Updated: 2023/02/22 17:56:34 by hauerbac         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>

int	*ft_range(int min, int max);

void	ft_putnbr(int nb)
{
	long	nb_in_long;
	int		digit_to_char;

	nb_in_long = nb;
	if (nb_in_long < 0)
	{
		write(1, "-", 1);
		nb_in_long = nb_in_long * -1;
	}
	if (nb_in_long < 10)
	{
		digit_to_char = nb_in_long + '0';
		write(1, &digit_to_char, 1);
	}
	else
	{
		ft_putnbr(nb_in_long / 10);
		ft_putnbr(nb_in_long % 10);
	}
}

void	ft_print_int_tab(int *tab, int size)
{
	int	i;

	if (tab && size > 0)
	{
		i = 0;
		while (i < size)
		{
			if (i == 0)
				write(1, "[", 1);
			ft_putnbr(tab[i]);
			if (i < size - 1)
				write(1, ", ", 2);
			if (i == size - 1)
				write(1, "]", 1);
			i++;
		}
	}
}

int	main(void)
{
	int	min;
	int	max;
	int	*tab;

	min = 3;
	max = 8;
	tab = ft_range(min, max);
	printf("Pour min = %d et max = %d, tab =\n", min, max);
	ft_print_int_tab(tab, max - min);
	free(tab);
	min = 42;
	max = 42;
	tab = ft_range(min, max);
	printf("\nPour min = %d et max = %d, tab =\n", min, max);
	ft_print_int_tab(tab, max - min);
	free(tab);
	return (0);
	min = -42;
	max = 43;
	tab = ft_range(min, max);
	printf("\nPour min = %d et max = %d, tab =\n", min, max);
	ft_print_int_tab(tab, max - min);
	free(tab);
	min = 42;
	max = -1;
	tab = ft_range(min, max);
	printf("\nPour min = %d et max = %d, tab =\n", min, max);
	ft_print_int_tab(tab, max - min);
	free(tab);
	return (0);
}
e3r11p9% norminette -R CheckForbiddenSourceHeader test_ft_range.c
test_ft_range.c: Error!
Error: TOO_MANY_LINES       (line:  95, col:   1):	Function has more than 25 lines
e3r11p9% gcc -Wall -Wextra -Werror -o test_ft_range ft_range.c test_ft_range.c   
e3r11p9% ls -al
total 32
drwxr-xr-x 2 hauerbac 2023_paris  4096 Feb 22 17:57 .
drwxr-xr-x 4 hauerbac 2023_paris  4096 Feb 22 17:15 ..
-rw-r--r-- 1 hauerbac 2023_paris  1495 Feb 22 17:26 ft_range.c
-rwxr-xr-x 1 hauerbac 2023_paris 16312 Feb 22 17:57 test_ft_range
-rw-r--r-- 1 hauerbac 2023_paris  2287 Feb 22 17:56 test_ft_range.c
e3r11p9% ./test_ft_range 
Pour min = 3 et max = 8, tab =

Pour min = 42 et max = 42, tab =
e3r11p9% vi test_ft_range.c                                     
e3r11p9% cat test_ft_range.c                                     
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   test_ft_range.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: hauerbac <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2023/02/22 17:56:00 by hauerbac          #+#    #+#             */
/*   Updated: 2023/02/22 18:00:16 by hauerbac         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>

int	*ft_range(int min, int max);

void	ft_putnbr(int nb)
{
	long	nb_in_long;
	int		digit_to_char;

	nb_in_long = nb;
	if (nb_in_long < 0)
	{
		write(1, "-", 1);
		nb_in_long = nb_in_long * -1;
	}
	if (nb_in_long < 10)
	{
		digit_to_char = nb_in_long + '0';
		write(1, &digit_to_char, 1);
	}
	else
	{
		ft_putnbr(nb_in_long / 10);
		ft_putnbr(nb_in_long % 10);
	}
}

void	ft_print_int_tab(int *tab, int size)
{
	int	i;

	if (tab && size > 0)
	{
		write(1, "[", 1);
		i = 0;
		while (i < size)
		{
			ft_putnbr(tab[i]);
			if (i < size - 1)
				write(1, ", ", 2);
			i++;
		}
		write(1, "]", 1);
	}
}

int	main(void)
{
	int	min;
	int	max;
	int	*tab1;
	int	*tab2;
	int	*tab3;
	int	*tab4;

	min = 3;
	max = 8;
	tab1 = ft_range(min, max);
	printf("Pour min = %d et max = %d, tab1 =\n", min, max);
	ft_print_int_tab(tab1, max - min);
	free(tab1);
	min = 42;
	max = 42;
	tab2 = ft_range(min, max);
	printf("\nPour min = %d et max = %d, tab2 =\n", min, max);
	ft_print_int_tab(tab2, max - min);
	free(tab2);
	return (0);
	min = -42;
	max = 43;
	tab3 = ft_range(min, max);
	printf("\nPour min = %d et max = %d, tab3 =\n", min, max);
	ft_print_int_tab(tab3, max - min);
	free(tab3);
	min = 42;
	max = -1;
	tab4 = ft_range(min, max);
	printf("\nPour min = %d et max = %d, tab4 =\n", min, max);
	ft_print_int_tab(tab4, max - min);
	free(tab4);
	return (0);
}
e3r11p9% norminette -R CheckForbiddenSourceHeader test_ft_range.c             
test_ft_range.c: Error!
Error: TOO_MANY_VARS_FUNC   (line:  68, col:   1):	Too many variables declarations in a function
Error: TOO_MANY_LINES       (line:  96, col:   1):	Function has more than 25 lines
e3r11p9% gcc -Wall -Wextra -Werror -o test_ft_range ft_range.c test_ft_range.c
e3r11p9% ls -al                                                               
total 32
drwxr-xr-x 2 hauerbac 2023_paris  4096 Feb 22 18:00 .
drwxr-xr-x 4 hauerbac 2023_paris  4096 Feb 22 17:15 ..
-rw-r--r-- 1 hauerbac 2023_paris  1495 Feb 22 17:26 ft_range.c
-rwxr-xr-x 1 hauerbac 2023_paris 16312 Feb 22 18:00 test_ft_range
-rw-r--r-- 1 hauerbac 2023_paris  2299 Feb 22 18:00 test_ft_range.c
e3r11p9% ./test_ft_range                                       
Pour min = 3 et max = 8, tab1 =

Pour min = 42 et max = 42, tab2 =
e3r11p9% vi test_ft_range.c                                     
e3r11p9% cat test_ft_range.c                                     
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   test_ft_range.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: hauerbac <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2023/02/22 17:56:00 by hauerbac          #+#    #+#             */
/*   Updated: 2023/02/22 18:58:36 by hauerbac         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>

int	*ft_range(int min, int max);

void	ft_putnbr(int nb)
{
	long	nb_in_long;
	int		digit_to_char;

	nb_in_long = nb;
	if (nb_in_long < 0)
	{
		write(1, "-", 1);
		nb_in_long = nb_in_long * -1;
	}
	if (nb_in_long < 10)
	{
		digit_to_char = nb_in_long + '0';
		write(1, &digit_to_char, 1);
	}
	else
	{
		ft_putnbr(nb_in_long / 10);
		ft_putnbr(nb_in_long % 10);
	}
}

void	ft_print_int_tab(int *tab, int size)
{
	int	i;

	if (tab && size > 0)
	{
		write(1, "[", 1);
		i = 0;
		while (i < size)
		{
			ft_putnbr(tab[i]);
			if (i < size - 1)
				write(1, ", ", 2);
			i++;
		}
		write(1, "]", 1);
	}
}

int	main(void)
{
	int	min;
	int	max;
	int	*tab1;
	int	*tab2;
	int	*tab3;
	int	*tab4;

	min = 3;
	max = 8;
	tab1 = ft_range(min, max);
	printf("Pour min = %d et max = %d, tab1 =\n", min, max);
	ft_print_int_tab(tab1, max - min);
	free(tab1);
	min = 42;
	max = 42;
	tab2 = ft_range(min, max);
	printf("\nPour min = %d et max = %d, tab2 =\n", min, max);
	ft_print_int_tab(tab2, max - min);
	free(tab2);
	min = -42;
	max = 43;
	tab3 = ft_range(min, max);
	printf("\nPour min = %d et max = %d, tab3 =\n", min, max);
	ft_print_int_tab(tab3, max - min);
	free(tab3);
	min = 42;
	max = -1;
	tab4 = ft_range(min, max);
	printf("\nPour min = %d et max = %d, tab4 =\n", min, max);
	ft_print_int_tab(tab4, max - min);
	free(tab4);
	return (0);
}
e3r11p9% norminette -R CheckForbiddenSourceHeader test_ft_range.c             
test_ft_range.c: Error!
Error: TOO_MANY_VARS_FUNC   (line:  68, col:   1):	Too many variables declarations in a function
Error: TOO_MANY_LINES       (line:  95, col:   1):	Function has more than 25 lines
e3r11p9% gcc -Wall -Wextra -Werror -o test_ft_range ft_range.c test_ft_range.c
e3r11p9% ls -al                                                
total 32
drwxr-xr-x 2 hauerbac 2023_paris  4096 Feb 22 18:58 .
drwxr-xr-x 4 hauerbac 2023_paris  4096 Feb 22 17:15 ..
-rw-r--r-- 1 hauerbac 2023_paris  1495 Feb 22 17:26 ft_range.c
-rwxr-xr-x 1 hauerbac 2023_paris 16312 Feb 22 18:58 test_ft_range
-rw-r--r-- 1 hauerbac 2023_paris  2286 Feb 22 18:58 test_ft_range.c
e3r11p9% ./test_ft_range                                       
Pour min = 3 et max = 8, tab1 =

Pour min = 42 et max = 42, tab2 =

Pour min = -42 et max = 43, tab3 =

Pour min = 42 et max = -1, tab4 =
e3r11p9% vi test_ft_range.c                                     
e3r11p9% cat test_ft_range.c 
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   test_ft_range.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: hauerbac <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2023/02/22 17:56:00 by hauerbac          #+#    #+#             */
/*   Updated: 2023/02/22 19:07:10 by hauerbac         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>

int	*ft_range(int min, int max);

void	ft_putnbr(int nb)
{
	long	nb_in_long;
	int		digit_to_char;

	nb_in_long = nb;
	if (nb_in_long < 0)
	{
		write(1, "-", 1);
		nb_in_long = nb_in_long * -1;
	}
	if (nb_in_long < 10)
	{
		digit_to_char = nb_in_long + '0';
		write(1, &digit_to_char, 1);
	}
	else
	{
		ft_putnbr(nb_in_long / 10);
		ft_putnbr(nb_in_long % 10);
	}
}

void	ft_print_int_tab(int *tab, int size)
{
	int	i;

	if (tab != NULL && size > 0)
	{
		write(1, "[", 1);
		i = 0;
		while (i < size)
		{
			ft_putnbr(tab[i]);
			if (i < size - 1)
				write(1, ", ", 2);
			i++;
		}
		write(1, "]", 1);
	}
}

int	main(void)
{
	int	min;
	int	max;
	int	*tab1;
	int	*tab2;
	int	*tab3;
	int	*tab4;

	min = 3;
	max = 8;
	tab1 = ft_range(min, max);
	printf("Pour min = %d et max = %d, tab1 =\n", min, max);
	ft_print_int_tab(tab1, max - min);
	free(tab1);
	min = 42;
	max = 42;
	tab2 = ft_range(min, max);
	printf("\nPour min = %d et max = %d, tab2 =\n", min, max);
	ft_print_int_tab(tab2, max - min);
	free(tab2);
	min = -42;
	max = 43;
	tab3 = ft_range(min, max);
	printf("\nPour min = %d et max = %d, tab3 =\n", min, max);
	ft_print_int_tab(tab3, max - min);
	free(tab3);
	min = 42;
	max = -1;
	tab4 = ft_range(min, max);
	printf("\nPour min = %d et max = %d, tab4 =\n", min, max);
	ft_print_int_tab(tab4, max - min);
	free(tab4);
	return (0);
}
e3r11p9% norminette -R CheckForbiddenSourceHeader test_ft_range.c             
test_ft_range.c: Error!
Error: TOO_MANY_VARS_FUNC   (line:  68, col:   1):	Too many variables declarations in a function
Error: TOO_MANY_LINES       (line:  95, col:   1):	Function has more than 25 lines
e3r11p9% vi ft_range.c                                     
e3r11p9% cat ft_range.c                                    
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_range.c                                         :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: hauerbac <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2023/02/22 17:26:36 by hauerbac          #+#    #+#             */
/*   Updated: 2023/02/22 19:12:39 by hauerbac         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include <stdlib.h>

char	*ft_strncpy(char *dest, char *src, unsigned int n)
{
	unsigned int	i;

	if (src && dest && n > 0)
	{
		i = 0;
		while (i < n && src[i] != '\0')
		{
			dest[i] = src[i];
			i++;
		}
		while (i < n)
		{
			dest[i] = '\0';
			i++;
		}
	}
	return (dest);
}

int	*ft_range(int min, int max)
{
	int	range_len;
	int	*ptr;
	int	i;
	int	value;

	if (min < max)
	{
		range_len = max - min;
		ptr = (int *) malloc(range_len * sizeof(int));
		if (ptr)
		{
			value = min;
			i = 0;
			while (i < range_len && value < max)
				ptr[i++] = value++;
			return (ptr);
		}
	}
	return (NULL);
}
e3r11p9% norminette -R CheckForbiddenSourceHeader ft_range.c
ft_range.c: OK!
e3r11p9% gcc -Wall -Wextra -Werror -o test_ft_range ft_range.c test_ft_range.c
e3r11p9% ls -al                                                
total 32
drwxr-xr-x 2 hauerbac 2023_paris  4096 Feb 22 19:13 .
drwxr-xr-x 4 hauerbac 2023_paris  4096 Feb 22 17:15 ..
-rw-r--r-- 1 hauerbac 2023_paris  1494 Feb 22 19:12 ft_range.c
-rwxr-xr-x 1 hauerbac 2023_paris 16312 Feb 22 19:13 test_ft_range
-rw-r--r-- 1 hauerbac 2023_paris  2294 Feb 22 19:07 test_ft_range.c
e3r11p9% ./test_ft_range                                       
Pour min = 3 et max = 8, tab1 =
[3, 4, 5, 6, 7]
Pour min = 42 et max = 42, tab2 =

Pour min = -42 et max = 43, tab3 =
[-42, -41, -40, -39, -38, -37, -36, -35, -34, -33, -32, -31, -30, -29, -28, -27, -26, -25, -24, -23, -22, -21, -20, -19, -18, -17, -16, -15, -14, -13, -12, -11, -10, -9, -8, -7, -6, -5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42]
Pour min = 42 et max = -1, tab4 =
e3r11p9% cd ..
--------------------------------------------------------------------------------------------------------------------------------------
hauerbac (HÃ©lÃ¨ne)
 â€” 
Aujourdâ€™hui Ã  08:43
Bonjour,
Je ne comprends pas l'enonce du ex02/ft_ultimate_range.c : ne devrait-ce pas etre "Ã‰crire une fonction ft_ultimate_range qui alloue et assigne un tableau de tableaux dâ€™int." (au lieu de "Ã‰crire une fonction ft_ultimate_range qui alloue et assigne un tableau dâ€™int.")?

octoross (OcÃ©ane)
 â€” 
Aujourdâ€™hui Ã  08:50
Coucou !
Tu alloues un tableau de min Ã  max comme l'exo 1 mais cette fois qui est pointÃ© par range (je n'avais pas trop compris non plus tktðŸ˜…)

hauerbac (HÃ©lÃ¨ne)
 â€” 
Aujourdâ€™hui Ã  09:55
Merci. Je m'excuse d'insister autant, mais je suis vraiment surprise par la "faible complexification" par rapport a l'exercice precedent : cette interpretation de l'exo a-t-elle ete validee par la Moulinette?

ebouvier (Elliot)
 â€” 
Aujourdâ€™hui Ã  11:01
C'est bien un pointer sur un tableau d'int et non pas un tableau 2D
--------------------------------------------------------------------------------------------------------------------------------------
e3r11p9% cd
e3r11p9% cd c_07
e3r11p9% ls
ex00  ex01  ex02
e3r11p9% cd ex02
e3r11p9% ls
e3r11p9% vi ft_ultimate_range.c
e3r11p9% cd ex01
cd: no such file or directory: ex01
e3r11p9% cd ../ex01
e3r11p9% vi ft_range.c 
e3r11p9% cat ft_range.c 
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_range.c                                         :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: hauerbac <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2023/02/22 17:26:36 by hauerbac          #+#    #+#             */
/*   Updated: 2023/02/23 09:05:04 by hauerbac         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include <stdlib.h>

int	*ft_range(int min, int max)
{
	int	range_len;
	int	*ptr;
	int	i;
	int	value;

	if (min < max)
	{
		range_len = max - min;
		ptr = (int *) malloc(range_len * sizeof(int));
		if (ptr)
		{
			value = min;
			i = 0;
			while (i < range_len && value < max)
				ptr[i++] = value++;
			return (ptr);
		}
	}
	return (NULL);
}
e3r11p9% norminette -R CheckForbiddenSourceHeader ft_range.c 
ft_range.c: OK!
e3r11p9% gcc -Wall -Wextra -Werror -o test_ft_range ft_range.c test_ft_range.c 
e3r11p9% ls -al
total 32
drwxr-xr-x 2 hauerbac 2023_paris  4096 Feb 23 09:07 .
drwxr-xr-x 5 hauerbac 2023_paris  4096 Feb 22 19:16 ..
-rw-r--r-- 1 hauerbac 2023_paris  1235 Feb 23 09:05 ft_range.c
-rwxr-xr-x 1 hauerbac 2023_paris 16280 Feb 23 09:07 test_ft_range
-rw-r--r-- 1 hauerbac 2023_paris  2294 Feb 22 19:07 test_ft_range.c
e3r11p9% ./test_ft_range 
Pour min = 3 et max = 8, tab1 =
[3, 4, 5, 6, 7]
Pour min = 42 et max = 42, tab2 =

Pour min = -42 et max = 43, tab3 =
[-42, -41, -40, -39, -38, -37, -36, -35, -34, -33, -32, -31, -30, -29, -28, -27, -26, -25, -24, -23, -22, -21, -20, -19, -18, -17, -16, -15, -14, -13, -12, -11, -10, -9, -8, -7, -6, -5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42]
Pour min = 42 et max = -1, tab4 =
e3r11p9% cd ../ex02
e3r11p9% ls
ft_ultimate_range.c
e3r11p9% cat ft_ultimate_range.c 
#include <stdlib.h>

int	*ft_range(int min, int max)
{
	int	range_len;
	int	*ptr;
	int	i;
	int	value;

	if (min < max)
	{
		range_len = max - min;
		ptr = (int *) malloc(range_len * sizeof(int));
		if (ptr)
		{
			value = min;
			i = 0;
			while (i < range_len && value < max)
				ptr[i++] = value++;
			return (ptr);
		}
	}
	return (NULL);
}

int	ft_ultimate_range(int **range, int min, int max)
{
	int	range_len;
	int	*ptr;
	int	i;
	int	value;

	if (min < max)
	{
		range_len = max - min;
		range = (int **) malloc(range_len * sizeof(int *));
		if (range)
		{
			value = min;
			i = 0;
			while (i < range_len && value < max)
			{
				ptr = ft_range(min, max);
				if (ptr)
				{
					range[i++] = ptr;
					value++;
				}
				else
					return (-1);

			}
			return (range_len);
		}
		else
		{
			range = NULL;
			return (-1);
		}
	}
	else
	{
		range = NULL;
		return (0);
	}
}
e3r11p9% norminette -R CheckForbiddenSourceHeader ft_ultimate_range.c         
ft_ultimate_range.c: Error!
Error: INVALID_HEADER       (line:   1, col:   1):	Missing or invalid 42 header
Error: EMPTY_LINE_FUNCTION  (line:  51, col:   1):	Empty line in function
Error: TOO_MANY_LINES       (line:  66, col:   1):	Function has more than 25 lines
e3r11p9% vi ft_ultimate_range.c 
e3r11p9% cat ft_ultimate_range.c 
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_ultimate_range.c                                :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: hauerbac <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2023/02/23 09:50:54 by hauerbac          #+#    #+#             */
/*   Updated: 2023/02/23 09:50:57 by hauerbac         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include <stdlib.h>

int	*ft_range(int min, int max)
{
	int	range_len;
	int	*ptr;
	int	i;
	int	value;

	if (min < max)
	{
		range_len = max - min;
		ptr = (int *) malloc(range_len * sizeof(int));
		if (ptr)
		{
			value = min;
			i = 0;
			while (i < range_len && value < max)
				ptr[i++] = value++;
			return (ptr);
		}
	}
	return (NULL);
}

int	ft_subranges(int **range, int range_len, int min, int max)
{
	int	*ptr;
	int	i;
	int	value;

	value = min;
	i = 0;
	while (i < range_len && value < max)
	{
		ptr = ft_range(min, max);
		if (ptr)
		{
			range[i++] = ptr;
			value++;
		}
		else
			return (-1);
	}
	if (i == range_len)
		return (range_len);
	else
		return (-1);
}

int	ft_ultimate_range(int **range, int min, int max)
{
	int	range_len;
	int	nb;

	if (min < max)
	{
		range_len = max - min;
		range = (int **) malloc(range_len * sizeof(int *));
		if (range)
		{
			nb = ft_subranges(range, range_len, min, max);
			return (nb);
		}
		else
		{
			range = NULL;
			return (-1);
		}
	}
	else
	{
		range = NULL;
		return (0);
	}
}
e3r11p9% norminette -R CheckForbiddenSourceHeader ft_ultimate_range.c
ft_ultimate_range.c: OK!
e3r11p9% cp ft_ultimate_range.c ft_ultimate_range_0.c
e3r11p9% vi ft_ultimate_range
e3r11p9% ls -al                
total 20
drwxr-xr-x 2 hauerbac 2023_paris 4096 Feb 23 10:18 .
drwxr-xr-x 5 hauerbac 2023_paris 4096 Feb 22 19:16 ..
-rw-r--r-- 1 hauerbac 2023_paris 1441 Feb 23 10:18 ft_ultimate_range
-rw-r--r-- 1 hauerbac 2023_paris 1930 Feb 23 09:57 ft_ultimate_range_0.c
-rw-r--r-- 1 hauerbac 2023_paris 1930 Feb 23 09:50 ft_ultimate_range.c
e3r11p9% rm ft_ultimate_range.c
e3r11p9% mv ft_ultimate_range ft_ultimate_range.c
e3r11p9% ls -al
total 16
drwxr-xr-x 2 hauerbac 2023_paris 4096 Feb 23 10:20 .
drwxr-xr-x 5 hauerbac 2023_paris 4096 Feb 22 19:16 ..
-rw-r--r-- 1 hauerbac 2023_paris 1930 Feb 23 09:57 ft_ultimate_range_0.c
-rw-r--r-- 1 hauerbac 2023_paris 1441 Feb 23 10:18 ft_ultimate_range.c
e3r11p9% norminette -R CheckForbiddenSourceHeader ft_ultimate_range.c
ft_ultimate_range.c: Error!
	Error: Unrecognized token line 1, col 81
e3r11p9% vi ft_ultimate_range.c                                     
e3r11p9% norminette -R CheckForbiddenSourceHeader ft_ultimate_range.c
ft_ultimate_range.c: Error!
Error: TOO_MANY_LINES       (line:  54, col:   1):	Function has more than 25 lines
e3r11p9% vi ft_ultimate_range.c 
e3r11p9% norminette -R CheckForbiddenSourceHeader ft_ultimate_range.c
ft_ultimate_range.c: OK!
e3r11p9% cat ft_ultimate_range.c 
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_ultimate_range.c                                :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: hauerbac <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2023/02/23 10:23:31 by hauerbac          #+#    #+#             */
/*   Updated: 2023/02/23 10:29:02 by hauerbac         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include <stdlib.h>

int	*ft_range(int min, int max)
{
	int	range_len;
	int	*ptr;
	int	i;
	int	value;

	if (min < max)
	{
		range_len = max - min;
		ptr = (int *) malloc(range_len * sizeof(int));
		if (ptr)
		{
			value = min;
			i = 0;
			while (i < range_len && value < max)
				ptr[i++] = value++;
			if (i == range_len)
				return (ptr);
			else
				return (NULL);
		}
	}
	return (NULL);
}

int	ft_ultimate_range(int **range, int min, int max)
{
	int	range_len;
	int	*ptr;
	int	i;
	int	value;

	if (min < max)
	{
		range_len = max - min;
		ptr = ft_range(min, max);
		if (ptr)
		{
			range = &ptr;
			return (range_len);
		}
		else
		{
			range = NULL;
			return (-1);
		}
	}
	else
	{
		range = NULL;
		return (0);
	}
}
e3r11p9% cp ../ex01/test_ft_range.c test_ft_ultimate_range.c 
e3r11p9% vi test_ft_ultimate_range.c 
e3r11p9% norminette -R CheckForbiddenSourceHeader test_ft_ultimate_range.c 
test_ft_ultimate_range.c: Error!
Error: LINE_TOO_LONG        (line:  61, col: 145):	line too long
Error: LINE_TOO_LONG        (line:  63, col: 101):	line too long
Error: TOO_MANY_VARS_FUNC   (line:  73, col:   1):	Too many variables declarations in a function
Error: TOO_MANY_VARS_FUNC   (line:  74, col:   1):	Too many variables declarations in a function
Error: TOO_MANY_VARS_FUNC   (line:  75, col:   1):	Too many variables declarations in a function
Error: TOO_MANY_VARS_FUNC   (line:  76, col:   1):	Too many variables declarations in a function
Error: TOO_MANY_VARS_FUNC   (line:  77, col:   1):	Too many variables declarations in a function
Error: TOO_MANY_LINES       (line: 108, col:   1):	Function has more than 25 lines
e3r11p9% cat test_ft_ultimate_range.c 
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   test_ft_ultimate_range.c                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: hauerbac <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2023/02/22 17:56:00 by hauerbac          #+#    #+#             */
/*   Updated: 2023/02/23 12:14:11 by hauerbac         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>

int	ft_ultimate_range(int **range, int min, int max);

void	ft_putnbr(int nb)
{
	long	nb_in_long;
	int		digit_to_char;

	nb_in_long = nb;
	if (nb_in_long < 0)
	{
		write(1, "-", 1);
		nb_in_long = nb_in_long * -1;
	}
	if (nb_in_long < 10)
	{
		digit_to_char = nb_in_long + '0';
		write(1, &digit_to_char, 1);
	}
	else
	{
		ft_putnbr(nb_in_long / 10);
		ft_putnbr(nb_in_long % 10);
	}
}

void	ft_print_int_tab(int *tab, int size)
{
	int	i;

	printf("The returned size of range is %d.\n", size);
	if (tab != NULL && size > 0)
	{
		write(1, "[", 1);
		i = 0;
		while (i < size)
		{
			ft_putnbr(tab[i]);
			if (i < size - 1)
				write(1, ", ", 2);
			i++;
		}
		write(1, "]", 1);
	}
	else if (size == 0)
		printf("\nNone array - Reason : If the value of min is greater or equal to maxâ€™s value, range will point on NULL and it should return 0.");
	else if (size == -1)
		printf("\nIncomplete array - Reason : The size of range should be returned (or -1 on error).");
}

int	main(void)
{
	int	min;
	int	max;
	int	**tab1;
	int	tab1_size;
	int	**tab2;
	int	tab2_size;
	int	**tab3;
	int	tab3_size;
	int	**tab4;
	int	tab4_size;

	min = 3;
	max = 8;
	tab1_size = ft_ultimate_range(tab1, min, max);
	printf("Pour min = %d et max = %d, tab1 =\n", min, max);
	ft_print_int_tab(*tab1, tab1_size);
	free(*tab1);
	free(tab1);
	min = 42;
	max = 42;
	tab2_size = ft_ultimate_range(tab2, min, max);
	printf("\nPour min = %d et max = %d, tab2 =\n", min, max);
	ft_print_int_tab(*tab2, tab2_size);
	free(*tab2);
	free(tab2);
	min = -42;
	max = 43;
	tab3_size = ft_ultimate_range(tab3, min, max);
	printf("\nPour min = %d et max = %d, tab3 =\n", min, max);
	ft_print_int_tab(*tab3, tab3_size);
	free(*tab3);
	free(tab3);
	min = 42;
	max = -1;
	tab4_size = ft_ultimate_range(tab4, min, max);
	printf("\nPour min = %d et max = %d, tab4 =\n", min, max);
	ft_print_int_tab(*tab4, tab4_size);
	free(*tab4);
	free(tab4);
	return (0);
}
e3r11p9% gcc -Wall -Wextra -Werror -o test_ft_ultimate_range ft_ultimate_range.c test_ft_ultimate_range.c 
ft_ultimate_range.c: In function â€˜ft_ultimate_rangeâ€™:
ft_ultimate_range.c:46:6: error: unused variable â€˜valueâ€™ [-Werror=unused-variable]
   46 |  int value;
      |      ^~~~~
ft_ultimate_range.c:45:6: error: unused variable â€˜iâ€™ [-Werror=unused-variable]
   45 |  int i;
      |      ^
ft_ultimate_range.c:41:29: error: parameter â€˜rangeâ€™ set but not used [-Werror=unused-but-set-parameter]
   41 | int ft_ultimate_range(int **range, int min, int max)
      |                       ~~~~~~^~~~~
cc1: all warnings being treated as errors
test_ft_ultimate_range.c: In function â€˜mainâ€™:
test_ft_ultimate_range.c:81:14: error: â€˜tab1â€™ is used uninitialized in this function [-Werror=uninitialized]
   81 |  tab1_size = ft_ultimate_range(tab1, min, max);
      |              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
test_ft_ultimate_range.c:88:14: error: â€˜tab2â€™ is used uninitialized in this function [-Werror=uninitialized]
   88 |  tab2_size = ft_ultimate_range(tab2, min, max);
      |              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
test_ft_ultimate_range.c:95:14: error: â€˜tab3â€™ is used uninitialized in this function [-Werror=uninitialized]
   95 |  tab3_size = ft_ultimate_range(tab3, min, max);
      |              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
test_ft_ultimate_range.c:102:14: error: â€˜tab4â€™ is used uninitialized in this function [-Werror=uninitialized]
  102 |  tab4_size = ft_ultimate_range(tab4, min, max);
      |              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
cc1: all warnings being treated as errors
e3r11p9% vi ft_ultimate_range.c                                      
e3r11p9% norminette -R CheckForbiddenSourceHeader ft_ultimate_range.c                               
ft_ultimate_range.c: OK!
e3r11p9% cat ft_ultimate_range.c                                   
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_ultimate_range.c                                :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: hauerbac <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2023/02/23 10:23:31 by hauerbac          #+#    #+#             */
/*   Updated: 2023/02/23 12:29:20 by hauerbac         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include <stdlib.h>

int	*ft_range(int min, int max)
{
	int	range_len;
	int	*ptr;
	int	i;
	int	value;

	if (min < max)
	{
		range_len = max - min;
		ptr = (int *) malloc(range_len * sizeof(int));
		if (ptr)
		{
			value = min;
			i = 0;
			while (i < range_len && value < max)
				ptr[i++] = value++;
			if (i == range_len)
				return (ptr);
			else
				return (NULL);
		}
	}
	return (NULL);
}

int	ft_ultimate_range(int **range, int min, int max)
{
	int	range_len;
	int	*ptr;

	range = NULL;
	if (min < max)
	{
		range_len = max - min;
		ptr = ft_range(min, max);
		if (ptr)
		{
			range = &ptr;
			return (range_len);
		}
		else
			return (-1);
	}
	else
		return (0);
}
e3r11p9% vi test_ft_ultimate_range.c 
e3r11p9% norminette -R CheckForbiddenSourceHeader test_ft_ultimate_range.c 
test_ft_ultimate_range.c: Error!
Error: LINE_TOO_LONG        (line:  61, col: 145):	line too long
Error: LINE_TOO_LONG        (line:  63, col: 101):	line too long
Error: DECL_ASSIGN_LINE     (line:  70, col:  16):	Declaration and assignation on a single line
Error: DECL_ASSIGN_LINE     (line:  72, col:  16):	Declaration and assignation on a single line
Error: TOO_MANY_VARS_FUNC   (line:  73, col:   1):	Too many variables declarations in a function
Error: TOO_MANY_VARS_FUNC   (line:  74, col:   1):	Too many variables declarations in a function
Error: DECL_ASSIGN_LINE     (line:  74, col:  16):	Declaration and assignation on a single line
Error: TOO_MANY_VARS_FUNC   (line:  75, col:   1):	Too many variables declarations in a function
Error: TOO_MANY_VARS_FUNC   (line:  76, col:   1):	Too many variables declarations in a function
Error: DECL_ASSIGN_LINE     (line:  76, col:  16):	Declaration and assignation on a single line
Error: TOO_MANY_VARS_FUNC   (line:  77, col:   1):	Too many variables declarations in a function
Error: TOO_MANY_LINES       (line: 108, col:   1):	Function has more than 25 lines
e3r11p9% cat test_ft_ultimate_range.c                                   
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   test_ft_ultimate_range.c                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: hauerbac <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2023/02/22 17:56:00 by hauerbac          #+#    #+#             */
/*   Updated: 2023/02/23 12:32:44 by hauerbac         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>

int	ft_ultimate_range(int **range, int min, int max);

void	ft_putnbr(int nb)
{
	long	nb_in_long;
	int		digit_to_char;

	nb_in_long = nb;
	if (nb_in_long < 0)
	{
		write(1, "-", 1);
		nb_in_long = nb_in_long * -1;
	}
	if (nb_in_long < 10)
	{
		digit_to_char = nb_in_long + '0';
		write(1, &digit_to_char, 1);
	}
	else
	{
		ft_putnbr(nb_in_long / 10);
		ft_putnbr(nb_in_long % 10);
	}
}

void	ft_print_int_tab(int *tab, int size)
{
	int	i;

	printf("The returned size of range is %d.\n", size);
	if (tab != NULL && size > 0)
	{
		write(1, "[", 1);
		i = 0;
		while (i < size)
		{
			ft_putnbr(tab[i]);
			if (i < size - 1)
				write(1, ", ", 2);
			i++;
		}
		write(1, "]", 1);
	}
	else if (size == 0)
		printf("\nNone array - Reason : If the value of min is greater or equal to maxâ€™s value, range will point on NULL and it should return 0.");
	else if (size == -1)
		printf("\nIncomplete array - Reason : The size of range should be returned (or -1 on error).");
}

int	main(void)
{
	int	min;
	int	max;
	int	**tab1 = NULL;
	int	tab1_size;
	int	**tab2 = NULL;
	int	tab2_size;
	int	**tab3 = NULL;
	int	tab3_size;
	int	**tab4 = NULL;
	int	tab4_size;

	min = 3;
	max = 8;
	tab1_size = ft_ultimate_range(tab1, min, max);
	printf("Pour min = %d et max = %d, tab1 =\n", min, max);
	ft_print_int_tab(*tab1, tab1_size);
	free(*tab1);
	free(tab1);
	min = 42;
	max = 42;
	tab2_size = ft_ultimate_range(tab2, min, max);
	printf("\nPour min = %d et max = %d, tab2 =\n", min, max);
	ft_print_int_tab(*tab2, tab2_size);
	free(*tab2);
	free(tab2);
	min = -42;
	max = 43;
	tab3_size = ft_ultimate_range(tab3, min, max);
	printf("\nPour min = %d et max = %d, tab3 =\n", min, max);
	ft_print_int_tab(*tab3, tab3_size);
	free(*tab3);
	free(tab3);
	min = 42;
	max = -1;
	tab4_size = ft_ultimate_range(tab4, min, max);
	printf("\nPour min = %d et max = %d, tab4 =\n", min, max);
	ft_print_int_tab(*tab4, tab4_size);
	free(*tab4);
	free(tab4);
	return (0);
}
e3r11p9% gcc -Wall -Wextra -Werror -o test_ft_ultimate_range ft_ultimate_range.c test_ft_ultimate_range.c
ft_ultimate_range.c: In function â€˜ft_ultimate_rangeâ€™:
ft_ultimate_range.c:41:29: error: parameter â€˜rangeâ€™ set but not used [-Werror=unused-but-set-parameter]
   41 | int ft_ultimate_range(int **range, int min, int max)
      |                       ~~~~~~^~~~~
cc1: all warnings being treated as errors
e3r11p9% vi ft_ultimate_range.c                                      
e3r11p9% cat ft_ultimate_range.c 
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_ultimate_range.c                                :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: hauerbac <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2023/02/23 10:23:31 by hauerbac          #+#    #+#             */
/*   Updated: 2023/02/23 12:34:59 by hauerbac         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include <stdlib.h>

int	*ft_range(int min, int max)
{
	int	range_len;
	int	*ptr;
	int	i;
	int	value;

	if (min < max)
	{
		range_len = max - min;
		ptr = (int *) malloc(range_len * sizeof(int));
		if (ptr)
		{
			value = min;
			i = 0;
			while (i < range_len && value < max)
				ptr[i++] = value++;
			if (i == range_len)
				return (ptr);
			else
				return (NULL);
		}
	}
	return (NULL);
}

int	ft_ultimate_range(int **range, int min, int max)
{
	int	range_len;
	int	*ptr;

	range = NULL;
	if (min < max)
	{
		range_len = max - min;
		ptr = ft_range(min, max);
		if (ptr)
		{
			range = &ptr;
			return (range_len);
		}
		if (range == NULL)
			return (-1);
	}
	else
		return (0);
}
e3r11p9% norminette -R CheckForbiddenSourceHeader ft_ultimate_range.c 
ft_ultimate_range.c: OK!
e3r11p9% gcc -Wall -Wextra -Werror -o test_ft_ultimate_range ft_ultimate_range.c test_ft_ultimate_range.c
ft_ultimate_range.c: In function â€˜ft_ultimate_rangeâ€™:
ft_ultimate_range.c:61:1: error: control reaches end of non-void function [-Werror=return-type]
   61 | }
      | ^
cc1: all warnings being treated as errors
e3r11p9% vi ft_ultimate_range.c                                     
e3r11p9% cat ft_ultimate_range.c                                                                       
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_ultimate_range.c                                :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: hauerbac <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2023/02/23 10:23:31 by hauerbac          #+#    #+#             */
/*   Updated: 2023/02/23 12:37:17 by hauerbac         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include <stdlib.h>

int	*ft_range(int min, int max)
{
	int	range_len;
	int	*ptr;
	int	i;
	int	value;

	if (min < max)
	{
		range_len = max - min;
		ptr = (int *) malloc(range_len * sizeof(int));
		if (ptr)
		{
			value = min;
			i = 0;
			while (i < range_len && value < max)
				ptr[i++] = value++;
			if (i == range_len)
				return (ptr);
			else
				return (NULL);
		}
	}
	return (NULL);
}

int	ft_ultimate_range(int **range, int min, int max)
{
	int	range_len;
	int	*ptr;

	range = NULL;
	if (min < max)
	{
		range_len = max - min;
		ptr = ft_range(min, max);
		if (ptr)
		{
			range = &ptr;
			return (range_len);
		}
		else if (range == NULL)
			return (-1);
	}
	else
		return (0);
}
e3r11p9% norminette -R CheckForbiddenSourceHeader ft_ultimate_range.c                                    
ft_ultimate_range.c: OK!
e3r11p9% gcc -Wall -Wextra -Werror -o test_ft_ultimate_range ft_ultimate_range.c test_ft_ultimate_range.c
ft_ultimate_range.c: In function â€˜ft_ultimate_rangeâ€™:
ft_ultimate_range.c:61:1: error: control reaches end of non-void function [-Werror=return-type]
   61 | }
      | ^
cc1: all warnings being treated as errors
e3r11p9% vi ft_ultimate_range.c                                     
e3r11p9% cat ft_ultimate_range.c 
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_ultimate_range.c                                :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: hauerbac <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2023/02/23 10:23:31 by hauerbac          #+#    #+#             */
/*   Updated: 2023/02/23 12:39:24 by hauerbac         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include <stdlib.h>

int	*ft_range(int min, int max)
{
	int	range_len;
	int	*ptr;
	int	i;
	int	value;

	if (min < max)
	{
		range_len = max - min;
		ptr = (int *) malloc(range_len * sizeof(int));
		if (ptr)
		{
			value = min;
			i = 0;
			while (i < range_len && value < max)
				ptr[i++] = value++;
			if (i == range_len)
				return (ptr);
			else
				return (NULL);
		}
	}
	return (NULL);
}

int	ft_ultimate_range(int **range, int min, int max)
{
	int	range_len;
	int	*ptr;

	range = NULL;
	if (min < max)
	{
		range_len = max - min;
		ptr = ft_range(min, max);
		if (ptr)
		{
			range = &ptr;
			return (range_len);
		}
		else if (range == NULL)
			return (-1);
		return (-1);
	}
	else
		return (0);
}
e3r11p9% norminette -R CheckForbiddenSourceHeader ft_ultimate_range.c                                    
ft_ultimate_range.c: OK!
e3r11p9% gcc -Wall -Wextra -Werror -o test_ft_ultimate_range ft_ultimate_range.c test_ft_ultimate_range.c
e3r11p9% ls -al
total 36
drwxr-xr-x 2 hauerbac 2023_paris  4096 Feb 23 12:39 .
drwxr-xr-x 5 hauerbac 2023_paris  4096 Feb 22 19:16 ..
-rw-r--r-- 1 hauerbac 2023_paris  1930 Feb 23 09:57 ft_ultimate_range_0.c
-rw-r--r-- 1 hauerbac 2023_paris  1598 Feb 23 12:39 ft_ultimate_range.c
-rwxr-xr-x 1 hauerbac 2023_paris 16328 Feb 23 12:39 test_ft_ultimate_range
-rw-r--r-- 1 hauerbac 2023_paris  2890 Feb 23 12:32 test_ft_ultimate_range.c
e3r11p9% ./test_ft_ultimate_range 
Pour min = 3 et max = 8, tab1 =
zsh: segmentation fault (core dumped)  ./test_ft_ultimate_range
e3r11p9% gcc -g3 -Wall -Wextra -Werror -o test_ft_ultimate_range ft_ultimate_range.c test_ft_ultimate_range.c
e3r11p9% ls -al
total 92
drwxr-xr-x 2 hauerbac 2023_paris  4096 Feb 23 12:51 .
drwxr-xr-x 5 hauerbac 2023_paris  4096 Feb 22 19:16 ..
-rw-r--r-- 1 hauerbac 2023_paris  1930 Feb 23 09:57 ft_ultimate_range_0.c
-rw-r--r-- 1 hauerbac 2023_paris  1598 Feb 23 12:39 ft_ultimate_range.c
-rwxr-xr-x 1 hauerbac 2023_paris 71584 Feb 23 12:51 test_ft_ultimate_range
-rw-r--r-- 1 hauerbac 2023_paris  2890 Feb 23 12:32 test_ft_ultimate_range.c
e3r11p9% valgrind ./test_ft_ultimate_range 
==97188== Memcheck, a memory error detector
==97188== Copyright (C) 2002-2017, and GNU GPL'd, by Julian Seward et al.
==97188== Using Valgrind-3.18.1 and LibVEX; rerun with -h for copyright info
==97188== Command: ./test_ft_ultimate_range
==97188== 
Pour min = 3 et max = 8, tab1 =
==97188== Invalid read of size 8
==97188==    at 0x109558: main (test_ft_ultimate_range.c:83)
==97188==  Address 0x0 is not stack'd, malloc'd or (recently) free'd
==97188== 
==97188== 
==97188== Process terminating with default action of signal 11 (SIGSEGV)
==97188==  Access not within mapped region at address 0x0
==97188==    at 0x109558: main (test_ft_ultimate_range.c:83)
==97188==  If you believe this happened as a result of a stack
==97188==  overflow in your program's main thread (unlikely but
==97188==  possible), you can try to increase the size of the
==97188==  main thread stack using the --main-stacksize= flag.
==97188==  The main thread stack size used in this run was 8388608.
==97188== 
==97188== HEAP SUMMARY:
==97188==     in use at exit: 1,044 bytes in 2 blocks
==97188==   total heap usage: 2 allocs, 0 frees, 1,044 bytes allocated
==97188== 
==97188== LEAK SUMMARY:
==97188==    definitely lost: 20 bytes in 1 blocks
==97188==    indirectly lost: 0 bytes in 0 blocks
==97188==      possibly lost: 0 bytes in 0 blocks
==97188==    still reachable: 1,024 bytes in 1 blocks
==97188==         suppressed: 0 bytes in 0 blocks
==97188== Rerun with --leak-check=full to see details of leaked memory
==97188== 
==97188== For lists of detected and suppressed errors, rerun with: -s
==97188== ERROR SUMMARY: 1 errors from 1 contexts (suppressed: 0 from 0)
zsh: segmentation fault (core dumped)  valgrind ./test_ft_ultimate_range
e3r11p9% gcc -g -Wall -Wextra -Werror -o test_ft_ultimate_range ft_ultimate_range.c test_ft_ultimate_range.c 
e3r11p9% ls -al
total 40
drwxr-xr-x 2 hauerbac 2023_paris  4096 Feb 23 12:54 .
drwxr-xr-x 5 hauerbac 2023_paris  4096 Feb 22 19:16 ..
-rw-r--r-- 1 hauerbac 2023_paris  1930 Feb 23 09:57 ft_ultimate_range_0.c
-rw-r--r-- 1 hauerbac 2023_paris  1598 Feb 23 12:39 ft_ultimate_range.c
-rwxr-xr-x 1 hauerbac 2023_paris 18912 Feb 23 12:54 test_ft_ultimate_range
-rw-r--r-- 1 hauerbac 2023_paris  2890 Feb 23 12:32 test_ft_ultimate_range.c
e3r11p9% lldb test_ft_ultimate_range 
(lldb) target create "test_ft_ultimate_range"
Current executable set to '/mnt/nfs/homes/hauerbac/c_07/ex02/test_ft_ultimate_range' (x86_64).
(lldb) b main
Breakpoint 1: where = test_ft_ultimate_range`main + 12 at test_ft_ultimate_range.c:70:8, address = 0x00000000000014f6
(lldb) run
warning: (x86_64) /usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2 unsupported DW_FORM value: 0x1f
Process 97615 launched: '/mnt/nfs/homes/hauerbac/c_07/ex02/test_ft_ultimate_range' (x86_64)
warning: (x86_64) /lib64/ld-linux-x86-64.so.2 unsupported DW_FORM value: 0x1f
warning: (x86_64) /lib/x86_64-linux-gnu/libc.so.6 unsupported DW_FORM value: 0x1f
Process 97615 stopped
* thread #1, name = 'test_ft_ultimat', stop reason = breakpoint 1.1
    frame #0: 0x00005555555554f6 test_ft_ultimate_range`main at test_ft_ultimate_range.c:70:8
   67  	{
   68  		int	min;
   69  		int	max;
-> 70  		int	**tab1 = NULL;
   71  		int	tab1_size;
   72  		int	**tab2 = NULL;
   73  		int	tab2_size;
(lldb) n
Process 97615 stopped
* thread #1, name = 'test_ft_ultimat', stop reason = step over
    frame #0: 0x00005555555554fe test_ft_ultimate_range`main at test_ft_ultimate_range.c:72:8
   69  		int	max;
   70  		int	**tab1 = NULL;
   71  		int	tab1_size;
-> 72  		int	**tab2 = NULL;
   73  		int	tab2_size;
   74  		int	**tab3 = NULL;
   75  		int	tab3_size;
(lldb) n
Process 97615 stopped
* thread #1, name = 'test_ft_ultimat', stop reason = step over
    frame #0: 0x0000555555555506 test_ft_ultimate_range`main at test_ft_ultimate_range.c:74:8
   71  		int	tab1_size;
   72  		int	**tab2 = NULL;
   73  		int	tab2_size;
-> 74  		int	**tab3 = NULL;
   75  		int	tab3_size;
   76  		int	**tab4 = NULL;
   77  		int	tab4_size;
(lldb) n
Process 97615 stopped
* thread #1, name = 'test_ft_ultimat', stop reason = step over
    frame #0: 0x000055555555550e test_ft_ultimate_range`main at test_ft_ultimate_range.c:76:8
   73  		int	tab2_size;
   74  		int	**tab3 = NULL;
   75  		int	tab3_size;
-> 76  		int	**tab4 = NULL;
   77  		int	tab4_size;
   78  	
   79  		min = 3;
(lldb) n
Process 97615 stopped
* thread #1, name = 'test_ft_ultimat', stop reason = step over
    frame #0: 0x0000555555555516 test_ft_ultimate_range`main at test_ft_ultimate_range.c:79:6
   76  		int	**tab4 = NULL;
   77  		int	tab4_size;
   78  	
-> 79  		min = 3;
   80  		max = 8;
   81  		tab1_size = ft_ultimate_range(tab1, min, max);
   82  		printf("Pour min = %d et max = %d, tab1 =\n", min, max);
(lldb) n
Process 97615 stopped
* thread #1, name = 'test_ft_ultimat', stop reason = step over
    frame #0: 0x000055555555551d test_ft_ultimate_range`main at test_ft_ultimate_range.c:80:6
   77  		int	tab4_size;
   78  	
   79  		min = 3;
-> 80  		max = 8;
   81  		tab1_size = ft_ultimate_range(tab1, min, max);
   82  		printf("Pour min = %d et max = %d, tab1 =\n", min, max);
   83  		ft_print_int_tab(*tab1, tab1_size);
(lldb) n
Process 97615 stopped
* thread #1, name = 'test_ft_ultimat', stop reason = step over
    frame #0: 0x0000555555555524 test_ft_ultimate_range`main at test_ft_ultimate_range.c:81:14
   78  	
   79  		min = 3;
   80  		max = 8;
-> 81  		tab1_size = ft_ultimate_range(tab1, min, max);
   82  		printf("Pour min = %d et max = %d, tab1 =\n", min, max);
   83  		ft_print_int_tab(*tab1, tab1_size);
   84  		free(*tab1);
(lldb) n
Process 97615 stopped
* thread #1, name = 'test_ft_ultimat', stop reason = step over
    frame #0: 0x000055555555553b test_ft_ultimate_range`main at test_ft_ultimate_range.c:82:2
   79  		min = 3;
   80  		max = 8;
   81  		tab1_size = ft_ultimate_range(tab1, min, max);
-> 82  		printf("Pour min = %d et max = %d, tab1 =\n", min, max);
   83  		ft_print_int_tab(*tab1, tab1_size);
   84  		free(*tab1);
   85  		free(tab1);
(lldb) n
Pour min = 3 et max = 8, tab1 =
Process 97615 stopped
* thread #1, name = 'test_ft_ultimat', stop reason = step over
    frame #0: 0x0000555555555554 test_ft_ultimate_range`main at test_ft_ultimate_range.c:83:2
   80  		max = 8;
   81  		tab1_size = ft_ultimate_range(tab1, min, max);
   82  		printf("Pour min = %d et max = %d, tab1 =\n", min, max);
-> 83  		ft_print_int_tab(*tab1, tab1_size);
   84  		free(*tab1);
   85  		free(tab1);
   86  		min = 42;
(lldb) n
Process 97615 stopped
* thread #1, name = 'test_ft_ultimat', stop reason = signal SIGSEGV: invalid address (fault address: 0x0)
    frame #0: 0x0000555555555558 test_ft_ultimate_range`main at test_ft_ultimate_range.c:83:2
   80  		max = 8;
   81  		tab1_size = ft_ultimate_range(tab1, min, max);
   82  		printf("Pour min = %d et max = %d, tab1 =\n", min, max);
-> 83  		ft_print_int_tab(*tab1, tab1_size);
   84  		free(*tab1);
   85  		free(tab1);
   86  		min = 42;
(lldb) n
Process 97615 exited with status = 11 (0x0000000b) 
(lldb) q
-------------------------------------------------------------------------------------------------------------------------
e3r11p9% pwd
/mnt/nfs/homes/hauerbac/c_07/ex02
e3r11p9% vi test_ft_ultimate_range.c
e3r11p9% cat test_ft_ultimate_range.c
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   test_ft_ultimate_range.c                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: hauerbac <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2023/02/22 17:56:00 by hauerbac          #+#    #+#             */
/*   Updated: 2023/02/23 15:24:08 by hauerbac         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>

int	ft_ultimate_range(int **range, int min, int max);

void	ft_putnbr(int nb)
{
	long	nb_in_long;
	int		digit_to_char;

	nb_in_long = nb;
	if (nb_in_long < 0)
	{
		write(1, "-", 1);
		nb_in_long = nb_in_long * -1;
	}
	if (nb_in_long < 10)
	{
		digit_to_char = nb_in_long + '0';
		write(1, &digit_to_char, 1);
	}
	else
	{
		ft_putnbr(nb_in_long / 10);
		ft_putnbr(nb_in_long % 10);
	}
}

void	ft_print_int_tab(int *tab, int size)
{
	int	i;

	printf("The returned size of range is %d.\n", size);
	if (tab != NULL && size > 0)
	{
		write(1, "[", 1);
		i = 0;
		while (i < size)
		{
			ft_putnbr(tab[i]);
			if (i < size - 1)
				write(1, ", ", 2);
			i++;
		}
		write(1, "]", 1);
	}
	else if (size == 0)
		printf("\nNone array - Reason : If the value of min is greater or equal to maxâ€™s value, range will point on NULL and it should return 0.");
	else if (size == -1)
		printf("\nIncomplete array - Reason : The size of range should be returned (or -1 on error).");
}

int	main(void)
{
	int	min;
	int	max;
	int	**tab1 = NULL;
	int	tab1_size;
	int	**tab2 = NULL;
	int	tab2_size;
	int	**tab3 = NULL;
	int	tab3_size;
	int	**tab4 = NULL;
	int	tab4_size;

	min = 3;
	max = 8;
	tab1_size = ft_ultimate_range(tab1, min, max);
	printf("Pour min = %d et max = %d, tab1 =\n", min, max);
	printf("tab1 = %d\n", tab1);
	ft_print_int_tab(*tab1, tab1_size);
	free(*tab1);
	free(tab1);
	min = 42;
	max = 42;
	tab2_size = ft_ultimate_range(tab2, min, max);
	printf("\nPour min = %d et max = %d, tab2 =\n", min, max);
	ft_print_int_tab(*tab2, tab2_size);
	free(*tab2);
	free(tab2);
	min = -42;
	max = 43;
	tab3_size = ft_ultimate_range(tab3, min, max);
	printf("\nPour min = %d et max = %d, tab3 =\n", min, max);
	ft_print_int_tab(*tab3, tab3_size);
	free(*tab3);
	free(tab3);
	min = 42;
	max = -1;
	tab4_size = ft_ultimate_range(tab4, min, max);
	printf("\nPour min = %d et max = %d, tab4 =\n", min, max);
	ft_print_int_tab(*tab4, tab4_size);
	free(*tab4);
	free(tab4);
	return (0);
}
e3r11p9% gcc -Wall -Wextra -Werror -o test_ft_ultimate_range -g ft_ultimate_range.c test_ft_ultimate_range.c 
test_ft_ultimate_range.c: In function â€˜mainâ€™:
test_ft_ultimate_range.c:83:18: error: format â€˜%dâ€™ expects argument of type â€˜intâ€™, but argument 2 has type â€˜int **â€™ [-Werror=format=]
   83 |  printf("tab1 = %d\n", tab1);
      |                 ~^     ~~~~
      |                  |     |
      |                  int   int **
cc1: all warnings being treated as errors
e3r11p9% vi test_ft_ultimate_range.c                                                                       
e3r11p9% cat test_ft_ultimate_range.c                                                                       
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   test_ft_ultimate_range.c                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: hauerbac <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2023/02/22 17:56:00 by hauerbac          #+#    #+#             */
/*   Updated: 2023/02/23 15:26:21 by hauerbac         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>

int	ft_ultimate_range(int **range, int min, int max);

void	ft_putnbr(int nb)
{
	long	nb_in_long;
	int		digit_to_char;

	nb_in_long = nb;
	if (nb_in_long < 0)
	{
		write(1, "-", 1);
		nb_in_long = nb_in_long * -1;
	}
	if (nb_in_long < 10)
	{
		digit_to_char = nb_in_long + '0';
		write(1, &digit_to_char, 1);
	}
	else
	{
		ft_putnbr(nb_in_long / 10);
		ft_putnbr(nb_in_long % 10);
	}
}

void	ft_print_int_tab(int *tab, int size)
{
	int	i;

	printf("The returned size of range is %d.\n", size);
	if (tab != NULL && size > 0)
	{
		write(1, "[", 1);
		i = 0;
		while (i < size)
		{
			ft_putnbr(tab[i]);
			if (i < size - 1)
				write(1, ", ", 2);
			i++;
		}
		write(1, "]", 1);
	}
	else if (size == 0)
		printf("\nNone array - Reason : If the value of min is greater or equal to maxâ€™s value, range will point on NULL and it should return 0.");
	else if (size == -1)
		printf("\nIncomplete array - Reason : The size of range should be returned (or -1 on error).");
}

int	main(void)
{
	int	min;
	int	max;
	int	**tab1 = NULL;
	int	tab1_size;
	int	**tab2 = NULL;
	int	tab2_size;
	int	**tab3 = NULL;
	int	tab3_size;
	int	**tab4 = NULL;
	int	tab4_size;

	min = 3;
	max = 8;
	tab1_size = ft_ultimate_range(tab1, min, max);
	printf("Pour min = %d et max = %d, tab1 =\n", min, max);
	printf("*tab1 = %d\n", *tab1);
	ft_print_int_tab(*tab1, tab1_size);
	free(*tab1);
	free(tab1);
	min = 42;
	max = 42;
	tab2_size = ft_ultimate_range(tab2, min, max);
	printf("\nPour min = %d et max = %d, tab2 =\n", min, max);
	ft_print_int_tab(*tab2, tab2_size);
	free(*tab2);
	free(tab2);
	min = -42;
	max = 43;
	tab3_size = ft_ultimate_range(tab3, min, max);
	printf("\nPour min = %d et max = %d, tab3 =\n", min, max);
	ft_print_int_tab(*tab3, tab3_size);
	free(*tab3);
	free(tab3);
	min = 42;
	max = -1;
	tab4_size = ft_ultimate_range(tab4, min, max);
	printf("\nPour min = %d et max = %d, tab4 =\n", min, max);
	ft_print_int_tab(*tab4, tab4_size);
	free(*tab4);
	free(tab4);
	return (0);
}
e3r11p9% gcc -Wall -Wextra -Werror -o test_ft_ultimate_range -g ft_ultimate_range.c test_ft_ultimate_range.c
test_ft_ultimate_range.c: In function â€˜mainâ€™:
test_ft_ultimate_range.c:83:19: error: format â€˜%dâ€™ expects argument of type â€˜intâ€™, but argument 2 has type â€˜int *â€™ [-Werror=format=]
   83 |  printf("*tab1 = %d\n", *tab1);
      |                  ~^     ~~~~~
      |                   |     |
      |                   int   int *
      |                  %ls
cc1: all warnings being treated as errors
e3r11p9% vi test_ft_ultimate_range.c                                                                       
e3r11p9% cat test_ft_ultimate_range.c                                                                       
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   test_ft_ultimate_range.c                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: hauerbac <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2023/02/22 17:56:00 by hauerbac          #+#    #+#             */
/*   Updated: 2023/02/23 15:26:55 by hauerbac         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>

int	ft_ultimate_range(int **range, int min, int max);

void	ft_putnbr(int nb)
{
	long	nb_in_long;
	int		digit_to_char;

	nb_in_long = nb;
	if (nb_in_long < 0)
	{
		write(1, "-", 1);
		nb_in_long = nb_in_long * -1;
	}
	if (nb_in_long < 10)
	{
		digit_to_char = nb_in_long + '0';
		write(1, &digit_to_char, 1);
	}
	else
	{
		ft_putnbr(nb_in_long / 10);
		ft_putnbr(nb_in_long % 10);
	}
}

void	ft_print_int_tab(int *tab, int size)
{
	int	i;

	printf("The returned size of range is %d.\n", size);
	if (tab != NULL && size > 0)
	{
		write(1, "[", 1);
		i = 0;
		while (i < size)
		{
			ft_putnbr(tab[i]);
			if (i < size - 1)
				write(1, ", ", 2);
			i++;
		}
		write(1, "]", 1);
	}
	else if (size == 0)
		printf("\nNone array - Reason : If the value of min is greater or equal to maxâ€™s value, range will point on NULL and it should return 0.");
	else if (size == -1)
		printf("\nIncomplete array - Reason : The size of range should be returned (or -1 on error).");
}

int	main(void)
{
	int	min;
	int	max;
	int	**tab1 = NULL;
	int	tab1_size;
	int	**tab2 = NULL;
	int	tab2_size;
	int	**tab3 = NULL;
	int	tab3_size;
	int	**tab4 = NULL;
	int	tab4_size;

	min = 3;
	max = 8;
	tab1_size = ft_ultimate_range(tab1, min, max);
	printf("Pour min = %d et max = %d, tab1 =\n", min, max);
	printf("*tab1 = %ls\n", *tab1);
	ft_print_int_tab(*tab1, tab1_size);
	free(*tab1);
	free(tab1);
	min = 42;
	max = 42;
	tab2_size = ft_ultimate_range(tab2, min, max);
	printf("\nPour min = %d et max = %d, tab2 =\n", min, max);
	ft_print_int_tab(*tab2, tab2_size);
	free(*tab2);
	free(tab2);
	min = -42;
	max = 43;
	tab3_size = ft_ultimate_range(tab3, min, max);
	printf("\nPour min = %d et max = %d, tab3 =\n", min, max);
	ft_print_int_tab(*tab3, tab3_size);
	free(*tab3);
	free(tab3);
	min = 42;
	max = -1;
	tab4_size = ft_ultimate_range(tab4, min, max);
	printf("\nPour min = %d et max = %d, tab4 =\n", min, max);
	ft_print_int_tab(*tab4, tab4_size);
	free(*tab4);
	free(tab4);
	return (0);
}
e3r11p9% gcc -Wall -Wextra -Werror -o test_ft_ultimate_range -g ft_ultimate_range.c test_ft_ultimate_range.c
e3r11p9% ls -al
total 40
drwxr-xr-x 2 hauerbac 2023_paris  4096 Feb 23 15:27 .
drwxr-xr-x 5 hauerbac 2023_paris  4096 Feb 22 19:16 ..
-rw-r--r-- 1 hauerbac 2023_paris  1930 Feb 23 09:57 ft_ultimate_range_0.c
-rw-r--r-- 1 hauerbac 2023_paris  1598 Feb 23 12:39 ft_ultimate_range.c
-rwxr-xr-x 1 hauerbac 2023_paris 18912 Feb 23 15:27 test_ft_ultimate_range
-rw-r--r-- 1 hauerbac 2023_paris  2923 Feb 23 15:26 test_ft_ultimate_range.c
e3r11p9% lldb test_ft_ultimate_range 
(lldb) target create "test_ft_ultimate_range"
Current executable set to '/mnt/nfs/homes/hauerbac/c_07/ex02/test_ft_ultimate_range' (x86_64).
(lldb) b main
Breakpoint 1: where = test_ft_ultimate_range`main + 12 at test_ft_ultimate_range.c:70:8, address = 0x00000000000014f6
(lldb) run
warning: (x86_64) /usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2 unsupported DW_FORM value: 0x1f
Process 119526 launched: '/mnt/nfs/homes/hauerbac/c_07/ex02/test_ft_ultimate_range' (x86_64)
warning: (x86_64) /lib64/ld-linux-x86-64.so.2 unsupported DW_FORM value: 0x1f
warning: (x86_64) /lib/x86_64-linux-gnu/libc.so.6 unsupported DW_FORM value: 0x1f
Process 119526 stopped
* thread #1, name = 'test_ft_ultimat', stop reason = breakpoint 1.1
    frame #0: 0x00005555555554f6 test_ft_ultimate_range`main at test_ft_ultimate_range.c:70:8
   67  	{
   68  		int	min;
   69  		int	max;
-> 70  		int	**tab1 = NULL;
   71  		int	tab1_size;
   72  		int	**tab2 = NULL;
   73  		int	tab2_size;
(lldb) gui
(lldb) q
Quitting LLDB will kill one or more processes. Do you really want to proceed: [Y/n] y
Pour min = 3 et max = 8, tab1 =
e3r11p9% vi test_ft_ultimate_range.c                                                                       
e3r11p9% cat test_ft_ultimate_range.c                                                                       
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   test_ft_ultimate_range.c                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: hauerbac <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2023/02/22 17:56:00 by hauerbac          #+#    #+#             */
/*   Updated: 2023/02/23 15:31:52 by hauerbac         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>

int	ft_ultimate_range(int **range, int min, int max);

void	ft_putnbr(int nb)
{
	long	nb_in_long;
	int		digit_to_char;

	nb_in_long = nb;
	if (nb_in_long < 0)
	{
		write(1, "-", 1);
		nb_in_long = nb_in_long * -1;
	}
	if (nb_in_long < 10)
	{
		digit_to_char = nb_in_long + '0';
		write(1, &digit_to_char, 1);
	}
	else
	{
		ft_putnbr(nb_in_long / 10);
		ft_putnbr(nb_in_long % 10);
	}
}

void	ft_print_int_tab(int *tab, int size)
{
	int	i;

	printf("The returned size of range is %d.\n", size);
	if (tab != NULL && size > 0)
	{
		write(1, "[", 1);
		i = 0;
		while (i < size)
		{
			ft_putnbr(tab[i]);
			if (i < size - 1)
				write(1, ", ", 2);
			i++;
		}
		write(1, "]", 1);
	}
	else if (size == 0)
		printf("\nNone array - Reason : If the value of min is greater or equal to maxâ€™s value, range will point on NULL and it should return 0.");
	else if (size == -1)
		printf("\nIncomplete array - Reason : The size of range should be returned (or -1 on error).");
}

int	main(void)
{
	int	min;
	int	max;
	int	**tab1;
	int	tab1_size;
	int	**tab2 = NULL;
	int	tab2_size;
	int	**tab3 = NULL;
	int	tab3_size;
	int	**tab4 = NULL;
	int	tab4_size;

	min = 3;
	max = 8;
	tab1_size = ft_ultimate_range(tab1, min, max);
	printf("Pour min = %d et max = %d, tab1 =\n", min, max);
	printf("*tab1 = %ls\n", *tab1);
	ft_print_int_tab(*tab1, tab1_size);
	free(*tab1);
	free(tab1);
	min = 42;
	max = 42;
	tab2_size = ft_ultimate_range(tab2, min, max);
	printf("\nPour min = %d et max = %d, tab2 =\n", min, max);
	ft_print_int_tab(*tab2, tab2_size);
	free(*tab2);
	free(tab2);
	min = -42;
	max = 43;
	tab3_size = ft_ultimate_range(tab3, min, max);
	printf("\nPour min = %d et max = %d, tab3 =\n", min, max);
	ft_print_int_tab(*tab3, tab3_size);
	free(*tab3);
	free(tab3);
	min = 42;
	max = -1;
	tab4_size = ft_ultimate_range(tab4, min, max);
	printf("\nPour min = %d et max = %d, tab4 =\n", min, max);
	ft_print_int_tab(*tab4, tab4_size);
	free(*tab4);
	free(tab4);
	return (0);
}
e3r11p9% gcc -Wall -Wextra -Werror -o test_ft_ultimate_range -g ft_ultimate_range.c test_ft_ultimate_range.c
test_ft_ultimate_range.c: In function â€˜mainâ€™:
test_ft_ultimate_range.c:81:14: error: â€˜tab1â€™ is used uninitialized in this function [-Werror=uninitialized]
   81 |  tab1_size = ft_ultimate_range(tab1, min, max);
      |              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
cc1: all warnings being treated as errors
e3r11p9% gcc -Wextra -Werror -o test_ft_ultimate_range -g ft_ultimate_range.c test_ft_ultimate_range.c 
test_ft_ultimate_range.c: In function â€˜mainâ€™:
test_ft_ultimate_range.c:81:14: error: â€˜tab1â€™ is used uninitialized in this function [-Werror=uninitialized]
   81 |  tab1_size = ft_ultimate_range(tab1, min, max);
      |              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
cc1: all warnings being treated as errors
e3r11p9% gcc -Werror -o test_ft_ultimate_range -g ft_ultimate_range.c test_ft_ultimate_range.c 
e3r11p9% lldb test_ft_ultimate_range                                                                       
(lldb) target create "test_ft_ultimate_range"
Current executable set to '/mnt/nfs/homes/hauerbac/c_07/ex02/test_ft_ultimate_range' (x86_64).
(lldb) b main
Breakpoint 1: where = test_ft_ultimate_range`main + 12 at test_ft_ultimate_range.c:72:8, address = 0x00000000000014f6
(lldb) run
warning: (x86_64) /usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2 unsupported DW_FORM value: 0x1f
Process 119879 launched: '/mnt/nfs/homes/hauerbac/c_07/ex02/test_ft_ultimate_range' (x86_64)
warning: (x86_64) /lib64/ld-linux-x86-64.so.2 unsupported DW_FORM value: 0x1f
warning: (x86_64) /lib/x86_64-linux-gnu/libc.so.6 unsupported DW_FORM value: 0x1f
Process 119879 stopped
* thread #1, name = 'test_ft_ultimat', stop reason = breakpoint 1.1
    frame #0: 0x00005555555554f6 test_ft_ultimate_range`main at test_ft_ultimate_range.c:72:8
   69  		int	max;
   70  		int	**tab1;
   71  		int	tab1_size;
-> 72  		int	**tab2 = NULL;
   73  		int	tab2_size;
   74  		int	**tab3 = NULL;
   75  		int	tab3_size;
(lldb) gui
(lldb) q
Quitting LLDB will kill one or more processes. Do you really want to proceed: [Y/n] y
e3r11p9% vi test_ft_ultimate_range.c                                                                       
e3r11p9% cat test_ft_ultimate_range.c 
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   test_ft_ultimate_range.c                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: hauerbac <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2023/02/22 17:56:00 by hauerbac          #+#    #+#             */
/*   Updated: 2023/02/23 15:34:32 by hauerbac         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>

int	ft_ultimate_range(int **range, int min, int max);

void	ft_putnbr(int nb)
{
	long	nb_in_long;
	int		digit_to_char;

	nb_in_long = nb;
	if (nb_in_long < 0)
	{
		write(1, "-", 1);
		nb_in_long = nb_in_long * -1;
	}
	if (nb_in_long < 10)
	{
		digit_to_char = nb_in_long + '0';
		write(1, &digit_to_char, 1);
	}
	else
	{
		ft_putnbr(nb_in_long / 10);
		ft_putnbr(nb_in_long % 10);
	}
}

void	ft_print_int_tab(int *tab, int size)
{
	int	i;

	printf("The returned size of range is %d.\n", size);
	if (tab != NULL && size > 0)
	{
		write(1, "[", 1);
		i = 0;
		while (i < size)
		{
			ft_putnbr(tab[i]);
			if (i < size - 1)
				write(1, ", ", 2);
			i++;
		}
		write(1, "]", 1);
	}
	else if (size == 0)
		printf("\nNone array - Reason : If the value of min is greater or equal to maxâ€™s value, range will point on NULL and it should return 0.");
	else if (size == -1)
		printf("\nIncomplete array - Reason : The size of range should be returned (or -1 on error).");
}

int	main(void)
{
	int	min;
	int	max;
	int	**tab1 = NULL;
	int	tab1_size;
	int	**tab2 = NULL;
	int	tab2_size;
	int	**tab3 = NULL;
	int	tab3_size;
	int	**tab4 = NULL;
	int	tab4_size;

	min = 3;
	max = 8;
	tab1_size = ft_ultimate_range(tab1, min, max);
	printf("Pour min = %d et max = %d, tab1 =\n", min, max);
	printf("*tab1 = %ls\n", *tab1);
	ft_print_int_tab(*tab1, tab1_size);
	free(*tab1);
	free(tab1);
	min = 42;
	max = 42;
	tab2_size = ft_ultimate_range(tab2, min, max);
	printf("\nPour min = %d et max = %d, tab2 =\n", min, max);
	ft_print_int_tab(*tab2, tab2_size);
	free(*tab2);
	free(tab2);
	min = -42;
	max = 43;
	tab3_size = ft_ultimate_range(tab3, min, max);
	printf("\nPour min = %d et max = %d, tab3 =\n", min, max);
	ft_print_int_tab(*tab3, tab3_size);
	free(*tab3);
	free(tab3);
	min = 42;
	max = -1;
	tab4_size = ft_ultimate_range(tab4, min, max);
	printf("\nPour min = %d et max = %d, tab4 =\n", min, max);
	ft_print_int_tab(*tab4, tab4_size);
	free(*tab4);
	free(tab4);
	return (0);
}
e3r11p9% vi ft_ultimate_range.c 
e3r11p9% cat ft_ultimate_range.c 
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_ultimate_range.c                                :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: hauerbac <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2023/02/23 10:23:31 by hauerbac          #+#    #+#             */
/*   Updated: 2023/02/23 15:35:10 by hauerbac         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include <stdlib.h>

int	*ft_range(int min, int max)
{
	int	range_len;
	int	*ptr;
	int	i;
	int	value;

	if (min < max)
	{
		range_len = max - min;
		ptr = (int *) malloc(range_len * sizeof(int));
		if (ptr)
		{
			value = min;
			i = 0;
			while (i < range_len && value < max)
				ptr[i++] = value++;
			if (i == range_len)
				return (ptr);
			else
				return (NULL);
		}
	}
	return (NULL);
}

int	ft_ultimate_range(int **range, int min, int max)
{
	int	range_len;
	int	*ptr;

	range = NULL;
	if (min < max)
	{
		range_len = max - min;
		ptr = ft_range(min, max);
		if (ptr)
		{
			*range = &ptr;
			return (range_len);
		}
		else if (range == NULL)
			return (-1);
		return (-1);
	}
	else
		return (0);
}
e3r11p9% gcc -Wextra -Werror -o test_ft_ultimate_range -g ft_ultimate_range.c test_ft_ultimate_range.c
ft_ultimate_range.c: In function â€˜ft_ultimate_rangeâ€™:
ft_ultimate_range.c:53:11: error: assignment to â€˜int *â€™ from incompatible pointer type â€˜int **â€™ [-Werror=incompatible-pointer-types]
   53 |    *range = &ptr;
      |           ^
cc1: all warnings being treated as errors
e3r11p9% vi ft_ultimate_range.c                                                                      
e3r11p9% cat ft_ultimate_range.c                                                                      
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_ultimate_range.c                                :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: hauerbac <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2023/02/23 10:23:31 by hauerbac          #+#    #+#             */
/*   Updated: 2023/02/23 15:36:01 by hauerbac         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include <stdlib.h>

int	*ft_range(int min, int max)
{
	int	range_len;
	int	*ptr;
	int	i;
	int	value;

	if (min < max)
	{
		range_len = max - min;
		ptr = (int *) malloc(range_len * sizeof(int));
		if (ptr)
		{
			value = min;
			i = 0;
			while (i < range_len && value < max)
				ptr[i++] = value++;
			if (i == range_len)
				return (ptr);
			else
				return (NULL);
		}
	}
	return (NULL);
}

int	ft_ultimate_range(int **range, int min, int max)
{
	int	range_len;
	int	*ptr;

	range = NULL;
	if (min < max)
	{
		range_len = max - min;
		ptr = ft_range(min, max);
		if (ptr)
		{
			*range = ptr;
			return (range_len);
		}
		else if (range == NULL)
			return (-1);
		return (-1);
	}
	else
		return (0);
}
e3r11p9% norminette -R CheckForbiddenSourceHeader ft_ultimate_range.c
ft_ultimate_range.c: OK!
e3r11p9% norminette -R CheckForbiddenSourceHeader test_ft_ultimate_range.c
test_ft_ultimate_range.c: Error!
Error: LINE_TOO_LONG        (line:  61, col: 145):	line too long
Error: LINE_TOO_LONG        (line:  63, col: 101):	line too long
Error: DECL_ASSIGN_LINE     (line:  70, col:  16):	Declaration and assignation on a single line
Error: DECL_ASSIGN_LINE     (line:  72, col:  16):	Declaration and assignation on a single line
Error: TOO_MANY_VARS_FUNC   (line:  73, col:   1):	Too many variables declarations in a function
Error: TOO_MANY_VARS_FUNC   (line:  74, col:   1):	Too many variables declarations in a function
Error: DECL_ASSIGN_LINE     (line:  74, col:  16):	Declaration and assignation on a single line
Error: TOO_MANY_VARS_FUNC   (line:  75, col:   1):	Too many variables declarations in a function
Error: TOO_MANY_VARS_FUNC   (line:  76, col:   1):	Too many variables declarations in a function
Error: DECL_ASSIGN_LINE     (line:  76, col:  16):	Declaration and assignation on a single line
Error: TOO_MANY_VARS_FUNC   (line:  77, col:   1):	Too many variables declarations in a function
Error: TOO_MANY_LINES       (line: 109, col:   1):	Function has more than 25 lines
e3r11p9% gcc -Wextra -Werror -o test_ft_ultimate_range -g ft_ultimate_range.c test_ft_ultimate_range.c
e3r11p9% ls -al
total 40
drwxr-xr-x 2 hauerbac 2023_paris  4096 Feb 23 15:37 .
drwxr-xr-x 5 hauerbac 2023_paris  4096 Feb 22 19:16 ..
-rw-r--r-- 1 hauerbac 2023_paris  1930 Feb 23 09:57 ft_ultimate_range_0.c
-rw-r--r-- 1 hauerbac 2023_paris  1598 Feb 23 15:36 ft_ultimate_range.c
-rwxr-xr-x 1 hauerbac 2023_paris 18904 Feb 23 15:37 test_ft_ultimate_range
-rw-r--r-- 1 hauerbac 2023_paris  2923 Feb 23 15:34 test_ft_ultimate_range.c
e3r11p9% lldb test_ft_ultimate_range 
(lldb) target create "test_ft_ultimate_range"
Current executable set to '/mnt/nfs/homes/hauerbac/c_07/ex02/test_ft_ultimate_range' (x86_64).
(lldb) b main
Breakpoint 1: where = test_ft_ultimate_range`main + 12 at test_ft_ultimate_range.c:70:8, address = 0x00000000000014d4
(lldb) run
warning: (x86_64) /usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2 unsupported DW_FORM value: 0x1f
Process 120560 launched: '/mnt/nfs/homes/hauerbac/c_07/ex02/test_ft_ultimate_range' (x86_64)
warning: (x86_64) /lib64/ld-linux-x86-64.so.2 unsupported DW_FORM value: 0x1f
warning: (x86_64) /lib/x86_64-linux-gnu/libc.so.6 unsupported DW_FORM value: 0x1f
Process 120560 stopped
* thread #1, name = 'test_ft_ultimat', stop reason = breakpoint 1.1
    frame #0: 0x00005555555554d4 test_ft_ultimate_range`main at test_ft_ultimate_range.c:70:8
   67  	{
   68  		int	min;
   69  		int	max;
-> 70  		int	**tab1 = NULL;
   71  		int	tab1_size;
   72  		int	**tab2 = NULL;
   73  		int	tab2_size;
(lldb) gui
(lldb) q
Quitting LLDB will kill one or more processes. Do you really want to proceed: [Y/n] y
e3r11p9% vi ft_ultimate_range.c                                     
e3r11p9% cat ft_ultimate_range.c 
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_ultimate_range.c                                :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: hauerbac <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2023/02/23 10:23:31 by hauerbac          #+#    #+#             */
/*   Updated: 2023/02/23 15:43:43 by hauerbac         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include <stdlib.h>

int	*ft_range(int min, int max)
{
	int	range_len;
	int	*ptr;
	int	i;
	int	value;

	if (min < max)
	{
		range_len = max - min;
		ptr = (int *) malloc(range_len * sizeof(int));
		if (ptr)
		{
			value = min;
			i = 0;
			while (i < range_len && value < max)
				ptr[i++] = value++;
			if (i == range_len)
				return (ptr);
			else
				return (NULL);
		}
	}
	return (NULL);
}

int	ft_ultimate_range(int **range, int min, int max)
{
	int	range_len;
	int	*ptr;

	if (min < max)
	{
		range = (int **) malloc(sizeof(int *));
		if (range == NULL)
			return (-1);
		range_len = max - min;
		ptr = ft_range(min, max);
		if (ptr)
		{
			*range = &ptr;
			return (range_len);
		}
		return (-1);
	}
	else
		return (0);
}
e3r11p9% norminette -R CheckForbiddenSourceHeader ft_ultimate_range.c                            
ft_ultimate_range.c: OK!
e3r11p9% gcc -Wextra -Werror -o test_ft_ultimate_range -g ft_ultimate_range.c test_ft_ultimate_range.c
ft_ultimate_range.c: In function â€˜ft_ultimate_rangeâ€™:
ft_ultimate_range.c:55:11: error: assignment to â€˜int *â€™ from incompatible pointer type â€˜int **â€™ [-Werror=incompatible-pointer-types]
   55 |    *range = &ptr;
      |           ^
cc1: all warnings being treated as errors
e3r11p9% vi ft_ultimate_range.c                                     
e3r11p9% cat ft_ultimate_range.c                                     
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_ultimate_range.c                                :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: hauerbac <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2023/02/23 10:23:31 by hauerbac          #+#    #+#             */
/*   Updated: 2023/02/23 15:45:09 by hauerbac         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include <stdlib.h>

int	*ft_range(int min, int max)
{
	int	range_len;
	int	*ptr;
	int	i;
	int	value;

	if (min < max)
	{
		range_len = max - min;
		ptr = (int *) malloc(range_len * sizeof(int));
		if (ptr)
		{
			value = min;
			i = 0;
			while (i < range_len && value < max)
				ptr[i++] = value++;
			if (i == range_len)
				return (ptr);
			else
				return (NULL);
		}
	}
	return (NULL);
}

int	ft_ultimate_range(int **range, int min, int max)
{
	int	range_len;
	int	*ptr;

	if (min < max)
	{
		range = (int **) malloc(sizeof(int *));
		if (range == NULL)
			return (-1);
		range_len = max - min;
		ptr = ft_range(min, max);
		if (ptr)
		{
			range = &ptr;
			return (range_len);
		}
		return (-1);
	}
	else
		return (0);
}
e3r11p9% norminette -R CheckForbiddenSourceHeader ft_ultimate_range.c                                 
ft_ultimate_range.c: OK!
e3r11p9% gcc -Wextra -Werror -o test_ft_ultimate_range -g ft_ultimate_range.c test_ft_ultimate_range.c
e3r11p9% lldb test_ft_ultimate_range                                
(lldb) target create "test_ft_ultimate_range"
Current executable set to '/mnt/nfs/homes/hauerbac/c_07/ex02/test_ft_ultimate_range' (x86_64).
(lldb) b main
Breakpoint 1: where = test_ft_ultimate_range`main + 12 at test_ft_ultimate_range.c:70:8, address = 0x00000000000014fc
(lldb) run
warning: (x86_64) /usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2 unsupported DW_FORM value: 0x1f
Process 121363 launched: '/mnt/nfs/homes/hauerbac/c_07/ex02/test_ft_ultimate_range' (x86_64)
warning: (x86_64) /lib64/ld-linux-x86-64.so.2 unsupported DW_FORM value: 0x1f
warning: (x86_64) /lib/x86_64-linux-gnu/libc.so.6 unsupported DW_FORM value: 0x1f
Process 121363 stopped
* thread #1, name = 'test_ft_ultimat', stop reason = breakpoint 1.1
    frame #0: 0x00005555555554fc test_ft_ultimate_range`main at test_ft_ultimate_range.c:70:8
   67  	{
   68  		int	min;
   69  		int	max;
-> 70  		int	**tab1 = NULL;
   71  		int	tab1_size;
   72  		int	**tab2 = NULL;
   73  		int	tab2_size;
(lldb) gui
(lldb) q
Quitting LLDB will kill one or more processes. Do you really want to proceed: [Y/n] y
e3r11p9% vi ft_ultimate_range.c                                     
e3r11p9% cat ft_ultimate_range.c 
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_ultimate_range.c                                :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: hauerbac <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2023/02/23 10:23:31 by hauerbac          #+#    #+#             */
/*   Updated: 2023/02/23 16:19:15 by hauerbac         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include <stdlib.h>

int	*ft_range(int min, int max)
{
	int	range_len;
	int	*ptr;
	int	i;
	int	value;

	if (min < max)
	{
		range_len = max - min;
		ptr = (int *) malloc(range_len * sizeof(int));
		if (ptr)
		{
			value = min;
			i = 0;
			while (i < range_len && value < max)
				ptr[i++] = value++;
			if (i == range_len)
				return (ptr);
			else
				return (NULL);
		}
	}
	return (NULL);
}

int	ft_ultimate_range(int **range, int min, int max)
{
	int	range_len;
	int	*ptr;

	range = NULL;
	if (min < max)
	{
		/*range = (int **) malloc(sizeof(int *));
		if (range == NULL)
			return (-1);*/
		range_len = max - min;
		ptr = ft_range(min, max);
		if (ptr)
		{
			range = &ptr;
			return (range_len);
		}
		else if (range == NULL)
			return (-1);
		return (-1);
	}
	else
		return (0);
}
e3r11p9% vi test_ft_ultimate_range.c
e3r11p9% cat test_ft_ultimate_range.c 
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   test_ft_ultimate_range.c                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: hauerbac <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2023/02/22 17:56:00 by hauerbac          #+#    #+#             */
/*   Updated: 2023/02/23 16:21:40 by hauerbac         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>

int	ft_ultimate_range(int **range, int min, int max);

void	ft_putnbr(int nb)
{
	long	nb_in_long;
	int		digit_to_char;

	nb_in_long = nb;
	if (nb_in_long < 0)
	{
		write(1, "-", 1);
		nb_in_long = nb_in_long * -1;
	}
	if (nb_in_long < 10)
	{
		digit_to_char = nb_in_long + '0';
		write(1, &digit_to_char, 1);
	}
	else
	{
		ft_putnbr(nb_in_long / 10);
		ft_putnbr(nb_in_long % 10);
	}
}

void	ft_print_int_tab(int *tab, int size)
{
	int	i;

	printf("The returned size of range is %d.\n", size);
	if (tab != NULL && size > 0)
	{
		write(1, "[", 1);
		i = 0;
		while (i < size)
		{
			ft_putnbr(tab[i]);
			if (i < size - 1)
				write(1, ", ", 2);
			i++;
		}
		write(1, "]", 1);
	}
	else if (size == 0)
		printf("\nNone array - Reason : If the value of min is greater or equal to maxâ€™s value, range will point on NULL and it should return 0.");
	else if (size == -1)
		printf("\nIncomplete array - Reason : The size of range should be returned (or -1 on error).");
}

int	main(void)
{
	int	min;
	int	max;
	int	*tab1 = NULL;
	int	tab1_size;
	int	*tab2 = NULL;
	int	tab2_size;
	int	*tab3 = NULL;
	int	tab3_size;
	int	*tab4 = NULL;
	int	tab4_size;

	min = 3;
	max = 8;
	tab1_size = ft_ultimate_range(&tab1, min, max);
	printf("Pour min = %d et max = %d, tab1 =\n", min, max);
	printf("*tab1 = %ls\n", *tab1);
	ft_print_int_tab(tab1, tab1_size);
	free(*tab1);
	free(tab1);
	/*min = 42;
	max = 42;
	tab2_size = ft_ultimate_range(tab2, min, max);
	printf("\nPour min = %d et max = %d, tab2 =\n", min, max);
	ft_print_int_tab(*tab2, tab2_size);
	free(*tab2);
	free(tab2);
	min = -42;
	max = 43;
	tab3_size = ft_ultimate_range(tab3, min, max);
	printf("\nPour min = %d et max = %d, tab3 =\n", min, max);
	ft_print_int_tab(*tab3, tab3_size);
	free(*tab3);
	free(tab3);
	min = 42;
	max = -1;
	tab4_size = ft_ultimate_range(tab4, min, max);
	printf("\nPour min = %d et max = %d, tab4 =\n", min, max);
	ft_print_int_tab(*tab4, tab4_size);
	free(*tab4);
	free(tab4);*/
	return (0);
}
e3r11p9% gcc -Wextra -Werror -o test_ft_ultimate_range -g ft_ultimate_range.c test_ft_ultimate_range.c
test_ft_ultimate_range.c: In function â€˜mainâ€™:
test_ft_ultimate_range.c:83:20: error: format â€˜%lsâ€™ expects argument of type â€˜wchar_t *â€™, but argument 2 has type â€˜intâ€™ [-Werror=format=]
   83 |  printf("*tab1 = %ls\n", *tab1);
      |                  ~~^     ~~~~~
      |                    |     |
      |                    int * int
      |                  %d
test_ft_ultimate_range.c:85:7: error: passing argument 1 of â€˜freeâ€™ makes pointer from integer without a cast [-Werror=int-conversion]
   85 |  free(*tab1);
      |       ^~~~~
      |       |
      |       int
In file included from test_ft_ultimate_range.c:15:
/usr/include/stdlib.h:555:25: note: expected â€˜void *â€™ but argument is of type â€˜intâ€™
  555 | extern void free (void *__ptr) __THROW;
      |                   ~~~~~~^~~~~
cc1: all warnings being treated as errors
e3r11p9% vi test_ft_ultimate_range.c                                                             
e3r11p9% cat test_ft_ultimate_range.c                                                                 
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   test_ft_ultimate_range.c                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: hauerbac <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2023/02/22 17:56:00 by hauerbac          #+#    #+#             */
/*   Updated: 2023/02/23 16:25:50 by hauerbac         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>

int	ft_ultimate_range(int **range, int min, int max);

void	ft_putnbr(int nb)
{
	long	nb_in_long;
	int		digit_to_char;

	nb_in_long = nb;
	if (nb_in_long < 0)
	{
		write(1, "-", 1);
		nb_in_long = nb_in_long * -1;
	}
	if (nb_in_long < 10)
	{
		digit_to_char = nb_in_long + '0';
		write(1, &digit_to_char, 1);
	}
	else
	{
		ft_putnbr(nb_in_long / 10);
		ft_putnbr(nb_in_long % 10);
	}
}

void	ft_print_int_tab(int *tab, int size)
{
	int	i;

	printf("The returned size of range is %d.\n", size);
	if (tab != NULL && size > 0)
	{
		write(1, "[", 1);
		i = 0;
		while (i < size)
		{
			ft_putnbr(tab[i]);
			if (i < size - 1)
				write(1, ", ", 2);
			i++;
		}
		write(1, "]", 1);
	}
	else if (size == 0)
		printf("\nNone array - Reason : If the value of min is greater or equal to maxâ€™s value, range will point on NULL and it should return 0.");
	else if (size == -1)
		printf("\nIncomplete array - Reason : The size of range should be returned (or -1 on error).");
}

int	main(void)
{
	int	min;
	int	max;i
	int	**ptr;
	int	*tab1 = NULL;
	int	tab1_size;
	int	*tab2 = NULL;
	int	tab2_size;
	int	*tab3 = NULL;
	int	tab3_size;
	int	*tab4 = NULL;
	int	tab4_size;

	min = 3;
	max = 8;
	tab1_size = ft_ultimate_range(&tab1, min, max);
	printf("Pour min = %d et max = %d, tab1 =\n", min, max);
	printf("&tab1 = %ls\n", &tab1);
	ft_print_int_tab(tab1, tab1_size);
	ptr = &tab1;
	free(tab1);
	free(ptr);
	/*min = 42;
	max = 42;
	tab2_size = ft_ultimate_range(tab2, min, max);
	printf("\nPour min = %d et max = %d, tab2 =\n", min, max);
	ft_print_int_tab(*tab2, tab2_size);
	free(*tab2);
	free(tab2);
	min = -42;
	max = 43;
	tab3_size = ft_ultimate_range(tab3, min, max);
	printf("\nPour min = %d et max = %d, tab3 =\n", min, max);
	ft_print_int_tab(*tab3, tab3_size);
	free(*tab3);
	free(tab3);
	min = 42;
	max = -1;
	tab4_size = ft_ultimate_range(tab4, min, max);
	printf("\nPour min = %d et max = %d, tab4 =\n", min, max);
	ft_print_int_tab(*tab4, tab4_size);
	free(*tab4);
	free(tab4);*/
	return (0);
}
e3r11p9% gcc -Wextra -Werror -o test_ft_ultimate_range -g ft_ultimate_range.c test_ft_ultimate_range.c
test_ft_ultimate_range.c: In function â€˜mainâ€™:
test_ft_ultimate_range.c:69:10: error: â€˜iâ€™ undeclared (first use in this function)
   69 |  int max;i
      |          ^
test_ft_ultimate_range.c:69:10: note: each undeclared identifier is reported only once for each function it appears in
test_ft_ultimate_range.c:69:11: error: expected â€˜;â€™ before â€˜intâ€™
   69 |  int max;i
      |           ^
      |           ;
   70 |  int **ptr;
      |  ~~~       
test_ft_ultimate_range.c:84:20: error: format â€˜%lsâ€™ expects argument of type â€˜wchar_t *â€™, but argument 2 has type â€˜int **â€™ [-Werror=format=]
   84 |  printf("&tab1 = %ls\n", &tab1);
      |                  ~~^     ~~~~~
      |                    |     |
      |                    int * int **
test_ft_ultimate_range.c:86:2: error: â€˜ptrâ€™ undeclared (first use in this function)
   86 |  ptr = &tab1;
      |  ^~~
cc1: all warnings being treated as errors
e3r11p9% vi test_ft_ultimate_range.c                                                                 
e3r11p9% cat test_ft_ultimate_range.c                                                                 
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   test_ft_ultimate_range.c                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: hauerbac <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2023/02/22 17:56:00 by hauerbac          #+#    #+#             */
/*   Updated: 2023/02/23 16:26:20 by hauerbac         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>

int	ft_ultimate_range(int **range, int min, int max);

void	ft_putnbr(int nb)
{
	long	nb_in_long;
	int		digit_to_char;

	nb_in_long = nb;
	if (nb_in_long < 0)
	{
		write(1, "-", 1);
		nb_in_long = nb_in_long * -1;
	}
	if (nb_in_long < 10)
	{
		digit_to_char = nb_in_long + '0';
		write(1, &digit_to_char, 1);
	}
	else
	{
		ft_putnbr(nb_in_long / 10);
		ft_putnbr(nb_in_long % 10);
	}
}

void	ft_print_int_tab(int *tab, int size)
{
	int	i;

	printf("The returned size of range is %d.\n", size);
	if (tab != NULL && size > 0)
	{
		write(1, "[", 1);
		i = 0;
		while (i < size)
		{
			ft_putnbr(tab[i]);
			if (i < size - 1)
				write(1, ", ", 2);
			i++;
		}
		write(1, "]", 1);
	}
	else if (size == 0)
		printf("\nNone array - Reason : If the value of min is greater or equal to maxâ€™s value, range will point on NULL and it should return 0.");
	else if (size == -1)
		printf("\nIncomplete array - Reason : The size of range should be returned (or -1 on error).");
}

int	main(void)
{
	int	min;
	int	max;
	int	**ptr;
	int	*tab1 = NULL;
	int	tab1_size;
	int	*tab2 = NULL;
	int	tab2_size;
	int	*tab3 = NULL;
	int	tab3_size;
	int	*tab4 = NULL;
	int	tab4_size;

	min = 3;
	max = 8;
	tab1_size = ft_ultimate_range(&tab1, min, max);
	printf("Pour min = %d et max = %d, tab1 =\n", min, max);
	printf("&tab1 = %ls\n", &tab1);
	ft_print_int_tab(tab1, tab1_size);
	ptr = &tab1;
	free(tab1);
	free(ptr);
	/*min = 42;
	max = 42;
	tab2_size = ft_ultimate_range(tab2, min, max);
	printf("\nPour min = %d et max = %d, tab2 =\n", min, max);
	ft_print_int_tab(*tab2, tab2_size);
	free(*tab2);
	free(tab2);
	min = -42;
	max = 43;
	tab3_size = ft_ultimate_range(tab3, min, max);
	printf("\nPour min = %d et max = %d, tab3 =\n", min, max);
	ft_print_int_tab(*tab3, tab3_size);
	free(*tab3);
	free(tab3);
	min = 42;
	max = -1;
	tab4_size = ft_ultimate_range(tab4, min, max);
	printf("\nPour min = %d et max = %d, tab4 =\n", min, max);
	ft_print_int_tab(*tab4, tab4_size);
	free(*tab4);
	free(tab4);*/
	return (0);
}
e3r11p9% gcc -Wextra -Werror -o test_ft_ultimate_range -g ft_ultimate_range.c test_ft_ultimate_range.c
test_ft_ultimate_range.c: In function â€˜mainâ€™:
test_ft_ultimate_range.c:84:20: error: format â€˜%lsâ€™ expects argument of type â€˜wchar_t *â€™, but argument 2 has type â€˜int **â€™ [-Werror=format=]
   84 |  printf("&tab1 = %ls\n", &tab1);
      |                  ~~^     ~~~~~
      |                    |     |
      |                    int * int **
cc1: all warnings being treated as errors
e3r11p9% vi test_ft_ultimate_range.c                                                                 
e3r11p9% cat test_ft_ultimate_range.c                                                                 
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   test_ft_ultimate_range.c                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: hauerbac <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2023/02/22 17:56:00 by hauerbac          #+#    #+#             */
/*   Updated: 2023/02/23 16:30:28 by hauerbac         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>

int	ft_ultimate_range(int **range, int min, int max);

void	ft_putnbr(int nb)
{
	long	nb_in_long;
	int		digit_to_char;

	nb_in_long = nb;
	if (nb_in_long < 0)
	{
		write(1, "-", 1);
		nb_in_long = nb_in_long * -1;
	}
	if (nb_in_long < 10)
	{
		digit_to_char = nb_in_long + '0';
		write(1, &digit_to_char, 1);
	}
	else
	{
		ft_putnbr(nb_in_long / 10);
		ft_putnbr(nb_in_long % 10);
	}
}

void	ft_print_int_tab(int *tab, int size)
{
	int	i;

	printf("The returned size of range is %d.\n", size);
	if (tab != NULL && size > 0)
	{
		write(1, "[", 1);
		i = 0;
		while (i < size)
		{
			ft_putnbr(tab[i]);
			if (i < size - 1)
				write(1, ", ", 2);
			i++;
		}
		write(1, "]", 1);
	}
	else if (size == 0)
		printf("\nNone array - Reason : If the value of min is greater or equal to maxâ€™s value, range will point on NULL and it should return 0.");
	else if (size == -1)
		printf("\nIncomplete array - Reason : The size of range should be returned (or -1 on error).");
}

int	main(void)
{
	int	min;
	int	max;
	int	**ptr;
	int	*tab1 = NULL;
	int	tab1_size;
	int	*tab2 = NULL;
	int	tab2_size;
	int	*tab3 = NULL;
	int	tab3_size;
	int	*tab4 = NULL;
	int	tab4_size;

	min = 3;
	max = 8;
	tab1_size = ft_ultimate_range(&tab1, min, max);
	printf("Pour min = %d et max = %d, tab1 =\n", min, max);
	printf("&tab1 = %lls\n", &tab1);
	ft_print_int_tab(tab1, tab1_size);
	ptr = &tab1;
	free(tab1);
	free(ptr);
	/*min = 42;
	max = 42;
	tab2_size = ft_ultimate_range(tab2, min, max);
	printf("\nPour min = %d et max = %d, tab2 =\n", min, max);
	ft_print_int_tab(*tab2, tab2_size);
	free(*tab2);
	free(tab2);
	min = -42;
	max = 43;
	tab3_size = ft_ultimate_range(tab3, min, max);
	printf("\nPour min = %d et max = %d, tab3 =\n", min, max);
	ft_print_int_tab(*tab3, tab3_size);
	free(*tab3);
	free(tab3);
	min = 42;
	max = -1;
	tab4_size = ft_ultimate_range(tab4, min, max);
	printf("\nPour min = %d et max = %d, tab4 =\n", min, max);
	ft_print_int_tab(*tab4, tab4_size);
	free(*tab4);
	free(tab4);*/
	return (0);
}
e3r11p9% gcc -Wextra -Werror -o test_ft_ultimate_range -g ft_ultimate_range.c test_ft_ultimate_range.c
test_ft_ultimate_range.c: In function â€˜mainâ€™:
test_ft_ultimate_range.c:84:21: error: use of â€˜llâ€™ length modifier with â€˜sâ€™ type character has either no effect or undefined behavior [-Werror=format=]
   84 |  printf("&tab1 = %lls\n", &tab1);
      |                     ^
cc1: all warnings being treated as errors
e3r11p9% vi test_ft_ultimate_range.c                                                                 
e3r11p9% cat test_ft_ultimate_range.c                                                                 
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   test_ft_ultimate_range.c                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: hauerbac <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2023/02/22 17:56:00 by hauerbac          #+#    #+#             */
/*   Updated: 2023/02/23 16:30:56 by hauerbac         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>

int	ft_ultimate_range(int **range, int min, int max);

void	ft_putnbr(int nb)
{
	long	nb_in_long;
	int		digit_to_char;

	nb_in_long = nb;
	if (nb_in_long < 0)
	{
		write(1, "-", 1);
		nb_in_long = nb_in_long * -1;
	}
	if (nb_in_long < 10)
	{
		digit_to_char = nb_in_long + '0';
		write(1, &digit_to_char, 1);
	}
	else
	{
		ft_putnbr(nb_in_long / 10);
		ft_putnbr(nb_in_long % 10);
	}
}

void	ft_print_int_tab(int *tab, int size)
{
	int	i;

	printf("The returned size of range is %d.\n", size);
	if (tab != NULL && size > 0)
	{
		write(1, "[", 1);
		i = 0;
		while (i < size)
		{
			ft_putnbr(tab[i]);
			if (i < size - 1)
				write(1, ", ", 2);
			i++;
		}
		write(1, "]", 1);
	}
	else if (size == 0)
		printf("\nNone array - Reason : If the value of min is greater or equal to maxâ€™s value, range will point on NULL and it should return 0.");
	else if (size == -1)
		printf("\nIncomplete array - Reason : The size of range should be returned (or -1 on error).");
}

int	main(void)
{
	int	min;
	int	max;
	int	**ptr;
	int	*tab1 = NULL;
	int	tab1_size;
	int	*tab2 = NULL;
	int	tab2_size;
	int	*tab3 = NULL;
	int	tab3_size;
	int	*tab4 = NULL;
	int	tab4_size;

	min = 3;
	max = 8;
	tab1_size = ft_ultimate_range(&tab1, min, max);
	printf("Pour min = %d et max = %d, tab1 =\n", min, max);
	printf("&tab1 = %llu\n", &tab1);
	ft_print_int_tab(tab1, tab1_size);
	ptr = &tab1;
	free(tab1);
	free(ptr);
	/*min = 42;
	max = 42;
	tab2_size = ft_ultimate_range(tab2, min, max);
	printf("\nPour min = %d et max = %d, tab2 =\n", min, max);
	ft_print_int_tab(*tab2, tab2_size);
	free(*tab2);
	free(tab2);
	min = -42;
	max = 43;
	tab3_size = ft_ultimate_range(tab3, min, max);
	printf("\nPour min = %d et max = %d, tab3 =\n", min, max);
	ft_print_int_tab(*tab3, tab3_size);
	free(*tab3);
	free(tab3);
	min = 42;
	max = -1;
	tab4_size = ft_ultimate_range(tab4, min, max);
	printf("\nPour min = %d et max = %d, tab4 =\n", min, max);
	ft_print_int_tab(*tab4, tab4_size);
	free(*tab4);
	free(tab4);*/
	return (0);
}
e3r11p9% gcc -Wextra -Werror -o test_ft_ultimate_range -g ft_ultimate_range.c test_ft_ultimate_range.c
test_ft_ultimate_range.c: In function â€˜mainâ€™:
test_ft_ultimate_range.c:84:21: error: format â€˜%lluâ€™ expects argument of type â€˜long long unsigned intâ€™, but argument 2 has type â€˜int **â€™ [-Werror=format=]
   84 |  printf("&tab1 = %llu\n", &tab1);
      |                  ~~~^     ~~~~~
      |                     |     |
      |                     |     int **
      |                     long long unsigned int
cc1: all warnings being treated as errors
e3r11p9% vi test_ft_ultimate_range.c                                                                 
e3r11p9% cat test_ft_ultimate_range.c                                                                 
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   test_ft_ultimate_range.c                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: hauerbac <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2023/02/22 17:56:00 by hauerbac          #+#    #+#             */
/*   Updated: 2023/02/23 16:32:16 by hauerbac         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>

int	ft_ultimate_range(int **range, int min, int max);

void	ft_putnbr(int nb)
{
	long	nb_in_long;
	int		digit_to_char;

	nb_in_long = nb;
	if (nb_in_long < 0)
	{
		write(1, "-", 1);
		nb_in_long = nb_in_long * -1;
	}
	if (nb_in_long < 10)
	{
		digit_to_char = nb_in_long + '0';
		write(1, &digit_to_char, 1);
	}
	else
	{
		ft_putnbr(nb_in_long / 10);
		ft_putnbr(nb_in_long % 10);
	}
}

void	ft_print_int_tab(int *tab, int size)
{
	int	i;

	printf("The returned size of range is %d.\n", size);
	if (tab != NULL && size > 0)
	{
		write(1, "[", 1);
		i = 0;
		while (i < size)
		{
			ft_putnbr(tab[i]);
			if (i < size - 1)
				write(1, ", ", 2);
			i++;
		}
		write(1, "]", 1);
	}
	else if (size == 0)
		printf("\nNone array - Reason : If the value of min is greater or equal to maxâ€™s value, range will point on NULL and it should return 0.");
	else if (size == -1)
		printf("\nIncomplete array - Reason : The size of range should be returned (or -1 on error).");
}

int	main(void)
{
	int	min;
	int	max;
	int	**ptr;
	int	*tab1 = NULL;
	int	tab1_size;
	int	*tab2 = NULL;
	int	tab2_size;
	int	*tab3 = NULL;
	int	tab3_size;
	int	*tab4 = NULL;
	int	tab4_size;

	min = 3;
	max = 8;
	tab1_size = ft_ultimate_range(&tab1, min, max);
	printf("Pour min = %d et max = %d, tab1 =\n", min, max);
	printf("&tab1 = %p\n", &tab1);
	ft_print_int_tab(tab1, tab1_size);
	ptr = &tab1;
	free(tab1);
	free(ptr);
	/*min = 42;
	max = 42;
	tab2_size = ft_ultimate_range(tab2, min, max);
	printf("\nPour min = %d et max = %d, tab2 =\n", min, max);
	ft_print_int_tab(*tab2, tab2_size);
	free(*tab2);
	free(tab2);
	min = -42;
	max = 43;
	tab3_size = ft_ultimate_range(tab3, min, max);
	printf("\nPour min = %d et max = %d, tab3 =\n", min, max);
	ft_print_int_tab(*tab3, tab3_size);
	free(*tab3);
	free(tab3);
	min = 42;
	max = -1;
	tab4_size = ft_ultimate_range(tab4, min, max);
	printf("\nPour min = %d et max = %d, tab4 =\n", min, max);
	ft_print_int_tab(*tab4, tab4_size);
	free(*tab4);
	free(tab4);*/
	return (0);
}
e3r11p9% gcc -Wextra -Werror -o test_ft_ultimate_range -g ft_ultimate_range.c test_ft_ultimate_range.c
e3r11p9% lldb test_ft_ultimate_range                                                                  
(lldb) target create "test_ft_ultimate_range"
Current executable set to '/mnt/nfs/homes/hauerbac/c_07/ex02/test_ft_ultimate_range' (x86_64).
(lldb) b main
Breakpoint 1: where = test_ft_ultimate_range`main + 27 at test_ft_ultimate_range.c:71:7, address = 0x0000000000001505
(lldb) run
warning: (x86_64) /usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2 unsupported DW_FORM value: 0x1f
Process 126955 launched: '/mnt/nfs/homes/hauerbac/c_07/ex02/test_ft_ultimate_range' (x86_64)
warning: (x86_64) /lib64/ld-linux-x86-64.so.2 unsupported DW_FORM value: 0x1f
warning: (x86_64) /lib/x86_64-linux-gnu/libc.so.6 unsupported DW_FORM value: 0x1f
Process 126955 stopped
* thread #1, name = 'test_ft_ultimat', stop reason = breakpoint 1.1
    frame #0: 0x0000555555555505 test_ft_ultimate_range`main at test_ft_ultimate_range.c:71:7
   68  		int	min;
   69  		int	max;
   70  		int	**ptr;
-> 71  		int	*tab1 = NULL;
   72  		int	tab1_size;
   73  		int	*tab2 = NULL;
   74  		int	tab2_size;
(lldb) gui
(lldb) q
Quitting LLDB will kill one or more processes. Do you really want to proceed: [Y/n] y
Pour min = 3 et max = 8, tab1 =
&tab1 = 0x7fffffffe3e0
The returned size of range is 5.
e3r11p9% vi test_ft_ultimate_range.c                                                                 
e3r11p9% cat test_ft_ultimate_range.c                                                                 
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   test_ft_ultimate_range.c                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: hauerbac <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2023/02/22 17:56:00 by hauerbac          #+#    #+#             */
/*   Updated: 2023/02/23 16:37:59 by hauerbac         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>

int	ft_ultimate_range(int **range, int min, int max);

void	ft_putnbr(int nb)
{
	long	nb_in_long;
	int		digit_to_char;

	nb_in_long = nb;
	if (nb_in_long < 0)
	{
		write(1, "-", 1);
		nb_in_long = nb_in_long * -1;
	}
	if (nb_in_long < 10)
	{
		digit_to_char = nb_in_long + '0';
		write(1, &digit_to_char, 1);
	}
	else
	{
		ft_putnbr(nb_in_long / 10);
		ft_putnbr(nb_in_long % 10);
	}
}

void	ft_print_int_tab(int *tab, int size)
{
	int	i;

	printf("The returned size of range is %d.\n", size);
	if (tab != NULL && size > 0)
	{
		write(1, "[", 1);
		i = 0;
		while (i < size)
		{
			ft_putnbr(tab[i]);
			if (i < size - 1)
				write(1, ", ", 2);
			i++;
		}
		write(1, "]", 1);
	}
	else if (size == 0)
		printf("\nNone array - Reason : If the value of min is greater or equal to maxâ€™s value, range will point on NULL and it should return 0.");
	else if (size == -1)
		printf("\nIncomplete array - Reason : The size of range should be returned (or -1 on error).");
}

int	main(void)
{
	int	min;
	int	max;
	int	**ptr;
	int	**tab1 = NULL;
	int	tab1_size;
	int	**tab2 = NULL;
	int	tab2_size;
	int	**tab3 = NULL;
	int	tab3_size;
	int	**tab4 = NULL;
	int	tab4_size;

	min = 3;
	max = 8;
	tab1_size = ft_ultimate_range(&tab1, min, max);
	printf("Pour min = %d et max = %d, tab1 =\n", min, max);
	printf("tab1 = %p\n", tab1);
	ft_print_int_tab(*tab1, tab1_size);
	//ptr = &tab1;
	free(*tab1);
	free(tab1);
	//free(ptr);
	/*min = 42;
	max = 42;
	tab2_size = ft_ultimate_range(tab2, min, max);
	printf("\nPour min = %d et max = %d, tab2 =\n", min, max);
	ft_print_int_tab(*tab2, tab2_size);
	free(*tab2);
	free(tab2);
	min = -42;
	max = 43;
	tab3_size = ft_ultimate_range(tab3, min, max);
	printf("\nPour min = %d et max = %d, tab3 =\n", min, max);
	ft_print_int_tab(*tab3, tab3_size);
	free(*tab3);
	free(tab3);
	min = 42;
	max = -1;
	tab4_size = ft_ultimate_range(tab4, min, max);
	printf("\nPour min = %d et max = %d, tab4 =\n", min, max);
	ft_print_int_tab(*tab4, tab4_size);
	free(*tab4);
	free(tab4);*/
	return (0);
}
e3r11p9% gcc -Wextra -Werror -o test_ft_ultimate_range -g ft_ultimate_range.c test_ft_ultimate_range.c
test_ft_ultimate_range.c: In function â€˜mainâ€™:
test_ft_ultimate_range.c:82:32: error: passing argument 1 of â€˜ft_ultimate_rangeâ€™ from incompatible pointer type [-Werror=incompatible-pointer-types]
   82 |  tab1_size = ft_ultimate_range(&tab1, min, max);
      |                                ^~~~~
      |                                |
      |                                int ***
test_ft_ultimate_range.c:17:29: note: expected â€˜int **â€™ but argument is of type â€˜int ***â€™
   17 | int ft_ultimate_range(int **range, int min, int max);
      |                       ~~~~~~^~~~~
cc1: all warnings being treated as errors
e3r11p9% vi test_ft_ultimate_range.c                                                                 
e3r11p9% cat test_ft_ultimate_range.c                                                                 
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   test_ft_ultimate_range.c                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: hauerbac <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2023/02/22 17:56:00 by hauerbac          #+#    #+#             */
/*   Updated: 2023/02/23 16:38:49 by hauerbac         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>

int	ft_ultimate_range(int **range, int min, int max);

void	ft_putnbr(int nb)
{
	long	nb_in_long;
	int		digit_to_char;

	nb_in_long = nb;
	if (nb_in_long < 0)
	{
		write(1, "-", 1);
		nb_in_long = nb_in_long * -1;
	}
	if (nb_in_long < 10)
	{
		digit_to_char = nb_in_long + '0';
		write(1, &digit_to_char, 1);
	}
	else
	{
		ft_putnbr(nb_in_long / 10);
		ft_putnbr(nb_in_long % 10);
	}
}

void	ft_print_int_tab(int *tab, int size)
{
	int	i;

	printf("The returned size of range is %d.\n", size);
	if (tab != NULL && size > 0)
	{
		write(1, "[", 1);
		i = 0;
		while (i < size)
		{
			ft_putnbr(tab[i]);
			if (i < size - 1)
				write(1, ", ", 2);
			i++;
		}
		write(1, "]", 1);
	}
	else if (size == 0)
		printf("\nNone array - Reason : If the value of min is greater or equal to maxâ€™s value, range will point on NULL and it should return 0.");
	else if (size == -1)
		printf("\nIncomplete array - Reason : The size of range should be returned (or -1 on error).");
}

int	main(void)
{
	int	min;
	int	max;
	int	**ptr;
	int	**tab1 = NULL;
	int	tab1_size;
	int	**tab2 = NULL;
	int	tab2_size;
	int	**tab3 = NULL;
	int	tab3_size;
	int	**tab4 = NULL;
	int	tab4_size;

	min = 3;
	max = 8;
	tab1_size = ft_ultimate_range(tab1, min, max);
	printf("Pour min = %d et max = %d, tab1 =\n", min, max);
	printf("tab1 = %p\n", tab1);
	ft_print_int_tab(*tab1, tab1_size);
	//ptr = &tab1;
	free(*tab1);
	free(tab1);
	//free(ptr);
	/*min = 42;
	max = 42;
	tab2_size = ft_ultimate_range(tab2, min, max);
	printf("\nPour min = %d et max = %d, tab2 =\n", min, max);
	ft_print_int_tab(*tab2, tab2_size);
	free(*tab2);
	free(tab2);
	min = -42;
	max = 43;
	tab3_size = ft_ultimate_range(tab3, min, max);
	printf("\nPour min = %d et max = %d, tab3 =\n", min, max);
	ft_print_int_tab(*tab3, tab3_size);
	free(*tab3);
	free(tab3);
	min = 42;
	max = -1;
	tab4_size = ft_ultimate_range(tab4, min, max);
	printf("\nPour min = %d et max = %d, tab4 =\n", min, max);
	ft_print_int_tab(*tab4, tab4_size);
	free(*tab4);
	free(tab4);*/
	return (0);
}
e3r11p9% gcc -Wextra -Werror -o test_ft_ultimate_range -g ft_ultimate_range.c test_ft_ultimate_range.c
e3r11p9% lldb test_ft_ultimate_range                                                                 
(lldb) target create "test_ft_ultimate_range"
Current executable set to '/mnt/nfs/homes/hauerbac/c_07/ex02/test_ft_ultimate_range' (x86_64).
(lldb) b main
Breakpoint 1: where = test_ft_ultimate_range`main + 12 at test_ft_ultimate_range.c:71:8, address = 0x00000000000014f6
(lldb) run
warning: (x86_64) /usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2 unsupported DW_FORM value: 0x1f
Process 127884 launched: '/mnt/nfs/homes/hauerbac/c_07/ex02/test_ft_ultimate_range' (x86_64)
warning: (x86_64) /lib64/ld-linux-x86-64.so.2 unsupported DW_FORM value: 0x1f
warning: (x86_64) /lib/x86_64-linux-gnu/libc.so.6 unsupported DW_FORM value: 0x1f
Process 127884 stopped
* thread #1, name = 'test_ft_ultimat', stop reason = breakpoint 1.1
    frame #0: 0x00005555555554f6 test_ft_ultimate_range`main at test_ft_ultimate_range.c:71:8
   68  		int	min;
   69  		int	max;
   70  		int	**ptr;
-> 71  		int	**tab1 = NULL;
   72  		int	tab1_size;
   73  		int	**tab2 = NULL;
   74  		int	tab2_size;
(lldb) gui
(lldb) q
Quitting LLDB will kill one or more processes. Do you really want to proceed: [Y/n] y
Pour min = 3 et max = 8, tab1 =
tab1 = (nil)
e3r11p9% vi ft_ultimate_range.c                                                                 
e3r11p9% cat ft_ultimate_range.c 
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_ultimate_range.c                                :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: hauerbac <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2023/02/23 10:23:31 by hauerbac          #+#    #+#             */
/*   Updated: 2023/02/23 17:28:09 by hauerbac         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include <stdlib.h>

int	*ft_range(int min, int max)
{
	int	range_len;
	int	*ptr;
	int	i;
	int	value;

	if (min < max)
	{
		range_len = max - min;
		ptr = (int *) malloc(range_len * sizeof(int));
		if (ptr)
		{
			value = min;
			i = 0;
			while (i < range_len && value < max)
				ptr[i++] = value++;
			if (i == range_len)
				return (ptr);
			else
				return (NULL);
		}
	}
	return (NULL);
}

int	ft_ultimate_range(int **range, int min, int max)
{
	int	range_len;
	int	*ptr;

	range = NULL;
	if (min < max)
	{
		range = (int **) malloc(sizeof(int *));
		if (range == NULL)
			return (-1);
		range_len = max - min;
		ptr = ft_range(min, max);
		if (ptr)
		{
			*range = &ptr;
			return (range_len);
		}
		else
			return (-1);
	}
	else
		return (0);
}
e3r11p9% norminette -R CheckForbiddenSourceHeader ft_ultimate_range.c                           
ft_ultimate_range.c: OK!
e3r11p9% vi test_ft_ultimate_range.c
e3r11p9% cat test_ft_ultimate_range.c 
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   test_ft_ultimate_range.c                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: hauerbac <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2023/02/22 17:56:00 by hauerbac          #+#    #+#             */
/*   Updated: 2023/02/23 17:31:11 by hauerbac         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>

int	ft_ultimate_range(int **range, int min, int max);

void	ft_putnbr(int nb)
{
	long	nb_in_long;
	int		digit_to_char;

	nb_in_long = nb;
	if (nb_in_long < 0)
	{
		write(1, "-", 1);
		nb_in_long = nb_in_long * -1;
	}
	if (nb_in_long < 10)
	{
		digit_to_char = nb_in_long + '0';
		write(1, &digit_to_char, 1);
	}
	else
	{
		ft_putnbr(nb_in_long / 10);
		ft_putnbr(nb_in_long % 10);
	}
}

void	ft_print_int_tab(int *tab, int size)
{
	int	i;

	printf("The returned size of range is %d.\n", size);
	if (tab != NULL && size > 0)
	{
		write(1, "[", 1);
		i = 0;
		while (i < size)
		{
			ft_putnbr(tab[i]);
			if (i < size - 1)
				write(1, ", ", 2);
			i++;
		}
		write(1, "]", 1);
	}
	else if (size == 0)
		printf("\nNone array - Reason : If the value of min is greater or equal to maxâ€™s value, range will point on NULL and it should return 0.");
	else if (size == -1)
		printf("\nIncomplete array - Reason : The size of range should be returned (or -1 on error).");
}

int	main(void)
{
	int	min;
	int	max;
	int	**ptr;
	int	**tab1 = NULL;
	int	tab1_size;
	int	**tab2 = NULL;
	int	tab2_size;
	int	**tab3 = NULL;
	int	tab3_size;
	int	**tab4 = NULL;
	int	tab4_size;

	min = 3;
	max = 8;
	tab1_size = ft_ultimate_range(&tab1, min, max);
	printf("Pour min = %d et max = %d, tab1 =\n", min, max);
	printf("tab1 = %p\n", tab1);
	ft_print_int_tab(*tab1, tab1_size);
	//ptr = &tab1;
	free(*tab1);
	free(tab1);
	//free(ptr);
	/*min = 42;
	max = 42;
	tab2_size = ft_ultimate_range(tab2, min, max);
	printf("\nPour min = %d et max = %d, tab2 =\n", min, max);
	ft_print_int_tab(*tab2, tab2_size);
	free(*tab2);
	free(tab2);
	min = -42;
	max = 43;
	tab3_size = ft_ultimate_range(tab3, min, max);
	printf("\nPour min = %d et max = %d, tab3 =\n", min, max);
	ft_print_int_tab(*tab3, tab3_size);
	free(*tab3);
	free(tab3);
	min = 42;
	max = -1;
	tab4_size = ft_ultimate_range(tab4, min, max);
	printf("\nPour min = %d et max = %d, tab4 =\n", min, max);
	ft_print_int_tab(*tab4, tab4_size);
	free(*tab4);
	free(tab4);*/
	return (0);
}
e3r11p9% norminette -R CheckForbiddenSourceHeader test_ft_ultimate_range.c
test_ft_ultimate_range.c: Error!
Error: LINE_TOO_LONG        (line:  61, col: 145):	line too long
Error: LINE_TOO_LONG        (line:  63, col: 101):	line too long
Error: DECL_ASSIGN_LINE     (line:  71, col:  16):	Declaration and assignation on a single line
Error: TOO_MANY_VARS_FUNC   (line:  73, col:   1):	Too many variables declarations in a function
Error: DECL_ASSIGN_LINE     (line:  73, col:  16):	Declaration and assignation on a single line
Error: TOO_MANY_VARS_FUNC   (line:  74, col:   1):	Too many variables declarations in a function
Error: TOO_MANY_VARS_FUNC   (line:  75, col:   1):	Too many variables declarations in a function
Error: DECL_ASSIGN_LINE     (line:  75, col:  16):	Declaration and assignation on a single line
Error: TOO_MANY_VARS_FUNC   (line:  76, col:   1):	Too many variables declarations in a function
Error: TOO_MANY_VARS_FUNC   (line:  77, col:   1):	Too many variables declarations in a function
Error: DECL_ASSIGN_LINE     (line:  77, col:  16):	Declaration and assignation on a single line
Error: TOO_MANY_VARS_FUNC   (line:  78, col:   1):	Too many variables declarations in a function
Error: WRONG_SCOPE_COMMENT  (line:  86, col:   5):	Comment is invalid in this scope
Error: WRONG_SCOPE_COMMENT  (line:  89, col:   5):	Comment is invalid in this scope
Error: WRONG_SCOPE_COMMENT  (line:  90, col:   5):	Comment is invalid in this scope
e3r11p9% gcc -Wextra -Werror -o test_ft_ultimate_range -g ft_ultimate_range.c test_ft_ultimate_range.c
ft_ultimate_range.c: In function â€˜ft_ultimate_rangeâ€™:
ft_ultimate_range.c:56:11: error: assignment to â€˜int *â€™ from incompatible pointer type â€˜int **â€™ [-Werror=incompatible-pointer-types]
   56 |    *range = &ptr;
      |           ^
cc1: all warnings being treated as errors
test_ft_ultimate_range.c: In function â€˜mainâ€™:
test_ft_ultimate_range.c:82:32: error: passing argument 1 of â€˜ft_ultimate_rangeâ€™ from incompatible pointer type [-Werror=incompatible-pointer-types]
   82 |  tab1_size = ft_ultimate_range(&tab1, min, max);
      |                                ^~~~~
      |                                |
      |                                int ***
test_ft_ultimate_range.c:17:29: note: expected â€˜int **â€™ but argument is of type â€˜int ***â€™
   17 | int ft_ultimate_range(int **range, int min, int max);
      |                       ~~~~~~^~~~~
cc1: all warnings being treated as errors
e3r11p9% vi test_ft_ultimate_range.c                                     
e3r11p9% cat test_ft_ultimate_range.c                                     
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   test_ft_ultimate_range.c                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: hauerbac <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2023/02/22 17:56:00 by hauerbac          #+#    #+#             */
/*   Updated: 2023/02/23 17:33:45 by hauerbac         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>

int	ft_ultimate_range(int **range, int min, int max);

void	ft_putnbr(int nb)
{
	long	nb_in_long;
	int		digit_to_char;

	nb_in_long = nb;
	if (nb_in_long < 0)
	{
		write(1, "-", 1);
		nb_in_long = nb_in_long * -1;
	}
	if (nb_in_long < 10)
	{
		digit_to_char = nb_in_long + '0';
		write(1, &digit_to_char, 1);
	}
	else
	{
		ft_putnbr(nb_in_long / 10);
		ft_putnbr(nb_in_long % 10);
	}
}

void	ft_print_int_tab(int *tab, int size)
{
	int	i;

	printf("The returned size of range is %d.\n", size);
	if (tab != NULL && size > 0)
	{
		write(1, "[", 1);
		i = 0;
		while (i < size)
		{
			ft_putnbr(tab[i]);
			if (i < size - 1)
				write(1, ", ", 2);
			i++;
		}
		write(1, "]", 1);
	}
	else if (size == 0)
		printf("\nNone array - Reason : If the value of min is greater or equal to maxâ€™s value, range will point on NULL and it should return 0.");
	else if (size == -1)
		printf("\nIncomplete array - Reason : The size of range should be returned (or -1 on error).");
}

int	main(void)
{
	int	min;
	int	max;
	int	**ptr;
	int	**tab1 = NULL;
	int	tab1_size;
	int	**tab2 = NULL;
	int	tab2_size;
	int	**tab3 = NULL;
	int	tab3_size;
	int	**tab4 = NULL;
	int	tab4_size;

	min = 3;
	max = 8;
	tab1_size = ft_ultimate_range(tab1, min, max);
	printf("Pour min = %d et max = %d, tab1 =\n", min, max);
	printf("tab1 = %p\n", tab1);
	ft_print_int_tab(*tab1, tab1_size);
	//ptr = &tab1;
	free(*tab1);
	free(tab1);
	//free(ptr);
	/*min = 42;
	max = 42;
	tab2_size = ft_ultimate_range(tab2, min, max);
	printf("\nPour min = %d et max = %d, tab2 =\n", min, max);
	ft_print_int_tab(*tab2, tab2_size);
	free(*tab2);
	free(tab2);
	min = -42;
	max = 43;
	tab3_size = ft_ultimate_range(tab3, min, max);
	printf("\nPour min = %d et max = %d, tab3 =\n", min, max);
	ft_print_int_tab(*tab3, tab3_size);
	free(*tab3);
	free(tab3);
	min = 42;
	max = -1;
	tab4_size = ft_ultimate_range(tab4, min, max);
	printf("\nPour min = %d et max = %d, tab4 =\n", min, max);
	ft_print_int_tab(*tab4, tab4_size);
	free(*tab4);
	free(tab4);*/
	return (0);
}
e3r11p9% gcc -Wextra -Werror -o test_ft_ultimate_range -g ft_ultimate_range.c test_ft_ultimate_range.c
ft_ultimate_range.c: In function â€˜ft_ultimate_rangeâ€™:
ft_ultimate_range.c:56:11: error: assignment to â€˜int *â€™ from incompatible pointer type â€˜int **â€™ [-Werror=incompatible-pointer-types]
   56 |    *range = &ptr;
      |           ^
cc1: all warnings being treated as errors
e3r11p9% vi test_ft_ultimate_range.c                                                                 
e3r11p9% vi ft_ultimate_range.c                                     
e3r11p9% cat ft_ultimate_range.c 
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_ultimate_range.c                                :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: hauerbac <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2023/02/23 10:23:31 by hauerbac          #+#    #+#             */
/*   Updated: 2023/02/23 17:42:09 by hauerbac         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include <stdlib.h>

int	*ft_range(int min, int max)
{
	int	range_len;
	int	*ptr;
	int	i;
	int	value;

	if (min < max)
	{
		range_len = max - min;
		ptr = (int *) malloc(range_len * sizeof(int));
		if (ptr)
		{
			value = min;
			i = 0;
			while (i < range_len && value < max)
				ptr[i++] = value++;
			if (i == range_len)
				return (ptr);
			else
				return (NULL);
		}
	}
	return (NULL);
}

int	ft_ultimate_range(int **range, int min, int max)
{
	int	range_len;
	int	*ptr;

	range = NULL;
	if (min < max)
	{
		range = (int **) malloc(sizeof(int *));
		if (range == NULL)
			return (-1);
		range_len = max - min;
		ptr = ft_range(min, max);
		if (ptr)
		{
			*range = ptr;
			return (range_len);
		}
		else
			return (-1);
	}
	else
		return (0);
}
e3r11p9% norminette -R CheckForbiddenSourceHeader ft_ultimate_range.c                            
ft_ultimate_range.c: OK!
e3r11p9% gcc -Wextra -Werror -o test_ft_ultimate_range -g ft_ultimate_range.c test_ft_ultimate_range.c
e3r11p9% lldb test_ft_ultimate_range                                                                  
(lldb) target create "test_ft_ultimate_range"
Current executable set to '/mnt/nfs/homes/hauerbac/c_07/ex02/test_ft_ultimate_range' (x86_64).
(lldb) b main
Breakpoint 1: where = test_ft_ultimate_range`main + 12 at test_ft_ultimate_range.c:71:8, address = 0x00000000000014e2
(lldb) run
warning: (x86_64) /usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2 unsupported DW_FORM value: 0x1f
Process 137071 launched: '/mnt/nfs/homes/hauerbac/c_07/ex02/test_ft_ultimate_range' (x86_64)
warning: (x86_64) /lib64/ld-linux-x86-64.so.2 unsupported DW_FORM value: 0x1f
warning: (x86_64) /lib/x86_64-linux-gnu/libc.so.6 unsupported DW_FORM value: 0x1f
Process 137071 stopped
* thread #1, name = 'test_ft_ultimat', stop reason = breakpoint 1.1
    frame #0: 0x00005555555554e2 test_ft_ultimate_range`main at test_ft_ultimate_range.c:71:8
   68  		int	min;
   69  		int	max;
   70  		int	**ptr;
-> 71  		int	**tab1 = NULL;
   72  		int	tab1_size;
   73  		int	**tab2 = NULL;
   74  		int	tab2_size;
(lldb) gui
(lldb) q
Quitting LLDB will kill one or more processes. Do you really want to proceed: [Y/n] y
e3r11p9% ./test_ft_ultimate_range 
Pour min = 3 et max = 8, tab1 =
tab1 = (nil)
zsh: segmentation fault (core dumped)  ./test_ft_ultimate_range
e3r11p9% vi test_ft_ultimate_range.c                                
e3r11p9% cat test_ft_ultimate_range.c 
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   test_ft_ultimate_range.c                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: hauerbac <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2023/02/22 17:56:00 by hauerbac          #+#    #+#             */
/*   Updated: 2023/02/23 18:01:12 by hauerbac         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>

int	ft_ultimate_range(int **range, int min, int max);

void	ft_putnbr(int nb)
{
	long	nb_in_long;
	int		digit_to_char;

	nb_in_long = nb;
	if (nb_in_long < 0)
	{
		write(1, "-", 1);
		nb_in_long = nb_in_long * -1;
	}
	if (nb_in_long < 10)
	{
		digit_to_char = nb_in_long + '0';
		write(1, &digit_to_char, 1);
	}
	else
	{
		ft_putnbr(nb_in_long / 10);
		ft_putnbr(nb_in_long % 10);
	}
}

void	ft_print_int_tab(int *tab, int size)
{
	int	i;

	printf("The returned size of range is %d.\n", size);
	if (tab != NULL && size > 0)
	{
		write(1, "[", 1);
		i = 0;
		while (i < size)
		{
			ft_putnbr(tab[i]);
			if (i < size - 1)
				write(1, ", ", 2);
			i++;
		}
		write(1, "]", 1);
	}
	else if (size == 0)
		printf("\nNone array - Reason : If the value of min is greater or equal to maxâ€™s value, range will point on NULL and it should return 0.");
	else if (size == -1)
		printf("\nIncomplete array - Reason : The size of range should be returned (or -1 on error).");
}

int	main(void)
{
	int	min;
	int	max;
	int	**ptr;
	int	*tab1 = NULL;
	int	tab1_size;
	int	**tab2 = NULL;
	int	tab2_size;
	int	**tab3 = NULL;
	int	tab3_size;
	int	**tab4 = NULL;
	int	tab4_size;

	min = 3;
	max = 8;
	tab1_size = ft_ultimate_range(&tab1, min, max);
	printf("Pour min = %d et max = %d, tab1 =\n", min, max);
	printf("&tab1 = %p\n", &tab1);
	ft_print_int_tab(tab1, tab1_size);
	ptr = &tab1;
	//free(*tab1);
	free(tab1);
	free(ptr);
	/*min = 42;
	max = 42;
	tab2_size = ft_ultimate_range(tab2, min, max);
	printf("\nPour min = %d et max = %d, tab2 =\n", min, max);
	ft_print_int_tab(*tab2, tab2_size);
	free(*tab2);
	free(tab2);
	min = -42;
	max = 43;
	tab3_size = ft_ultimate_range(tab3, min, max);
	printf("\nPour min = %d et max = %d, tab3 =\n", min, max);
	ft_print_int_tab(*tab3, tab3_size);
	free(*tab3);
	free(tab3);
	min = 42;
	max = -1;
	tab4_size = ft_ultimate_range(tab4, min, max);
	printf("\nPour min = %d et max = %d, tab4 =\n", min, max);
	ft_print_int_tab(*tab4, tab4_size);
	free(*tab4);
	free(tab4);*/
	return (0);
}
e3r11p9% gcc -Wextra -Werror -o test_ft_ultimate_range -g ft_ultimate_range.c test_ft_ultimate_range.c
e3r11p9% ./test_ft_ultimate_range                                                                   
Pour min = 3 et max = 8, tab1 =
&tab1 = 0x7fff3d050550
The returned size of range is 5.
free(): invalid size
zsh: IOT instruction (core dumped)  ./test_ft_ultimate_range
e3r11p9% vi test_ft_ultimate_range.c                                                                 
e3r11p9% lldb test_ft_ultimate_range                                                                
(lldb) target create "test_ft_ultimate_range"
Current executable set to '/mnt/nfs/homes/hauerbac/c_07/ex02/test_ft_ultimate_range' (x86_64).
(lldb) b main
Breakpoint 1: where = test_ft_ultimate_range`main + 27 at test_ft_ultimate_range.c:71:7, address = 0x00000000000014f1
(lldb) run
warning: (x86_64) /usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2 unsupported DW_FORM value: 0x1f
Process 139911 launched: '/mnt/nfs/homes/hauerbac/c_07/ex02/test_ft_ultimate_range' (x86_64)
warning: (x86_64) /lib64/ld-linux-x86-64.so.2 unsupported DW_FORM value: 0x1f
warning: (x86_64) /lib/x86_64-linux-gnu/libc.so.6 unsupported DW_FORM value: 0x1f
Process 139911 stopped
* thread #1, name = 'test_ft_ultimat', stop reason = breakpoint 1.1
    frame #0: 0x00005555555554f1 test_ft_ultimate_range`main at test_ft_ultimate_range.c:71:7
   68  		int	min;
   69  		int	max;
   70  		int	**ptr;
-> 71  		int	*tab1 = NULL;
   72  		int	tab1_size;
   73  		int	**tab2 = NULL;
   74  		int	tab2_size;
(lldb) gui
(lldb) q
Quitting LLDB will kill one or more processes. Do you really want to proceed: [Y/n] y
Pour min = 3 et max = 8, tab1 =
&tab1 = 0x7fffffffe3e0
The returned size of range is 5.
e3r11p9% vi test_ft_ultimate_range.c
e3r11p9% cat test_ft_ultimate_range.c 
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   test_ft_ultimate_range.c                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: hauerbac <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2023/02/22 17:56:00 by hauerbac          #+#    #+#             */
/*   Updated: 2023/02/23 18:11:09 by hauerbac         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>

int	ft_ultimate_range(int **range, int min, int max);

void	ft_putnbr(int nb)
{
	long	nb_in_long;
	int		digit_to_char;

	nb_in_long = nb;
	if (nb_in_long < 0)
	{
		write(1, "-", 1);
		nb_in_long = nb_in_long * -1;
	}
	if (nb_in_long < 10)
	{
		digit_to_char = nb_in_long + '0';
		write(1, &digit_to_char, 1);
	}
	else
	{
		ft_putnbr(nb_in_long / 10);
		ft_putnbr(nb_in_long % 10);
	}
}

void	ft_print_int_tab(int *tab, int size)
{
	int	i;

	printf("The returned size of range is %d.\n", size);
	printf("tab = %p\n", tab);
	if (tab != NULL && size > 0)
	{
		write(1, "[", 1);
		i = 0;
		while (i < size)
		{
			ft_putnbr(tab[i]);
			if (i < size - 1)
				write(1, ", ", 2);
			i++;
		}
		write(1, "]", 1);
	}
	else if (size == 0)
		printf("\nNone array - Reason : If the value of min is greater or equal to maxâ€™s value, range will point on NULL and it should return 0.");
	else if (size == -1)
		printf("\nIncomplete array - Reason : The size of range should be returned (or -1 on error).");
}

int	main(void)
{
	int	min;
	int	max;
	int	**ptr;
	int	*tab1 = NULL;
	int	tab1_size;
	int	**tab2 = NULL;
	int	tab2_size;
	int	**tab3 = NULL;
	int	tab3_size;
	int	**tab4 = NULL;
	int	tab4_size;

	min = 3;
	max = 8;
	tab1_size = ft_ultimate_range(&tab1, min, max);
	printf("Pour min = %d et max = %d, tab1 =\n", min, max);
	printf("&tab1 = %p\n", &tab1);
	ft_print_int_tab(tab1, tab1_size);
	ptr = &tab1;
	//free(*tab1);
	free(tab1);
	free(ptr);
	/*min = 42;
	max = 42;
	tab2_size = ft_ultimate_range(tab2, min, max);
	printf("\nPour min = %d et max = %d, tab2 =\n", min, max);
	ft_print_int_tab(*tab2, tab2_size);
	free(*tab2);
	free(tab2);
	min = -42;
	max = 43;
	tab3_size = ft_ultimate_range(tab3, min, max);
	printf("\nPour min = %d et max = %d, tab3 =\n", min, max);
	ft_print_int_tab(*tab3, tab3_size);
	free(*tab3);
	free(tab3);
	min = 42;
	max = -1;
	tab4_size = ft_ultimate_range(tab4, min, max);
	printf("\nPour min = %d et max = %d, tab4 =\n", min, max);
	ft_print_int_tab(*tab4, tab4_size);
	free(*tab4);
	free(tab4);*/
	return (0);
}
e3r11p9% gcc -Wextra -Werror -o test_ft_ultimate_range -g ft_ultimate_range.c test_ft_ultimate_range.c
e3r11p9% ./test_ft_ultimate_range                                                                 
Pour min = 3 et max = 8, tab1 =
&tab1 = 0x7ffe97297c70
The returned size of range is 5.
tab = (nil)
free(): invalid size
zsh: IOT instruction (core dumped)  ./test_ft_ultimate_range
e3r11p9% vi test_ft_ultimate_range.c
e3r11p9% cat test_ft_ultimate_range.c 
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   test_ft_ultimate_range.c                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: hauerbac <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2023/02/22 17:56:00 by hauerbac          #+#    #+#             */
/*   Updated: 2023/02/23 18:41:14 by hauerbac         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>

int	ft_ultimate_range(int **range, int min, int max);

void	ft_putnbr(int nb)
{
	long	nb_in_long;
	int		digit_to_char;

	nb_in_long = nb;
	if (nb_in_long < 0)
	{
		write(1, "-", 1);
		nb_in_long = nb_in_long * -1;
	}
	if (nb_in_long < 10)
	{
		digit_to_char = nb_in_long + '0';
		write(1, &digit_to_char, 1);
	}
	else
	{
		ft_putnbr(nb_in_long / 10);
		ft_putnbr(nb_in_long % 10);
	}
}

void	ft_print_int_tab(int *tab, int size)
{
	int	i;

	printf("The returned size of range is %d.\n", size);
	printf("tab = %p\n", tab);
	if (tab != NULL && size > 0)
	{
		write(1, "[", 1);
		i = 0;
		while (i < size)
		{
			ft_putnbr(tab[i]);
			if (i < size - 1)
				write(1, ", ", 2);
			i++;
		}
		write(1, "]", 1);
	}
	else if (size == 0)
		printf("\nNone array - Reason : If the value of min is greater or equal to maxâ€™s value, range will point on NULL and it should return 0.");
	else if (size == -1)
		printf("\nIncomplete array - Reason : The size of range should be returned (or -1 on error).");
}

int	main(void)
{
	int	min;
	int	max;
	int	**ptr;
	int	*tab1 = NULL;
	int	tab1_size;
	int	**tab2 = NULL;
	int	tab2_size;
	int	**tab3 = NULL;
	int	tab3_size;
	int	**tab4 = NULL;
	int	tab4_size;

	min = 3;
	max = 8;
	tab1_size = ft_ultimate_range(&tab1, min, max);
	printf("Pour min = %d et max = %d, tab1 =\n", min, max);
	printf("&tab1 = %p\n", &tab1);
	ptr = &tab1;
	ft_print_int_tab(*ptr, tab1_size);
	//free(*tab1);
	free(**ptr);
	free(*ptr);
	/*min = 42;
	max = 42;
	tab2_size = ft_ultimate_range(tab2, min, max);
	printf("\nPour min = %d et max = %d, tab2 =\n", min, max);
	ft_print_int_tab(*tab2, tab2_size);
	free(*tab2);
	free(tab2);
	min = -42;
	max = 43;
	tab3_size = ft_ultimate_range(tab3, min, max);
	printf("\nPour min = %d et max = %d, tab3 =\n", min, max);
	ft_print_int_tab(*tab3, tab3_size);
	free(*tab3);
	free(tab3);
	min = 42;
	max = -1;
	tab4_size = ft_ultimate_range(tab4, min, max);
	printf("\nPour min = %d et max = %d, tab4 =\n", min, max);
	ft_print_int_tab(*tab4, tab4_size);
	free(*tab4);
	free(tab4);*/
	return (0);
}
e3r11p9% gcc -Wextra -Werror -o test_ft_ultimate_range -g ft_ultimate_range.c test_ft_ultimate_range.c
test_ft_ultimate_range.c: In function â€˜mainâ€™:
test_ft_ultimate_range.c:89:7: error: passing argument 1 of â€˜freeâ€™ makes pointer from integer without a cast [-Werror=int-conversion]
   89 |  free(**ptr);
      |       ^~~~~
      |       |
      |       int
In file included from test_ft_ultimate_range.c:15:
/usr/include/stdlib.h:555:25: note: expected â€˜void *â€™ but argument is of type â€˜intâ€™
  555 | extern void free (void *__ptr) __THROW;
      |                   ~~~~~~^~~~~
cc1: all warnings being treated as errors
e3r11p9% vi test_ft_ultimate_range.c                                                                 
e3r11p9% cat test_ft_ultimate_range.c                                                                 
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   test_ft_ultimate_range.c                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: hauerbac <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2023/02/22 17:56:00 by hauerbac          #+#    #+#             */
/*   Updated: 2023/02/23 18:41:59 by hauerbac         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>

int	ft_ultimate_range(int **range, int min, int max);

void	ft_putnbr(int nb)
{
	long	nb_in_long;
	int		digit_to_char;

	nb_in_long = nb;
	if (nb_in_long < 0)
	{
		write(1, "-", 1);
		nb_in_long = nb_in_long * -1;
	}
	if (nb_in_long < 10)
	{
		digit_to_char = nb_in_long + '0';
		write(1, &digit_to_char, 1);
	}
	else
	{
		ft_putnbr(nb_in_long / 10);
		ft_putnbr(nb_in_long % 10);
	}
}

void	ft_print_int_tab(int *tab, int size)
{
	int	i;

	printf("The returned size of range is %d.\n", size);
	printf("tab = %p\n", tab);
	if (tab != NULL && size > 0)
	{
		write(1, "[", 1);
		i = 0;
		while (i < size)
		{
			ft_putnbr(tab[i]);
			if (i < size - 1)
				write(1, ", ", 2);
			i++;
		}
		write(1, "]", 1);
	}
	else if (size == 0)
		printf("\nNone array - Reason : If the value of min is greater or equal to maxâ€™s value, range will point on NULL and it should return 0.");
	else if (size == -1)
		printf("\nIncomplete array - Reason : The size of range should be returned (or -1 on error).");
}

int	main(void)
{
	int	min;
	int	max;
	int	**ptr;
	int	*tab1 = NULL;
	int	tab1_size;
	int	**tab2 = NULL;
	int	tab2_size;
	int	**tab3 = NULL;
	int	tab3_size;
	int	**tab4 = NULL;
	int	tab4_size;

	min = 3;
	max = 8;
	tab1_size = ft_ultimate_range(&tab1, min, max);
	printf("Pour min = %d et max = %d, tab1 =\n", min, max);
	printf("&tab1 = %p\n", &tab1);
	ptr = &tab1;
	ft_print_int_tab(*ptr, tab1_size);
	//free(*tab1);
	free(*ptr);
	free(ptr);
	/*min = 42;
	max = 42;
	tab2_size = ft_ultimate_range(tab2, min, max);
	printf("\nPour min = %d et max = %d, tab2 =\n", min, max);
	ft_print_int_tab(*tab2, tab2_size);
	free(*tab2);
	free(tab2);
	min = -42;
	max = 43;
	tab3_size = ft_ultimate_range(tab3, min, max);
	printf("\nPour min = %d et max = %d, tab3 =\n", min, max);
	ft_print_int_tab(*tab3, tab3_size);
	free(*tab3);
	free(tab3);
	min = 42;
	max = -1;
	tab4_size = ft_ultimate_range(tab4, min, max);
	printf("\nPour min = %d et max = %d, tab4 =\n", min, max);
	ft_print_int_tab(*tab4, tab4_size);
	free(*tab4);
	free(tab4);*/
	return (0);
}
e3r11p9% gcc -Wextra -Werror -o test_ft_ultimate_range -g ft_ultimate_range.c test_ft_ultimate_range.c
e3r11p9% ./test_ft_ultimate_range.c                                                               
zsh: permission denied: ./test_ft_ultimate_range.c
e3r11p9% ./test_ft_ultimate_range  
Pour min = 3 et max = 8, tab1 =
&tab1 = 0x7ffffdd0ce60
The returned size of range is 5.
tab = (nil)
free(): invalid size
zsh: IOT instruction (core dumped)  ./test_ft_ultimate_range
e3r11p9% vi test_ft_ultimate_range.c                                                                 
e3r11p9% cat test_ft_ultimate_range.c                                                                
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   test_ft_ultimate_range.c                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: hauerbac <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2023/02/22 17:56:00 by hauerbac          #+#    #+#             */
/*   Updated: 2023/02/23 18:43:59 by hauerbac         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>

int	ft_ultimate_range(int **range, int min, int max);

void	ft_putnbr(int nb)
{
	long	nb_in_long;
	int		digit_to_char;

	nb_in_long = nb;
	if (nb_in_long < 0)
	{
		write(1, "-", 1);
		nb_in_long = nb_in_long * -1;
	}
	if (nb_in_long < 10)
	{
		digit_to_char = nb_in_long + '0';
		write(1, &digit_to_char, 1);
	}
	else
	{
		ft_putnbr(nb_in_long / 10);
		ft_putnbr(nb_in_long % 10);
	}
}

void	ft_print_int_tab(int *tab, int size)
{
	int	i;

	printf("The returned size of range is %d.\n", size);
	printf("tab = %p\n", tab);
	if (tab != NULL && size > 0)
	{
		write(1, "[", 1);
		i = 0;
		while (i < size)
		{
			ft_putnbr(tab[i]);
			if (i < size - 1)
				write(1, ", ", 2);
			i++;
		}
		write(1, "]", 1);
	}
	else if (size == 0)
		printf("\nNone array - Reason : If the value of min is greater or equal to maxâ€™s value, range will point on NULL and it should return 0.");
	else if (size == -1)
		printf("\nIncomplete array - Reason : The size of range should be returned (or -1 on error).");
}

int	main(void)
{
	int	min;
	int	max;
	int	**ptr;
	int	*tab1 = NULL;
	int	tab1_size;
	int	**tab2 = NULL;
	int	tab2_size;
	int	**tab3 = NULL;
	int	tab3_size;
	int	**tab4 = NULL;
	int	tab4_size;

	min = 3;
	max = 8;
	tab1_size = ft_ultimate_range(&tab1, min, max);
	printf("Pour min = %d et max = %d, tab1 =\n", min, max);
	printf("&tab1 = %p\n", &tab1);
	ptr = &tab1;
	printf("ptr = %p\n", ptr);
	ft_print_int_tab(*ptr, tab1_size);
	//free(*tab1);
	free(*ptr);
	free(ptr);
	/*min = 42;
	max = 42;
	tab2_size = ft_ultimate_range(tab2, min, max);
	printf("\nPour min = %d et max = %d, tab2 =\n", min, max);
	ft_print_int_tab(*tab2, tab2_size);
	free(*tab2);
	free(tab2);
	min = -42;
	max = 43;
	tab3_size = ft_ultimate_range(tab3, min, max);
	printf("\nPour min = %d et max = %d, tab3 =\n", min, max);
	ft_print_int_tab(*tab3, tab3_size);
	free(*tab3);
	free(tab3);
	min = 42;
	max = -1;
	tab4_size = ft_ultimate_range(tab4, min, max);
	printf("\nPour min = %d et max = %d, tab4 =\n", min, max);
	ft_print_int_tab(*tab4, tab4_size);
	free(*tab4);
	free(tab4);*/
	return (0);
}
e3r11p9% gcc -Wextra -Werror -o test_ft_ultimate_range -g ft_ultimate_range.c test_ft_ultimate_range.c
e3r11p9% ./test_ft_ultimate_range                                                                   
Pour min = 3 et max = 8, tab1 =
&tab1 = 0x7ffd4179bf90
ptr = 0x7ffd4179bf90
The returned size of range is 5.
tab = (nil)
free(): invalid size
zsh: IOT instruction (core dumped)  ./test_ft_ultimate_range
e3r11p9% vi test_ft_ultimate_range.c                                                                 
e3r11p9% cat test_ft_ultimate_range.c 
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   test_ft_ultimate_range.c                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: hauerbac <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2023/02/22 17:56:00 by hauerbac          #+#    #+#             */
/*   Updated: 2023/02/23 19:12:38 by hauerbac         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>

int	ft_ultimate_range(int **range, int min, int max);

void	ft_putnbr(int nb)
{
	long	nb_in_long;
	int		digit_to_char;

	nb_in_long = nb;
	if (nb_in_long < 0)
	{
		write(1, "-", 1);
		nb_in_long = nb_in_long * -1;
	}
	if (nb_in_long < 10)
	{
		digit_to_char = nb_in_long + '0';
		write(1, &digit_to_char, 1);
	}
	else
	{
		ft_putnbr(nb_in_long / 10);
		ft_putnbr(nb_in_long % 10);
	}
}

void	ft_print_int_tab(int **tab, int size)
{
	int	i;

	printf("The returned size of range is %d.\n", size);
	printf("*tab = %p\n", *tab);
	if (tab != NULL && *tab != NULL && size > 0)
	{
		write(1, "[", 1);
		i = 0;
		while (i < size)
		{
			ft_putnbr(*tab[i]);
			if (i < size - 1)
				write(1, ", ", 2);
			i++;
		}
		write(1, "]", 1);
	}
	else if (size == 0)
		printf("\nNone array - Reason : If the value of min is greater or equal to maxâ€™s value, range will point on NULL and it should return 0.");
	else if (size == -1)
		printf("\nIncomplete array - Reason : The size of range should be returned (or -1 on error).");
}

int	main(void)
{
	int	min;
	int	max;
	int	**ptr;
	int	*tab1 = NULL;
	int	tab1_size;
	int	**tab2 = NULL;
	int	tab2_size;
	int	**tab3 = NULL;
	int	tab3_size;
	int	**tab4 = NULL;
	int	tab4_size;

	min = 3;
	max = 8;
	tab1_size = ft_ultimate_range(&tab1, min, max);
	printf("Pour min = %d et max = %d, tab1 =\n", min, max);
	printf("&tab1 = %p\n", &tab1);
	ptr = &tab1;
	printf("ptr = %p\n", ptr);
	ft_print_int_tab(ptr, tab1_size);
	//free(*tab1);
	free(*ptr);
	free(ptr);
	/*min = 42;
	max = 42;
	tab2_size = ft_ultimate_range(tab2, min, max);
	printf("\nPour min = %d et max = %d, tab2 =\n", min, max);
	ft_print_int_tab(*tab2, tab2_size);
	free(*tab2);
	free(tab2);
	min = -42;
	max = 43;
	tab3_size = ft_ultimate_range(tab3, min, max);
	printf("\nPour min = %d et max = %d, tab3 =\n", min, max);
	ft_print_int_tab(*tab3, tab3_size);
	free(*tab3);
	free(tab3);
	min = 42;
	max = -1;
	tab4_size = ft_ultimate_range(tab4, min, max);
	printf("\nPour min = %d et max = %d, tab4 =\n", min, max);
	ft_print_int_tab(*tab4, tab4_size);
	free(*tab4);
	free(tab4);*/
	return (0);
}
e3r11p9% gcc -Wextra -Werror -o test_ft_ultimate_range -g ft_ultimate_range.c test_ft_ultimate_range.c
e3r11p9% ./test_ft_ultimate_range                                                                   
Pour min = 3 et max = 8, tab1 =
&tab1 = 0x7ffdc42cdbf0
ptr = 0x7ffdc42cdbf0
The returned size of range is 5.
*tab = (nil)
free(): invalid size
zsh: IOT instruction (core dumped)  ./test_ft_ultimate_range
e3r11p9% vi test_ft_ultimate_range.c                                                                 
e3r11p9% cat test_ft_ultimate_range.c                                                                 
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   test_ft_ultimate_range.c                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: hauerbac <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2023/02/22 17:56:00 by hauerbac          #+#    #+#             */
/*   Updated: 2023/02/23 19:14:35 by hauerbac         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>

int	ft_ultimate_range(int **range, int min, int max);

void	ft_putnbr(int nb)
{
	long	nb_in_long;
	int		digit_to_char;

	nb_in_long = nb;
	if (nb_in_long < 0)
	{
		write(1, "-", 1);
		nb_in_long = nb_in_long * -1;
	}
	if (nb_in_long < 10)
	{
		digit_to_char = nb_in_long + '0';
		write(1, &digit_to_char, 1);
	}
	else
	{
		ft_putnbr(nb_in_long / 10);
		ft_putnbr(nb_in_long % 10);
	}
}

void	ft_print_int_tab(int **tab, int size)
{
	int	i;

	printf("The returned size of range is %d.\n", size);
	printf("tab = %p\n", tab);
	if (tab != NULL && size > 0)
	{
		write(1, "[", 1);
		i = 0;
		while (i < size)
		{
			ft_putnbr(*tab[i]);
			if (i < size - 1)
				write(1, ", ", 2);
			i++;
		}
		write(1, "]", 1);
	}
	else if (size == 0)
		printf("\nNone array - Reason : If the value of min is greater or equal to maxâ€™s value, range will point on NULL and it should return 0.");
	else if (size == -1)
		printf("\nIncomplete array - Reason : The size of range should be returned (or -1 on error).");
}

int	main(void)
{
	int	min;
	int	max;
	int	**ptr;
	int	*tab1 = NULL;
	int	tab1_size;
	int	**tab2 = NULL;
	int	tab2_size;
	int	**tab3 = NULL;
	int	tab3_size;
	int	**tab4 = NULL;
	int	tab4_size;

	min = 3;
	max = 8;
	tab1_size = ft_ultimate_range(&tab1, min, max);
	printf("Pour min = %d et max = %d, tab1 =\n", min, max);
	printf("&tab1 = %p\n", &tab1);
	ptr = &tab1;
	printf("ptr = %p\n", ptr);
	ft_print_int_tab(ptr, tab1_size);
	//free(*tab1);
	free(*ptr);
	free(ptr);
	/*min = 42;
	max = 42;
	tab2_size = ft_ultimate_range(tab2, min, max);
	printf("\nPour min = %d et max = %d, tab2 =\n", min, max);
	ft_print_int_tab(*tab2, tab2_size);
	free(*tab2);
	free(tab2);
	min = -42;
	max = 43;
	tab3_size = ft_ultimate_range(tab3, min, max);
	printf("\nPour min = %d et max = %d, tab3 =\n", min, max);
	ft_print_int_tab(*tab3, tab3_size);
	free(*tab3);
	free(tab3);
	min = 42;
	max = -1;
	tab4_size = ft_ultimate_range(tab4, min, max);
	printf("\nPour min = %d et max = %d, tab4 =\n", min, max);
	ft_print_int_tab(*tab4, tab4_size);
	free(*tab4);
	free(tab4);*/
	return (0);
}
e3r11p9% gcc -Wextra -Werror -o test_ft_ultimate_range -g ft_ultimate_range.c test_ft_ultimate_range.c
e3r11p9% ./test_ft_ultimate_range                                                                   
Pour min = 3 et max = 8, tab1 =
&tab1 = 0x7ffcd384f610
ptr = 0x7ffcd384f610
The returned size of range is 5.
tab = 0x7ffcd384f610
[zsh: segmentation fault (core dumped)  ./test_ft_ultimate_range
e3r11p9% vi test_ft_ultimate_range.c                                                                 
e3r11p9% cat test_ft_ultimate_range.c                                                                 
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   test_ft_ultimate_range.c                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: hauerbac <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2023/02/22 17:56:00 by hauerbac          #+#    #+#             */
/*   Updated: 2023/02/23 19:48:02 by hauerbac         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>

int	ft_ultimate_range(int **range, int min, int max);

void	ft_putnbr(int nb)
{
	long	nb_in_long;
	int		digit_to_char;

	nb_in_long = nb;
	if (nb_in_long < 0)
	{
		write(1, "-", 1);
		nb_in_long = nb_in_long * -1;
	}
	if (nb_in_long < 10)
	{
		digit_to_char = nb_in_long + '0';
		write(1, &digit_to_char, 1);
	}
	else
	{
		ft_putnbr(nb_in_long / 10);
		ft_putnbr(nb_in_long % 10);
	}
}

void	ft_print_int_tab(int **tab, int size)
{
	int	i;

	printf("The returned size of range is %d.\n", size);
	printf("tab = %p\n", tab);
	if (tab != NULL && size > 0)
	{
		write(1, "[", 1);
		i = 0;
		while (i < size)
		{
			ft_putnbr(*(tab[i]));
			if (i < size - 1)
				write(1, ", ", 2);
			i++;
		}
		write(1, "]", 1);
	}
	else if (size == 0)
		printf("\nNone array - Reason : If the value of min is greater or equal to maxâ€™s value, range will point on NULL and it should return 0.");
	else if (size == -1)
		printf("\nIncomplete array - Reason : The size of range should be returned (or -1 on error).");
}

int	main(void)
{
	int	min;
	int	max;
	int	**ptr;
	int	*tab1 = NULL;
	int	tab1_size;
	int	**tab2 = NULL;
	int	tab2_size;
	int	**tab3 = NULL;
	int	tab3_size;
	int	**tab4 = NULL;
	int	tab4_size;

	min = 3;
	max = 8;
	tab1_size = ft_ultimate_range(&tab1, min, max);
	printf("Pour min = %d et max = %d, tab1 =\n", min, max);
	printf("&tab1 = %p\n", &tab1);
	ptr = &tab1;
	printf("ptr = %p\n", ptr);
	ft_print_int_tab(ptr, tab1_size);
	//free(*tab1);
	free(*ptr);
	free(ptr);
	/*min = 42;
	max = 42;
	tab2_size = ft_ultimate_range(tab2, min, max);
	printf("\nPour min = %d et max = %d, tab2 =\n", min, max);
	ft_print_int_tab(*tab2, tab2_size);
	free(*tab2);
	free(tab2);
	min = -42;
	max = 43;
	tab3_size = ft_ultimate_range(tab3, min, max);
	printf("\nPour min = %d et max = %d, tab3 =\n", min, max);
	ft_print_int_tab(*tab3, tab3_size);
	free(*tab3);
	free(tab3);
	min = 42;
	max = -1;
	tab4_size = ft_ultimate_range(tab4, min, max);
	printf("\nPour min = %d et max = %d, tab4 =\n", min, max);
	ft_print_int_tab(*tab4, tab4_size);
	free(*tab4);
	free(tab4);*/
	return (0);
}
e3r11p9% gcc -Wextra -Werror -o test_ft_ultimate_range -g ft_ultimate_range.c test_ft_ultimate_range.c
e3r11p9% ./test_ft_ultimate_range                                                                   
Pour min = 3 et max = 8, tab1 =
&tab1 = 0x7ffc62bc5520
ptr = 0x7ffc62bc5520
The returned size of range is 5.
tab = 0x7ffc62bc5520
[zsh: segmentation fault (core dumped)  ./test_ft_ultimate_range
e3r11p9% lldb test_ft_ultimate_range 
(lldb) target create "test_ft_ultimate_range"
Current executable set to '/mnt/nfs/homes/hauerbac/c_07/ex02/test_ft_ultimate_range' (x86_64).
(lldb) b main
Breakpoint 1: where = test_ft_ultimate_range`main + 27 at test_ft_ultimate_range.c:72:7, address = 0x000000000000150c
(lldb) run
warning: (x86_64) /usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2 unsupported DW_FORM value: 0x1f
Process 154928 launched: '/mnt/nfs/homes/hauerbac/c_07/ex02/test_ft_ultimate_range' (x86_64)
warning: (x86_64) /lib64/ld-linux-x86-64.so.2 unsupported DW_FORM value: 0x1f
warning: (x86_64) /lib/x86_64-linux-gnu/libc.so.6 unsupported DW_FORM value: 0x1f
Process 154928 stopped
* thread #1, name = 'test_ft_ultimat', stop reason = breakpoint 1.1
    frame #0: 0x000055555555550c test_ft_ultimate_range`main at test_ft_ultimate_range.c:72:7
   69  		int	min;
   70  		int	max;
   71  		int	**ptr;
-> 72  		int	*tab1 = NULL;
   73  		int	tab1_size;
   74  		int	**tab2 = NULL;
   75  		int	tab2_size;
(lldb) gui
(lldb) q
Quitting LLDB will kill one or more processes. Do you really want to proceed: [Y/n] y
Pour min = 3 et max = 8, tab1 =
&tab1 = 0x7fffffffe3e0
ptr = 0x7fffffffe3e0
The returned size of range is 5.
tab = 0x7fffffffe3e0
[%                                                                                                                                                        e3r11p9% vi test_ft_ultimate_range.c                                                                 
e3r11p9% cat test_ft_ultimate_range.c                                                                 
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   test_ft_ultimate_range.c                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: hauerbac <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2023/02/22 17:56:00 by hauerbac          #+#    #+#             */
/*   Updated: 2023/02/23 19:54:48 by hauerbac         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>

int	ft_ultimate_range(int **range, int min, int max);

void	ft_putnbr(int nb)
{
	long	nb_in_long;
	int		digit_to_char;

	nb_in_long = nb;
	if (nb_in_long < 0)
	{
		write(1, "-", 1);
		nb_in_long = nb_in_long * -1;
	}
	if (nb_in_long < 10)
	{
		digit_to_char = nb_in_long + '0';
		write(1, &digit_to_char, 1);
	}
	else
	{
		ft_putnbr(nb_in_long / 10);
		ft_putnbr(nb_in_long % 10);
	}
}

void	ft_print_int_tab(int **tab, int size)
{
	int	i;

	printf("The returned size of range is %d.\n", size);
	printf("tab = %p\n", tab);
	if (tab != NULL && size > 0)
	{
		write(1, "[", 1);
		i = 0;
		while (i < size)
		{
			ft_putnbr((*tab)[i]);
			if (i < size - 1)
				write(1, ", ", 2);
			i++;
		}
		write(1, "]", 1);
	}
	else if (size == 0)
		printf("\nNone array - Reason : If the value of min is greater or equal to maxâ€™s value, range will point on NULL and it should return 0.");
	else if (size == -1)
		printf("\nIncomplete array - Reason : The size of range should be returned (or -1 on error).");
}

int	main(void)
{
	int	min;
	int	max;
	int	**ptr;
	int	*tab1 = NULL;
	int	tab1_size;
	int	**tab2 = NULL;
	int	tab2_size;
	int	**tab3 = NULL;
	int	tab3_size;
	int	**tab4 = NULL;
	int	tab4_size;

	min = 3;
	max = 8;
	tab1_size = ft_ultimate_range(&tab1, min, max);
	printf("Pour min = %d et max = %d, tab1 =\n", min, max);
	printf("&tab1 = %p\n", &tab1);
	ptr = &tab1;
	printf("ptr = %p\n", ptr);
	ft_print_int_tab(ptr, tab1_size);
	//free(*tab1);
	free(*ptr);
	free(ptr);
	/*min = 42;
	max = 42;
	tab2_size = ft_ultimate_range(tab2, min, max);
	printf("\nPour min = %d et max = %d, tab2 =\n", min, max);
	ft_print_int_tab(*tab2, tab2_size);
	free(*tab2);
	free(tab2);
	min = -42;
	max = 43;
	tab3_size = ft_ultimate_range(tab3, min, max);
	printf("\nPour min = %d et max = %d, tab3 =\n", min, max);
	ft_print_int_tab(*tab3, tab3_size);
	free(*tab3);
	free(tab3);
	min = 42;
	max = -1;
	tab4_size = ft_ultimate_range(tab4, min, max);
	printf("\nPour min = %d et max = %d, tab4 =\n", min, max);
	ft_print_int_tab(*tab4, tab4_size);
	free(*tab4);
	free(tab4);*/
	return (0);
}
e3r11p9% ./test_ft_ultimate_range   
Pour min = 3 et max = 8, tab1 =
&tab1 = 0x7ffe4292e700
ptr = 0x7ffe4292e700
The returned size of range is 5.
tab = 0x7ffe4292e700
[zsh: segmentation fault (core dumped)  ./test_ft_ultimate_range
e3r11p9% vi test_ft_ultimate_range.c 
e3r11p9% cat test_ft_ultimate_range.c
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   test_ft_ultimate_range.c                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: hauerbac <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2023/02/22 17:56:00 by hauerbac          #+#    #+#             */
/*   Updated: 2023/02/23 19:56:09 by hauerbac         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>

int	ft_ultimate_range(int **range, int min, int max);

void	ft_putnbr(int nb)
{
	long	nb_in_long;
	int		digit_to_char;

	nb_in_long = nb;
	if (nb_in_long < 0)
	{
		write(1, "-", 1);
		nb_in_long = nb_in_long * -1;
	}
	if (nb_in_long < 10)
	{
		digit_to_char = nb_in_long + '0';
		write(1, &digit_to_char, 1);
	}
	else
	{
		ft_putnbr(nb_in_long / 10);
		ft_putnbr(nb_in_long % 10);
	}
}

void	ft_print_int_tab(int **tab, int size)
{
	int	i;

	printf("The returned size of range is %d.\n", size);
	printf("tab = %p\n", tab);
	if (tab != NULL && size > 0)
	{
		write(1, "[", 1);
		i = 0;
		while (i < size)
		{
			printf("%d", (*tab)[i]);
			ft_putnbr((*tab)[i]);
			if (i < size - 1)
				write(1, ", ", 2);
			i++;
		}
		write(1, "]", 1);
	}
	else if (size == 0)
		printf("\nNone array - Reason : If the value of min is greater or equal to maxâ€™s value, range will point on NULL and it should return 0.");
	else if (size == -1)
		printf("\nIncomplete array - Reason : The size of range should be returned (or -1 on error).");
}

int	main(void)
{
	int	min;
	int	max;
	int	**ptr;
	int	*tab1 = NULL;
	int	tab1_size;
	int	**tab2 = NULL;
	int	tab2_size;
	int	**tab3 = NULL;
	int	tab3_size;
	int	**tab4 = NULL;
	int	tab4_size;

	min = 3;
	max = 8;
	tab1_size = ft_ultimate_range(&tab1, min, max);
	printf("Pour min = %d et max = %d, tab1 =\n", min, max);
	printf("&tab1 = %p\n", &tab1);
	ptr = &tab1;
	printf("ptr = %p\n", ptr);
	ft_print_int_tab(ptr, tab1_size);
	//free(*tab1);
	free(*ptr);
	free(ptr);
	/*min = 42;
	max = 42;
	tab2_size = ft_ultimate_range(tab2, min, max);
	printf("\nPour min = %d et max = %d, tab2 =\n", min, max);
	ft_print_int_tab(*tab2, tab2_size);
	free(*tab2);
	free(tab2);
	min = -42;
	max = 43;
	tab3_size = ft_ultimate_range(tab3, min, max);
	printf("\nPour min = %d et max = %d, tab3 =\n", min, max);
	ft_print_int_tab(*tab3, tab3_size);
	free(*tab3);
	free(tab3);
	min = 42;
	max = -1;
	tab4_size = ft_ultimate_range(tab4, min, max);
	printf("\nPour min = %d et max = %d, tab4 =\n", min, max);
	ft_print_int_tab(*tab4, tab4_size);
	free(*tab4);
	free(tab4);*/
	return (0);
}
e3r11p9% gcc -Wextra -Werror -o test_ft_ultimate_range -g ft_ultimate_range.c test_ft_ultimate_range.c
e3r11p9% ./test_ft_ultimate_range                                                                   
Pour min = 3 et max = 8, tab1 =
&tab1 = 0x7ffc15c25fb0
ptr = 0x7ffc15c25fb0
The returned size of range is 5.
tab = 0x7ffc15c25fb0
[zsh: segmentation fault (core dumped)  ./test_ft_ultimate_range
e3r11p9% vi test_ft_ultimate_range.c                                                                 
e3r11p9% cat test_ft_ultimate_range.c                                                                 
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   test_ft_ultimate_range.c                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: hauerbac <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2023/02/22 17:56:00 by hauerbac          #+#    #+#             */
/*   Updated: 2023/02/23 19:57:59 by hauerbac         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>

int	ft_ultimate_range(int **range, int min, int max);

void	ft_putnbr(int nb)
{
	long	nb_in_long;
	int		digit_to_char;

	nb_in_long = nb;
	if (nb_in_long < 0)
	{
		write(1, "-", 1);
		nb_in_long = nb_in_long * -1;
	}
	if (nb_in_long < 10)
	{
		digit_to_char = nb_in_long + '0';
		write(1, &digit_to_char, 1);
	}
	else
	{
		ft_putnbr(nb_in_long / 10);
		ft_putnbr(nb_in_long % 10);
	}
}

void	ft_print_int_tab(int **tab, int size)
{
	int	i;

	printf("The returned size of range is %d.\n", size);
	printf("tab = %p\n", tab);
	if (tab != NULL && size > 0)
	{
		write(1, "[", 1);
		i = 0;
		while (i < size)
		{
			printf("%d", *tab[i]);
			//ft_putnbr(*tab[i]);
			if (i < size - 1)
				write(1, ", ", 2);
			i++;
		}
		write(1, "]", 1);
	}
	else if (size == 0)
		printf("\nNone array - Reason : If the value of min is greater or equal to maxâ€™s value, range will point on NULL and it should return 0.");
	else if (size == -1)
		printf("\nIncomplete array - Reason : The size of range should be returned (or -1 on error).");
}

int	main(void)
{
	int	min;
	int	max;
	int	**ptr;
	int	*tab1 = NULL;
	int	tab1_size;
	int	**tab2 = NULL;
	int	tab2_size;
	int	**tab3 = NULL;
	int	tab3_size;
	int	**tab4 = NULL;
	int	tab4_size;

	min = 3;
	max = 8;
	tab1_size = ft_ultimate_range(&tab1, min, max);
	printf("Pour min = %d et max = %d, tab1 =\n", min, max);
	printf("&tab1 = %p\n", &tab1);
	ptr = &tab1;
	printf("ptr = %p\n", ptr);
	ft_print_int_tab(ptr, tab1_size);
	//free(*tab1);
	free(*ptr);
	free(ptr);
	/*min = 42;
	max = 42;
	tab2_size = ft_ultimate_range(tab2, min, max);
	printf("\nPour min = %d et max = %d, tab2 =\n", min, max);
	ft_print_int_tab(*tab2, tab2_size);
	free(*tab2);
	free(tab2);
	min = -42;
	max = 43;
	tab3_size = ft_ultimate_range(tab3, min, max);
	printf("\nPour min = %d et max = %d, tab3 =\n", min, max);
	ft_print_int_tab(*tab3, tab3_size);
	free(*tab3);
	free(tab3);
	min = 42;
	max = -1;
	tab4_size = ft_ultimate_range(tab4, min, max);
	printf("\nPour min = %d et max = %d, tab4 =\n", min, max);
	ft_print_int_tab(*tab4, tab4_size);
	free(*tab4);
	free(tab4);*/
	return (0);
}
e3r11p9% gcc -Wextra -Werror -o test_ft_ultimate_range -g ft_ultimate_range.c test_ft_ultimate_range.c
e3r11p9% ./test_ft_ultimate_range                                                                   
Pour min = 3 et max = 8, tab1 =
&tab1 = 0x7ffec1415d10
ptr = 0x7ffec1415d10
The returned size of range is 5.
tab = 0x7ffec1415d10
[zsh: segmentation fault (core dumped)  ./test_ft_ultimate_range
e3r11p9% vi test_ft_ultimate_range.c                                                                 
e3r11p9% cat test_ft_ultimate_range.c                                                                 
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   test_ft_ultimate_range.c                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: hauerbac <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2023/02/22 17:56:00 by hauerbac          #+#    #+#             */
/*   Updated: 2023/02/23 19:58:31 by hauerbac         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>

int	ft_ultimate_range(int **range, int min, int max);

void	ft_putnbr(int nb)
{
	long	nb_in_long;
	int		digit_to_char;

	nb_in_long = nb;
	if (nb_in_long < 0)
	{
		write(1, "-", 1);
		nb_in_long = nb_in_long * -1;
	}
	if (nb_in_long < 10)
	{
		digit_to_char = nb_in_long + '0';
		write(1, &digit_to_char, 1);
	}
	else
	{
		ft_putnbr(nb_in_long / 10);
		ft_putnbr(nb_in_long % 10);
	}
}

void	ft_print_int_tab(int **tab, int size)
{
	int	i;

	printf("The returned size of range is %d.\n", size);
	printf("tab = %p\n", tab);
	if (tab != NULL && size > 0)
	{
		write(1, "[", 1);
		i = 0;
		while (i < size)
		{
			printf("%d", (*tab)[i]);
			//ft_putnbr(*tab[i]);
			if (i < size - 1)
				write(1, ", ", 2);
			i++;
		}
		write(1, "]", 1);
	}
	else if (size == 0)
		printf("\nNone array - Reason : If the value of min is greater or equal to maxâ€™s value, range will point on NULL and it should return 0.");
	else if (size == -1)
		printf("\nIncomplete array - Reason : The size of range should be returned (or -1 on error).");
}

int	main(void)
{
	int	min;
	int	max;
	int	**ptr;
	int	*tab1 = NULL;
	int	tab1_size;
	int	**tab2 = NULL;
	int	tab2_size;
	int	**tab3 = NULL;
	int	tab3_size;
	int	**tab4 = NULL;
	int	tab4_size;

	min = 3;
	max = 8;
	tab1_size = ft_ultimate_range(&tab1, min, max);
	printf("Pour min = %d et max = %d, tab1 =\n", min, max);
	printf("&tab1 = %p\n", &tab1);
	ptr = &tab1;
	printf("ptr = %p\n", ptr);
	ft_print_int_tab(ptr, tab1_size);
	//free(*tab1);
	free(*ptr);
	free(ptr);
	/*min = 42;
	max = 42;
	tab2_size = ft_ultimate_range(tab2, min, max);
	printf("\nPour min = %d et max = %d, tab2 =\n", min, max);
	ft_print_int_tab(*tab2, tab2_size);
	free(*tab2);
	free(tab2);
	min = -42;
	max = 43;
	tab3_size = ft_ultimate_range(tab3, min, max);
	printf("\nPour min = %d et max = %d, tab3 =\n", min, max);
	ft_print_int_tab(*tab3, tab3_size);
	free(*tab3);
	free(tab3);
	min = 42;
	max = -1;
	tab4_size = ft_ultimate_range(tab4, min, max);
	printf("\nPour min = %d et max = %d, tab4 =\n", min, max);
	ft_print_int_tab(*tab4, tab4_size);
	free(*tab4);
	free(tab4);*/
	return (0);
}
e3r11p9% gcc -Wextra -Werror -o test_ft_ultimate_range -g ft_ultimate_range.c test_ft_ultimate_range.c
e3r11p9% ./test_ft_ultimate_range                                                                   
Pour min = 3 et max = 8, tab1 =
&tab1 = 0x7ffead87f110
ptr = 0x7ffead87f110
The returned size of range is 5.
tab = 0x7ffead87f110
[zsh: segmentation fault (core dumped)  ./test_ft_ultimate_range
e3r11p9% vi test_ft_ultimate_range.c                                                                 
e3r11p9% cat test_ft_ultimate_range.c                                                                 
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   test_ft_ultimate_range.c                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: hauerbac <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2023/02/22 17:56:00 by hauerbac          #+#    #+#             */
/*   Updated: 2023/02/23 19:59:59 by hauerbac         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>

int	ft_ultimate_range(int **range, int min, int max);

void	ft_putnbr(int nb)
{
	long	nb_in_long;
	int		digit_to_char;

	nb_in_long = nb;
	if (nb_in_long < 0)
	{
		write(1, "-", 1);
		nb_in_long = nb_in_long * -1;
	}
	if (nb_in_long < 10)
	{
		digit_to_char = nb_in_long + '0';
		write(1, &digit_to_char, 1);
	}
	else
	{
		ft_putnbr(nb_in_long / 10);
		ft_putnbr(nb_in_long % 10);
	}
}

void	ft_print_int_tab(int **tab, int size)
{
	int	i;

	printf("The returned size of range is %d.\n", size);
	printf("tab = %p\n", tab);
	if (tab != NULL && size > 0)
	{
		write(1, "[", 1);
		i = 0;
		while (i < size)
		{
			printf("%d", *(tab[i]));
			//ft_putnbr(*tab[i]);
			if (i < size - 1)
				write(1, ", ", 2);
			i++;
		}
		write(1, "]", 1);
	}
	else if (size == 0)
		printf("\nNone array - Reason : If the value of min is greater or equal to maxâ€™s value, range will point on NULL and it should return 0.");
	else if (size == -1)
		printf("\nIncomplete array - Reason : The size of range should be returned (or -1 on error).");
}

int	main(void)
{
	int	min;
	int	max;
	int	**ptr;
	int	*tab1 = NULL;
	int	tab1_size;
	int	**tab2 = NULL;
	int	tab2_size;
	int	**tab3 = NULL;
	int	tab3_size;
	int	**tab4 = NULL;
	int	tab4_size;

	min = 3;
	max = 8;
	tab1_size = ft_ultimate_range(&tab1, min, max);
	printf("Pour min = %d et max = %d, tab1 =\n", min, max);
	printf("&tab1 = %p\n", &tab1);
	ptr = &tab1;
	printf("ptr = %p\n", ptr);
	ft_print_int_tab(ptr, tab1_size);
	//free(*tab1);
	free(*ptr);
	free(ptr);
	/*min = 42;
	max = 42;
	tab2_size = ft_ultimate_range(tab2, min, max);
	printf("\nPour min = %d et max = %d, tab2 =\n", min, max);
	ft_print_int_tab(*tab2, tab2_size);
	free(*tab2);
	free(tab2);
	min = -42;
	max = 43;
	tab3_size = ft_ultimate_range(tab3, min, max);
	printf("\nPour min = %d et max = %d, tab3 =\n", min, max);
	ft_print_int_tab(*tab3, tab3_size);
	free(*tab3);
	free(tab3);
	min = 42;
	max = -1;
	tab4_size = ft_ultimate_range(tab4, min, max);
	printf("\nPour min = %d et max = %d, tab4 =\n", min, max);
	ft_print_int_tab(*tab4, tab4_size);
	free(*tab4);
	free(tab4);*/
	return (0);
}
e3r11p9% gcc -Wextra -Werror -o test_ft_ultimate_range -g ft_ultimate_range.c test_ft_ultimate_range.c
e3r11p9% ./test_ft_ultimate_range                                                                   
Pour min = 3 et max = 8, tab1 =
&tab1 = 0x7ffc654a4cf0
ptr = 0x7ffc654a4cf0
The returned size of range is 5.
tab = 0x7ffc654a4cf0
[zsh: segmentation fault (core dumped)  ./test_ft_ultimate_range
e3r11p9% lldb test_ft_ultimate_range                                                            
(lldb) target create "test_ft_ultimate_range"
Current executable set to '/mnt/nfs/homes/hauerbac/c_07/ex02/test_ft_ultimate_range' (x86_64).
(lldb) b main
Breakpoint 1: where = test_ft_ultimate_range`main + 27 at test_ft_ultimate_range.c:73:7, address = 0x0000000000001518
(lldb) run
warning: (x86_64) /usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2 unsupported DW_FORM value: 0x1f
Process 156960 launched: '/mnt/nfs/homes/hauerbac/c_07/ex02/test_ft_ultimate_range' (x86_64)
warning: (x86_64) /lib64/ld-linux-x86-64.so.2 unsupported DW_FORM value: 0x1f
warning: (x86_64) /lib/x86_64-linux-gnu/libc.so.6 unsupported DW_FORM value: 0x1f
Process 156960 stopped
* thread #1, name = 'test_ft_ultimat', stop reason = breakpoint 1.1
    frame #0: 0x0000555555555518 test_ft_ultimate_range`main at test_ft_ultimate_range.c:73:7
   70  		int	min;
   71  		int	max;
   72  		int	**ptr;
-> 73  		int	*tab1 = NULL;
   74  		int	tab1_size;
   75  		int	**tab2 = NULL;
   76  		int	tab2_size;
(lldb) gui
(lldb) q
Quitting LLDB will kill one or more processes. Do you really want to proceed: [Y/n] y
Pour min = 3 et max = 8, tab1 =
&tab1 = 0x7fffffffe3e0
ptr = 0x7fffffffe3e0
The returned size of range is 5.
tab = 0x7fffffffe3e0
[%                                                                                                                                                        e3r11p9% vi ft_ultimate_range.c                                                                 
e3r11p9% cat ft_ultimate_range.c                                                                 
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_ultimate_range.c                                :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: hauerbac <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2023/02/23 10:23:31 by hauerbac          #+#    #+#             */
/*   Updated: 2023/02/23 20:04:46 by hauerbac         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include <stdlib.h>
#include <stdio.h>

int	*ft_range(int min, int max)
{
	int	range_len;
	int	*ptr;
	int	i;
	int	value;
	int	val;

	if (min < max)
	{
		range_len = max - min;
		ptr = (int *) malloc(range_len * sizeof(int));
		if (ptr)
		{
			value = min;
			i = 0;
			while (i < range_len && value < max)
			{
				ptr[i++] = value++;
				val = ptr[i - 1];
				printf("%d ", val);
			}
			if (i == range_len)
				return (ptr);
			else
				return (NULL);
		}
	}
	return (NULL);
}

int	ft_ultimate_range(int **range, int min, int max)
{
	int	range_len;
	int	*ptr;

	range = NULL;
	if (min < max)
	{
		range = (int **) malloc(sizeof(int *));
		if (range == NULL)
			return (-1);
		range_len = max - min;
		ptr = ft_range(min, max);
		if (ptr)
		{
			*range = ptr;
			return (range_len);
		}
		else
			return (-1);
	}
	else
		return (0);
}
e3r11p9% gcc -Wextra -Werror -o test_ft_ultimate_range -g ft_ultimate_range.c test_ft_ultimate_range.c
e3r11p9% ./test_ft_ultimate_range                                                                 
3 4 5 6 7 Pour min = 3 et max = 8, tab1 =
&tab1 = 0x7ffff608df70
ptr = 0x7ffff608df70
The returned size of range is 5.
tab = 0x7ffff608df70
[zsh: segmentation fault (core dumped)  ./test_ft_ultimate_range
e3r11p9% vi ft_ultimate_range.c                                                                      
e3r11p9% cat ft_ultimate_range.c 
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_ultimate_range.c                                :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: hauerbac <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2023/02/23 10:23:31 by hauerbac          #+#    #+#             */
/*   Updated: 2023/02/23 20:06:43 by hauerbac         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include <stdlib.h>

int	*ft_range(int min, int max)
{
	int	range_len;
	int	*ptr;
	int	i;
	int	value;

	if (min < max)
	{
		range_len = max - min;
		ptr = (int *) malloc(range_len * sizeof(int));
		if (ptr)
		{
			value = min;
			i = 0;
			while (i < range_len && value < max)
				ptr[i++] = value++;
			if (i == range_len)
				return (ptr);
			else
				return (NULL);
		}
	}
	return (NULL);
}

int	ft_ultimate_range(int **range, int min, int max)
{
	int	range_len;
	int	*ptr;

	range = NULL;
	if (min < max)
	{
		range = (int **) malloc(sizeof(int *));
		if (range == NULL)
			return (-1);
		range_len = max - min;
		ptr = ft_range(min, max);
		if (ptr)
		{
			*range = ptr;
			return (range_len);
		}
		else
			return (-1);
	}
	else
		return (0);
}
e3r11p9% vi test_ft_ultimate_range.c                                                                 
e3r11p9% cat test_ft_ultimate_range.c                                                                 
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   test_ft_ultimate_range.c                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: hauerbac <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2023/02/22 17:56:00 by hauerbac          #+#    #+#             */
/*   Updated: 2023/02/23 20:08:27 by hauerbac         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>

int	ft_ultimate_range(int **range, int min, int max);

void	ft_putnbr(int nb)
{
	long	nb_in_long;
	int		digit_to_char;

	nb_in_long = nb;
	if (nb_in_long < 0)
	{
		write(1, "-", 1);
		nb_in_long = nb_in_long * -1;
	}
	if (nb_in_long < 10)
	{
		digit_to_char = nb_in_long + '0';
		write(1, &digit_to_char, 1);
	}
	else
	{
		ft_putnbr(nb_in_long / 10);
		ft_putnbr(nb_in_long % 10);
	}
}

void	ft_print_int_tab(int **tab, int size)
{
	int	i;
	int	val;

	printf("The returned size of range is %d.\n", size);
	printf("tab = %p\n", tab);
	if (tab != NULL && size > 0)
	{
		write(1, "[", 1);
		i = 0;
		while (i < size)
		{
			val = *(*(tab) + i);
			printf("%d", *(*(tab) + i));
			//ft_putnbr(*tab[i]);
			if (i < size - 1)
				write(1, ", ", 2);
			i++;
		}
		write(1, "]", 1);
	}
	else if (size == 0)
		printf("\nNone array - Reason : If the value of min is greater or equal to maxâ€™s value, range will point on NULL and it should return 0.");
	else if (size == -1)
		printf("\nIncomplete array - Reason : The size of range should be returned (or -1 on error).");
}

int	main(void)
{
	int	min;
	int	max;
	int	**ptr;
	int	*tab1 = NULL;
	int	tab1_size;
	int	**tab2 = NULL;
	int	tab2_size;
	int	**tab3 = NULL;
	int	tab3_size;
	int	**tab4 = NULL;
	int	tab4_size;

	min = 3;
	max = 8;
	tab1_size = ft_ultimate_range(&tab1, min, max);
	printf("Pour min = %d et max = %d, tab1 =\n", min, max);
	printf("&tab1 = %p\n", &tab1);
	ptr = &tab1;
	printf("ptr = %p\n", ptr);
	ft_print_int_tab(ptr, tab1_size);
	//free(*tab1);
	free(*ptr);
	free(ptr);
	/*min = 42;
	max = 42;
	tab2_size = ft_ultimate_range(tab2, min, max);
	printf("\nPour min = %d et max = %d, tab2 =\n", min, max);
	ft_print_int_tab(*tab2, tab2_size);
	free(*tab2);
	free(tab2);
	min = -42;
	max = 43;
	tab3_size = ft_ultimate_range(tab3, min, max);
	printf("\nPour min = %d et max = %d, tab3 =\n", min, max);
	ft_print_int_tab(*tab3, tab3_size);
	free(*tab3);
	free(tab3);
	min = 42;
	max = -1;
	tab4_size = ft_ultimate_range(tab4, min, max);
	printf("\nPour min = %d et max = %d, tab4 =\n", min, max);
	ft_print_int_tab(*tab4, tab4_size);
	free(*tab4);
	free(tab4);*/
	return (0);
}
e3r11p9% gcc -Wextra -Werror -o test_ft_ultimate_range -g ft_ultimate_range.c test_ft_ultimate_range.c
e3r11p9% ./test_ft_ultimate_range                                                               
Pour min = 3 et max = 8, tab1 =
&tab1 = 0x7ffd56dc0ea0
ptr = 0x7ffd56dc0ea0
The returned size of range is 5.
tab = 0x7ffd56dc0ea0
[zsh: segmentation fault (core dumped)  ./test_ft_ultimate_range
e3r11p9% lldb test_ft_ultimate_range                                                                 
(lldb) target create "test_ft_ultimate_range"
Current executable set to '/mnt/nfs/homes/hauerbac/c_07/ex02/test_ft_ultimate_range' (x86_64).
(lldb) b main
Breakpoint 1: where = test_ft_ultimate_range`main + 27 at test_ft_ultimate_range.c:75:7, address = 0x000000000000152c
(lldb) run
warning: (x86_64) /usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2 unsupported DW_FORM value: 0x1f
Process 158475 launched: '/mnt/nfs/homes/hauerbac/c_07/ex02/test_ft_ultimate_range' (x86_64)
warning: (x86_64) /lib64/ld-linux-x86-64.so.2 unsupported DW_FORM value: 0x1f
warning: (x86_64) /lib/x86_64-linux-gnu/libc.so.6 unsupported DW_FORM value: 0x1f
Process 158475 stopped
* thread #1, name = 'test_ft_ultimat', stop reason = breakpoint 1.1
    frame #0: 0x000055555555552c test_ft_ultimate_range`main at test_ft_ultimate_range.c:75:7
   72  		int	min;
   73  		int	max;
   74  		int	**ptr;
-> 75  		int	*tab1 = NULL;
   76  		int	tab1_size;
   77  		int	**tab2 = NULL;
   78  		int	tab2_size;
(lldb) gui
(lldb) q
Quitting LLDB will kill one or more processes. Do you really want to proceed: [Y/n] y
Pour min = 3 et max = 8, tab1 =
&tab1 = 0x7fffffffe3e0
ptr = 0x7fffffffe3e0
The returned size of range is 5.
tab = 0x7fffffffe3e0
[%                                                                                                                                                        e3r11p9% vi test_ft_ultimate_range.c                                                                 
e3r11p9% cat test_ft_ultimate_range.c                                                                 
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   test_ft_ultimate_range.c                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: hauerbac <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2023/02/22 17:56:00 by hauerbac          #+#    #+#             */
/*   Updated: 2023/02/23 20:13:11 by hauerbac         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>

int	ft_ultimate_range(int **range, int min, int max);

void	ft_putnbr(int nb)
{
	long	nb_in_long;
	int		digit_to_char;

	nb_in_long = nb;
	if (nb_in_long < 0)
	{
		write(1, "-", 1);
		nb_in_long = nb_in_long * -1;
	}
	if (nb_in_long < 10)
	{
		digit_to_char = nb_in_long + '0';
		write(1, &digit_to_char, 1);
	}
	else
	{
		ft_putnbr(nb_in_long / 10);
		ft_putnbr(nb_in_long % 10);
	}
}

void	ft_print_int_tab(int **tab, int size)
{
	int	i;
	int	val;

	printf("The returned size of range is %d.\n", size);
	printf("tab = %p\n", tab);
	if (tab != NULL && size > 0)
	{
		write(1, "[", 1);
		i = 0;
		val = 0;
		while (i < size)
		{
			val = tab[0][i];
			printf("%d", tab[0][i]);
			//ft_putnbr(tab[0][i]);
			if (i < size - 1)
				write(1, ", ", 2);
			i++;
		}
		write(1, "]", 1);
	}
	else if (size == 0)
		printf("\nNone array - Reason : If the value of min is greater or equal to maxâ€™s value, range will point on NULL and it should return 0.");
	else if (size == -1)
		printf("\nIncomplete array - Reason : The size of range should be returned (or -1 on error).");
}

int	main(void)
{
	int	min;
	int	max;
	int	**ptr;
	int	*tab1 = NULL;
	int	tab1_size;
	int	**tab2 = NULL;
	int	tab2_size;
	int	**tab3 = NULL;
	int	tab3_size;
	int	**tab4 = NULL;
	int	tab4_size;

	min = 3;
	max = 8;
	tab1_size = ft_ultimate_range(&tab1, min, max);
	printf("Pour min = %d et max = %d, tab1 =\n", min, max);
	printf("&tab1 = %p\n", &tab1);
	ptr = &tab1;
	printf("ptr = %p\n", ptr);
	ft_print_int_tab(ptr, tab1_size);
	//free(*tab1);
	free(*ptr);
	free(ptr);
	/*min = 42;
	max = 42;
	tab2_size = ft_ultimate_range(tab2, min, max);
	printf("\nPour min = %d et max = %d, tab2 =\n", min, max);
	ft_print_int_tab(*tab2, tab2_size);
	free(*tab2);
	free(tab2);
	min = -42;
	max = 43;
	tab3_size = ft_ultimate_range(tab3, min, max);
	printf("\nPour min = %d et max = %d, tab3 =\n", min, max);
	ft_print_int_tab(*tab3, tab3_size);
	free(*tab3);
	free(tab3);
	min = 42;
	max = -1;
	tab4_size = ft_ultimate_range(tab4, min, max);
	printf("\nPour min = %d et max = %d, tab4 =\n", min, max);
	ft_print_int_tab(*tab4, tab4_size);
	free(*tab4);
	free(tab4);*/
	return (0);
}
e3r11p9% gcc -Wextra -Werror -o test_ft_ultimate_range -g ft_ultimate_range.c test_ft_ultimate_range.c
e3r11p9% ./test_ft_ultimate_range                                                                 
Pour min = 3 et max = 8, tab1 =
&tab1 = 0x7ffeee343f10
ptr = 0x7ffeee343f10
The returned size of range is 5.
tab = 0x7ffeee343f10
[zsh: segmentation fault (core dumped)  ./test_ft_ultimate_range
e3r11p9% ls -al                                                                                      
total 40
drwxr-xr-x 2 hauerbac 2023_paris  4096 Feb 23 20:13 .
drwxr-xr-x 5 hauerbac 2023_paris  4096 Feb 22 19:16 ..
-rw-r--r-- 1 hauerbac 2023_paris  1930 Feb 23 09:57 ft_ultimate_range_0.c
-rw-r--r-- 1 hauerbac 2023_paris  1643 Feb 23 20:06 ft_ultimate_range.c
-rwxr-xr-x 1 hauerbac 2023_paris 18928 Feb 23 20:13 test_ft_ultimate_range
-rw-r--r-- 1 hauerbac 2023_paris  3095 Feb 23 20:13 test_ft_ultimate_range.c
e3r11p9% lldb test_ft_ultimate_range                                                                 
(lldb) target create "test_ft_ultimate_range"
Current executable set to '/mnt/nfs/homes/hauerbac/c_07/ex02/test_ft_ultimate_range' (x86_64).
(lldb) b main
Breakpoint 1: where = test_ft_ultimate_range`main + 27 at test_ft_ultimate_range.c:76:7, address = 0x0000000000001533
(lldb) run
warning: (x86_64) /usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2 unsupported DW_FORM value: 0x1f
Process 159326 launched: '/mnt/nfs/homes/hauerbac/c_07/ex02/test_ft_ultimate_range' (x86_64)
warning: (x86_64) /lib64/ld-linux-x86-64.so.2 unsupported DW_FORM value: 0x1f
warning: (x86_64) /lib/x86_64-linux-gnu/libc.so.6 unsupported DW_FORM value: 0x1f
Process 159326 stopped
* thread #1, name = 'test_ft_ultimat', stop reason = breakpoint 1.1
    frame #0: 0x0000555555555533 test_ft_ultimate_range`main at test_ft_ultimate_range.c:76:7
   73  		int	min;
   74  		int	max;
   75  		int	**ptr;
-> 76  		int	*tab1 = NULL;
   77  		int	tab1_size;
   78  		int	**tab2 = NULL;
   79  		int	tab2_size;
(lldb) gui
(lldb) q
Quitting LLDB will kill one or more processes. Do you really want to proceed: [Y/n] y
Pour min = 3 et max = 8, tab1 =
&tab1 = 0x7fffffffe3e0
ptr = 0x7fffffffe3e0
The returned size of range is 5.
tab = 0x7fffffffe3e0
[%                                                                                                                                                        e3r11p9% vi test_ft_ultimate_range.c                                                                 
e3r11p9% cat test_ft_ultimate_range.c                                                                 
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   test_ft_ultimate_range.c                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: hauerbac <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2023/02/22 17:56:00 by hauerbac          #+#    #+#             */
/*   Updated: 2023/02/23 20:16:21 by hauerbac         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>

int	ft_ultimate_range(int **range, int min, int max);

void	ft_putnbr(int nb)
{
	long	nb_in_long;
	int		digit_to_char;

	nb_in_long = nb;
	if (nb_in_long < 0)
	{
		write(1, "-", 1);
		nb_in_long = nb_in_long * -1;
	}
	if (nb_in_long < 10)
	{
		digit_to_char = nb_in_long + '0';
		write(1, &digit_to_char, 1);
	}
	else
	{
		ft_putnbr(nb_in_long / 10);
		ft_putnbr(nb_in_long % 10);
	}
}

void	ft_print_int_tab(int **tab, int size)
{
	int	i;
	int	val;

	printf("The returned size of range is %d.\n", size);
	printf("tab = %p\n", tab);
	if (tab != NULL && size > 0)
	{
		write(1, "[", 1);
		i = 0;
		val = 0;
		while (i < size)
		{
			val = tab[i][0];
			printf("%d", tab[i][0]);
			//ft_putnbr(tab[0][i]);
			if (i < size - 1)
				write(1, ", ", 2);
			i++;
		}
		write(1, "]", 1);
	}
	else if (size == 0)
		printf("\nNone array - Reason : If the value of min is greater or equal to maxâ€™s value, range will point on NULL and it should return 0.");
	else if (size == -1)
		printf("\nIncomplete array - Reason : The size of range should be returned (or -1 on error).");
}

int	main(void)
{
	int	min;
	int	max;
	int	**ptr;
	int	*tab1 = NULL;
	int	tab1_size;
	int	**tab2 = NULL;
	int	tab2_size;
	int	**tab3 = NULL;
	int	tab3_size;
	int	**tab4 = NULL;
	int	tab4_size;

	min = 3;
	max = 8;
	tab1_size = ft_ultimate_range(&tab1, min, max);
	printf("Pour min = %d et max = %d, tab1 =\n", min, max);
	printf("&tab1 = %p\n", &tab1);
	ptr = &tab1;
	printf("ptr = %p\n", ptr);
	ft_print_int_tab(ptr, tab1_size);
	//free(*tab1);
	free(*ptr);
	free(ptr);
	/*min = 42;
	max = 42;
	tab2_size = ft_ultimate_range(tab2, min, max);
	printf("\nPour min = %d et max = %d, tab2 =\n", min, max);
	ft_print_int_tab(*tab2, tab2_size);
	free(*tab2);
	free(tab2);
	min = -42;
	max = 43;
	tab3_size = ft_ultimate_range(tab3, min, max);
	printf("\nPour min = %d et max = %d, tab3 =\n", min, max);
	ft_print_int_tab(*tab3, tab3_size);
	free(*tab3);
	free(tab3);
	min = 42;
	max = -1;
	tab4_size = ft_ultimate_range(tab4, min, max);
	printf("\nPour min = %d et max = %d, tab4 =\n", min, max);
	ft_print_int_tab(*tab4, tab4_size);
	free(*tab4);
	free(tab4);*/
	return (0);
}
e3r11p9% gcc -Wextra -Werror -o test_ft_ultimate_range -g ft_ultimate_range.c test_ft_ultimate_range.c
e3r11p9% lldb test_ft_ultimate_range                                                                 
(lldb) target create "test_ft_ultimate_range"
Current executable set to '/mnt/nfs/homes/hauerbac/c_07/ex02/test_ft_ultimate_range' (x86_64).
(lldb) b main
Breakpoint 1: where = test_ft_ultimate_range`main + 27 at test_ft_ultimate_range.c:76:7, address = 0x000000000000153b
(lldb) run
warning: (x86_64) /usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2 unsupported DW_FORM value: 0x1f
Process 159818 launched: '/mnt/nfs/homes/hauerbac/c_07/ex02/test_ft_ultimate_range' (x86_64)
warning: (x86_64) /lib64/ld-linux-x86-64.so.2 unsupported DW_FORM value: 0x1f
warning: (x86_64) /lib/x86_64-linux-gnu/libc.so.6 unsupported DW_FORM value: 0x1f
Process 159818 stopped
* thread #1, name = 'test_ft_ultimat', stop reason = breakpoint 1.1
    frame #0: 0x000055555555553b test_ft_ultimate_range`main at test_ft_ultimate_range.c:76:7
   73  		int	min;
   74  		int	max;
   75  		int	**ptr;
-> 76  		int	*tab1 = NULL;
   77  		int	tab1_size;
   78  		int	**tab2 = NULL;
   79  		int	tab2_size;
(lldb) gui
(lldb) q
Quitting LLDB will kill one or more processes. Do you really want to proceed: [Y/n] y
Pour min = 3 et max = 8, tab1 =
&tab1 = 0x7fffffffe3e0
ptr = 0x7fffffffe3e0
The returned size of range is 5.
tab = 0x7fffffffe3e0
[%                                                                                                                                                        e3r11p9% vi test_ft_ultimate_range.c                                                                 
e3r11p9% cat test_ft_ultimate_range.c                                                                 
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   test_ft_ultimate_range.c                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: hauerbac <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2023/02/22 17:56:00 by hauerbac          #+#    #+#             */
/*   Updated: 2023/02/23 20:22:39 by hauerbac         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>

int	ft_ultimate_range(int **range, int min, int max);

void	ft_putnbr(int nb)
{
	long	nb_in_long;
	int		digit_to_char;

	nb_in_long = nb;
	if (nb_in_long < 0)
	{
		write(1, "-", 1);
		nb_in_long = nb_in_long * -1;
	}
	if (nb_in_long < 10)
	{
		digit_to_char = nb_in_long + '0';
		write(1, &digit_to_char, 1);
	}
	else
	{
		ft_putnbr(nb_in_long / 10);
		ft_putnbr(nb_in_long % 10);
	}
}

void	ft_print_int_tab(int **tab, int size)
{
	int	i;
	int	val;

	printf("The returned size of range is %d.\n", size);
	printf("tab = %p\n", tab);
	printf("tab[0] = %p\n", tab[0]);
	printf("tab[0][0] = %p\n", tab[0][0]);
	if (tab != NULL && tab[0] != NULL && size > 0)
	{
		write(1, "[", 1);
		i = 0;
		val = 0;
		while (i < size)
		{
			val = tab[0][0];
			printf("%d", tab[0][0]);
			//ft_putnbr(tab[0][i]);
			if (i < size - 1)
				write(1, ", ", 2);
			i++;
		}
		write(1, "]", 1);
	}
	else if (size == 0)
		printf("\nNone array - Reason : If the value of min is greater or equal to maxâ€™s value, range will point on NULL and it should return 0.");
	else if (size == -1)
		printf("\nIncomplete array - Reason : The size of range should be returned (or -1 on error).");
}

int	main(void)
{
	int	min;
	int	max;
	int	**ptr;
	int	*tab1 = NULL;
	int	tab1_size;
	int	**tab2 = NULL;
	int	tab2_size;
	int	**tab3 = NULL;
	int	tab3_size;
	int	**tab4 = NULL;
	int	tab4_size;

	min = 3;
	max = 8;
	tab1_size = ft_ultimate_range(&tab1, min, max);
	printf("Pour min = %d et max = %d, tab1 =\n", min, max);
	printf("&tab1 = %p\n", &tab1);
	ptr = &tab1;
	printf("ptr = %p\n", ptr);
	ft_print_int_tab(ptr, tab1_size);
	//free(*tab1);
	free(*ptr);
	free(ptr);
	/*min = 42;
	max = 42;
	tab2_size = ft_ultimate_range(tab2, min, max);
	printf("\nPour min = %d et max = %d, tab2 =\n", min, max);
	ft_print_int_tab(*tab2, tab2_size);
	free(*tab2);
	free(tab2);
	min = -42;
	max = 43;
	tab3_size = ft_ultimate_range(tab3, min, max);
	printf("\nPour min = %d et max = %d, tab3 =\n", min, max);
	ft_print_int_tab(*tab3, tab3_size);
	free(*tab3);
	free(tab3);
	min = 42;
	max = -1;
	tab4_size = ft_ultimate_range(tab4, min, max);
	printf("\nPour min = %d et max = %d, tab4 =\n", min, max);
	ft_print_int_tab(*tab4, tab4_size);
	free(*tab4);
	free(tab4);*/
	return (0);
}
e3r11p9% gcc -Wextra -Werror -o test_ft_ultimate_range -g ft_ultimate_range.c test_ft_ultimate_range.c
test_ft_ultimate_range.c: In function â€˜ft_print_int_tabâ€™:
test_ft_ultimate_range.c:50:23: error: format â€˜%pâ€™ expects argument of type â€˜void *â€™, but argument 2 has type â€˜intâ€™ [-Werror=format=]
   50 |  printf("tab[0][0] = %p\n", tab[0][0]);
      |                      ~^     ~~~~~~~~~
      |                       |           |
      |                       void *      int
      |                      %d
cc1: all warnings being treated as errors
e3r11p9% vi test_ft_ultimate_range.c                                                                 
e3r11p9% cat test_ft_ultimate_range.c                                                                 
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   test_ft_ultimate_range.c                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: hauerbac <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2023/02/22 17:56:00 by hauerbac          #+#    #+#             */
/*   Updated: 2023/02/23 20:22:58 by hauerbac         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>

int	ft_ultimate_range(int **range, int min, int max);

void	ft_putnbr(int nb)
{
	long	nb_in_long;
	int		digit_to_char;

	nb_in_long = nb;
	if (nb_in_long < 0)
	{
		write(1, "-", 1);
		nb_in_long = nb_in_long * -1;
	}
	if (nb_in_long < 10)
	{
		digit_to_char = nb_in_long + '0';
		write(1, &digit_to_char, 1);
	}
	else
	{
		ft_putnbr(nb_in_long / 10);
		ft_putnbr(nb_in_long % 10);
	}
}

void	ft_print_int_tab(int **tab, int size)
{
	int	i;
	int	val;

	printf("The returned size of range is %d.\n", size);
	printf("tab = %p\n", tab);
	printf("tab[0] = %p\n", tab[0]);
	printf("tab[0][0] = %d\n", tab[0][0]);
	if (tab != NULL && tab[0] != NULL && size > 0)
	{
		write(1, "[", 1);
		i = 0;
		val = 0;
		while (i < size)
		{
			val = tab[0][0];
			printf("%d", tab[0][0]);
			//ft_putnbr(tab[0][i]);
			if (i < size - 1)
				write(1, ", ", 2);
			i++;
		}
		write(1, "]", 1);
	}
	else if (size == 0)
		printf("\nNone array - Reason : If the value of min is greater or equal to maxâ€™s value, range will point on NULL and it should return 0.");
	else if (size == -1)
		printf("\nIncomplete array - Reason : The size of range should be returned (or -1 on error).");
}

int	main(void)
{
	int	min;
	int	max;
	int	**ptr;
	int	*tab1 = NULL;
	int	tab1_size;
	int	**tab2 = NULL;
	int	tab2_size;
	int	**tab3 = NULL;
	int	tab3_size;
	int	**tab4 = NULL;
	int	tab4_size;

	min = 3;
	max = 8;
	tab1_size = ft_ultimate_range(&tab1, min, max);
	printf("Pour min = %d et max = %d, tab1 =\n", min, max);
	printf("&tab1 = %p\n", &tab1);
	ptr = &tab1;
	printf("ptr = %p\n", ptr);
	ft_print_int_tab(ptr, tab1_size);
	//free(*tab1);
	free(*ptr);
	free(ptr);
	/*min = 42;
	max = 42;
	tab2_size = ft_ultimate_range(tab2, min, max);
	printf("\nPour min = %d et max = %d, tab2 =\n", min, max);
	ft_print_int_tab(*tab2, tab2_size);
	free(*tab2);
	free(tab2);
	min = -42;
	max = 43;
	tab3_size = ft_ultimate_range(tab3, min, max);
	printf("\nPour min = %d et max = %d, tab3 =\n", min, max);
	ft_print_int_tab(*tab3, tab3_size);
	free(*tab3);
	free(tab3);
	min = 42;
	max = -1;
	tab4_size = ft_ultimate_range(tab4, min, max);
	printf("\nPour min = %d et max = %d, tab4 =\n", min, max);
	ft_print_int_tab(*tab4, tab4_size);
	free(*tab4);
	free(tab4);*/
	return (0);
}
e3r11p9% gcc -Wextra -Werror -o test_ft_ultimate_range -g ft_ultimate_range.c test_ft_ultimate_range.c
e3r11p9% ./test_ft_ultimate_range                                                                     
Pour min = 3 et max = 8, tab1 =
&tab1 = 0x7ffe2f046e40
ptr = 0x7ffe2f046e40
The returned size of range is 5.
tab = 0x7ffe2f046e40
tab[0] = (nil)
zsh: segmentation fault (core dumped)  ./test_ft_ultimate_range
e3r11p9% vi test_ft_ultimate_range.c                                                                 
e3r11p9% cat test_ft_ultimate_range.c                                                                 
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   test_ft_ultimate_range.c                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: hauerbac <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2023/02/22 17:56:00 by hauerbac          #+#    #+#             */
/*   Updated: 2023/02/23 20:29:11 by hauerbac         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>

int	ft_ultimate_range(int **range, int min, int max);

void	ft_putnbr(int nb)
{
	long	nb_in_long;
	int		digit_to_char;

	nb_in_long = nb;
	if (nb_in_long < 0)
	{
		write(1, "-", 1);
		nb_in_long = nb_in_long * -1;
	}
	if (nb_in_long < 10)
	{
		digit_to_char = nb_in_long + '0';
		write(1, &digit_to_char, 1);
	}
	else
	{
		ft_putnbr(nb_in_long / 10);
		ft_putnbr(nb_in_long % 10);
	}
}

void	ft_print_int_tab(int **tab, int size)
{
	int	i;
	int	val;

	printf("The returned size of range is %d.\n", size);
	printf("tab = %p\n", tab);
	printf("tab[0] = %p\n", tab[0]);
	printf("tab[0][0] = %d\n", tab[0][0]);
	if (tab != NULL && tab[0] != NULL && size > 0)
	{
		write(1, "[", 1);
		i = 0;
		val = 0;
		while (i < size)
		{
			val = tab[0][0];
			printf("%d", tab[0][0]);
			//ft_putnbr(tab[0][i]);
			if (i < size - 1)
				write(1, ", ", 2);
			i++;
		}
		write(1, "]", 1);
	}
	else if (size == 0)
		printf("\nNone array - Reason : If the value of min is greater or equal to maxâ€™s value, range will point on NULL and it should return 0.");
	else if (size == -1)
		printf("\nIncomplete array - Reason : The size of range should be returned (or -1 on error).");
}

int	main(void)
{
	int	min;
	int	max;
	int	**ptr;
	int	*tab1 = NULL;
	int	tab1_size;
	int	**tab2 = NULL;
	int	tab2_size;
	int	**tab3 = NULL;
	int	tab3_size;
	int	**tab4 = NULL;
	int	tab4_size;

	min = 3;
	max = 8;
	tab1_size = ft_ultimate_range(&tab1, min, max);
	printf("Pour min = %d et max = %d, tab1 =\n", min, max);
	printf("&tab1 = %p\n", &tab1);
	printf("tab1[0] = %d\n", tab1[0]);
	ptr = &tab1;
	printf("ptr = %p\n", ptr);
	ft_print_int_tab(ptr, tab1_size);
	//free(*tab1);
	free(*ptr);
	free(ptr);
	/*min = 42;
	max = 42;
	tab2_size = ft_ultimate_range(tab2, min, max);
	printf("\nPour min = %d et max = %d, tab2 =\n", min, max);
	ft_print_int_tab(*tab2, tab2_size);
	free(*tab2);
	free(tab2);
	min = -42;
	max = 43;
	tab3_size = ft_ultimate_range(tab3, min, max);
	printf("\nPour min = %d et max = %d, tab3 =\n", min, max);
	ft_print_int_tab(*tab3, tab3_size);
	free(*tab3);
	free(tab3);
	min = 42;
	max = -1;
	tab4_size = ft_ultimate_range(tab4, min, max);
	printf("\nPour min = %d et max = %d, tab4 =\n", min, max);
	ft_print_int_tab(*tab4, tab4_size);
	free(*tab4);
	free(tab4);*/
	return (0);
}
e3r11p9% gcc -Wextra -Werror -o test_ft_ultimate_range -g ft_ultimate_range.c test_ft_ultimate_range.c
e3r11p9% ./test_ft_ultimate_range                                                                   
Pour min = 3 et max = 8, tab1 =
&tab1 = 0x7fff507a9480
zsh: segmentation fault (core dumped)  ./test_ft_ultimate_range
e3r11p9% vi test_ft_ultimate_range.c                                                                 
e3r11p9% cat test_ft_ultimate_range.c                                                                 
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   test_ft_ultimate_range.c                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: hauerbac <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2023/02/22 17:56:00 by hauerbac          #+#    #+#             */
/*   Updated: 2023/02/23 20:30:15 by hauerbac         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>

int	ft_ultimate_range(int **range, int min, int max);

void	ft_putnbr(int nb)
{
	long	nb_in_long;
	int		digit_to_char;

	nb_in_long = nb;
	if (nb_in_long < 0)
	{
		write(1, "-", 1);
		nb_in_long = nb_in_long * -1;
	}
	if (nb_in_long < 10)
	{
		digit_to_char = nb_in_long + '0';
		write(1, &digit_to_char, 1);
	}
	else
	{
		ft_putnbr(nb_in_long / 10);
		ft_putnbr(nb_in_long % 10);
	}
}

void	ft_print_int_tab(int **tab, int size)
{
	int	i;
	int	val;

	printf("The returned size of range is %d.\n", size);
	printf("tab = %p\n", tab);
	printf("tab[0] = %p\n", tab[0]);
	printf("tab[0][0] = %d\n", tab[0][0]);
	if (tab != NULL && tab[0] != NULL && size > 0)
	{
		write(1, "[", 1);
		i = 0;
		val = 0;
		while (i < size)
		{
			val = tab[0][0];
			printf("%d", tab[0][0]);
			//ft_putnbr(tab[0][i]);
			if (i < size - 1)
				write(1, ", ", 2);
			i++;
		}
		write(1, "]", 1);
	}
	else if (size == 0)
		printf("\nNone array - Reason : If the value of min is greater or equal to maxâ€™s value, range will point on NULL and it should return 0.");
	else if (size == -1)
		printf("\nIncomplete array - Reason : The size of range should be returned (or -1 on error).");
}

int	main(void)
{
	int	min;
	int	max;
	int	**ptr;
	int	*tab1 = NULL;
	int	tab1_size;
	int	**tab2 = NULL;
	int	tab2_size;
	int	**tab3 = NULL;
	int	tab3_size;
	int	**tab4 = NULL;
	int	tab4_size;

	min = 3;
	max = 8;
	tab1_size = ft_ultimate_range(&tab1, min, max);
	printf("Pour min = %d et max = %d, tab1 =\n", min, max);
	printf("&tab1 = %p\n", &tab1);
	printf("tab1[0] = %d\n", tab1[0]);
	/*ptr = &tab1;
	printf("ptr = %p\n", ptr);
	ft_print_int_tab(ptr, tab1_size);*/
	//free(*tab1);
	/*free(*ptr);
	free(ptr);*/
	/*min = 42;
	max = 42;
	tab2_size = ft_ultimate_range(tab2, min, max);
	printf("\nPour min = %d et max = %d, tab2 =\n", min, max);
	ft_print_int_tab(*tab2, tab2_size);
	free(*tab2);
	free(tab2);
	min = -42;
	max = 43;
	tab3_size = ft_ultimate_range(tab3, min, max);
	printf("\nPour min = %d et max = %d, tab3 =\n", min, max);
	ft_print_int_tab(*tab3, tab3_size);
	free(*tab3);
	free(tab3);
	min = 42;
	max = -1;
	tab4_size = ft_ultimate_range(tab4, min, max);
	printf("\nPour min = %d et max = %d, tab4 =\n", min, max);
	ft_print_int_tab(*tab4, tab4_size);
	free(*tab4);
	free(tab4);*/
	return (0);
}
e3r11p9% gcc -Wextra -Werror -o test_ft_ultimate_range -g ft_ultimate_range.c test_ft_ultimate_range.c
e3r11p9% ./test_ft_ultimate_range                                                                   
Pour min = 3 et max = 8, tab1 =
&tab1 = 0x7fff45fd53c8
zsh: segmentation fault (core dumped)  ./test_ft_ultimate_range
---------------------------------------------------------------------------------------------------------------------------------
e3r11p9% cd
e3r11p9% cd c_07/ex00
e3r11p9% ls
ft_strdup.c  test_ft_strdup  test_ft_strdup.c
e3r11p9% cat test_ft_strdup.c
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   test_ft_strdup.c                                   :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: hauerbac <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2023/02/22 16:07:32 by hauerbac          #+#    #+#             */
/*   Updated: 2023/02/22 16:17:59 by hauerbac         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include <stdio.h>
#include <stdlib.h>

char	*ft_strdup(char *src);

int	main(void)
{
	char	*duplicated;

	duplicated = ft_strdup("Toto");
	printf("\"%s\" duplicated : \"%s\"\n", "Toto", duplicated);
	free(duplicated);
	duplicated = ft_strdup("");
	printf("\"%s\" duplicated : \"%s\"\n", "", duplicated);
	free(duplicated);
	duplicated = ft_strdup("1");
	printf("\"%s\" duplicated : \"%s\"\n", "1", duplicated);
	return (0);
}
e3r11p9% vi test_ft_strdup.c
e3r11p9% cat test_ft_strdup.c 
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   test_ft_strdup.c                                   :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: hauerbac <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2023/02/22 16:07:32 by hauerbac          #+#    #+#             */
/*   Updated: 2023/02/24 10:21:37 by hauerbac         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include <stdio.h>
#include <stdlib.h>

char	*ft_strdup(char *src);

int	main(void)
{
	char	*duplicated;

	duplicated = ft_strdup("Toto");
	printf("\"%s\" duplicated : \"%s\"\n", "Toto", duplicated);
	free(duplicated);
	duplicated = ft_strdup("");
	printf("\"%s\" duplicated : \"%s\"\n", "", duplicated);
	free(duplicated);
	duplicated = ft_strdup("1");
	printf("\"%s\" duplicated : \"%s\"\n", "1", duplicated);
	free(duplicated);
	return (0);
}
e3r11p9% cat ft_strdup.c 
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_strdup.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: hauerbac <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2023/02/22 14:07:10 by hauerbac          #+#    #+#             */
/*   Updated: 2023/02/22 16:11:29 by hauerbac         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include <stdlib.h>

int	ft_strlen(char *str)
{
	int	i;

	i = 0;
	while (str && str[i] != '\0')
		i++;
	return (i);
}

char	*ft_strncpy(char *dest, char *src, unsigned int n)
{
	unsigned int	i;

	if (src && dest && n > 0)
	{
		i = 0;
		while (i < n && src[i] != '\0')
		{
			dest[i] = src[i];
			i++;
		}
		while (i < n)
		{
			dest[i] = '\0';
			i++;
		}
	}
	return (dest);
}

char	*ft_strdup(char *src)
{
	int		src_len;
	char	*ptr;

	if (src)
	{
		src_len = ft_strlen(src);
		ptr = (char *) malloc(src_len * sizeof(char));
		if (ptr)
		{
			ft_strncpy(ptr, src, src_len + 1);
			return (ptr);
		}
	}
	return (NULL);
}
e3r11p9% gcc -Wall -Wextra -Werror -o test_ft_strdup -g3 ft_strdup.c test_ft_strdup.c 
e3r11p9% ls -al
total 68
drwxr-xr-x 2 hauerbac 2023_paris  4096 Feb 24 10:24 .
drwxr-xr-x 5 hauerbac 2023_paris  4096 Feb 22 19:16 ..
-rw-r--r-- 1 hauerbac 2023_paris  1512 Feb 22 16:11 ft_strdup.c
-rwxr-xr-x 1 hauerbac 2023_paris 52984 Feb 24 10:24 test_ft_strdup
-rw-r--r-- 1 hauerbac 2023_paris  1338 Feb 24 10:21 test_ft_strdup.c
e3r11p9% valgrind ./test_ft_strdup 
==243425== Memcheck, a memory error detector
==243425== Copyright (C) 2002-2017, and GNU GPL'd, by Julian Seward et al.
==243425== Using Valgrind-3.18.1 and LibVEX; rerun with -h for copyright info
==243425== Command: ./test_ft_strdup
==243425== 
==243425== Invalid write of size 1
==243425==    at 0x109234: ft_strncpy (ft_strdup.c:39)
==243425==    by 0x1092A1: ft_strdup (ft_strdup.c:57)
==243425==    by 0x1092C6: main (test_ft_strdup.c:22)
==243425==  Address 0x4a9f044 is 0 bytes after a block of size 4 alloc'd
==243425==    at 0x4848899: malloc (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
==243425==    by 0x10927B: ft_strdup (ft_strdup.c:54)
==243425==    by 0x1092C6: main (test_ft_strdup.c:22)
==243425== 
==243425== Invalid read of size 1
==243425==    at 0x484ED84: __strlen_sse2 (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
==243425==    by 0x48EADB0: __vfprintf_internal (vfprintf-internal.c:1517)
==243425==    by 0x48D481E: printf (printf.c:33)
==243425==    by 0x1092E9: main (test_ft_strdup.c:23)
==243425==  Address 0x4a9f044 is 0 bytes after a block of size 4 alloc'd
==243425==    at 0x4848899: malloc (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
==243425==    by 0x10927B: ft_strdup (ft_strdup.c:54)
==243425==    by 0x1092C6: main (test_ft_strdup.c:22)
==243425== 
"Toto" duplicated : "Toto"
==243425== Invalid write of size 1
==243425==    at 0x109234: ft_strncpy (ft_strdup.c:39)
==243425==    by 0x1092A1: ft_strdup (ft_strdup.c:57)
==243425==    by 0x109301: main (test_ft_strdup.c:25)
==243425==  Address 0x4a9f4d0 is 0 bytes after a block of size 0 alloc'd
==243425==    at 0x4848899: malloc (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
==243425==    by 0x10927B: ft_strdup (ft_strdup.c:54)
==243425==    by 0x109301: main (test_ft_strdup.c:25)
==243425== 
==243425== Invalid read of size 1
==243425==    at 0x484ED76: __strlen_sse2 (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
==243425==    by 0x48EADB0: __vfprintf_internal (vfprintf-internal.c:1517)
==243425==    by 0x48D481E: printf (printf.c:33)
==243425==    by 0x109324: main (test_ft_strdup.c:26)
==243425==  Address 0x4a9f4d0 is 0 bytes after a block of size 0 alloc'd
==243425==    at 0x4848899: malloc (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
==243425==    by 0x10927B: ft_strdup (ft_strdup.c:54)
==243425==    by 0x109301: main (test_ft_strdup.c:25)
==243425== 
"" duplicated : ""
==243425== Invalid write of size 1
==243425==    at 0x109234: ft_strncpy (ft_strdup.c:39)
==243425==    by 0x1092A1: ft_strdup (ft_strdup.c:57)
==243425==    by 0x10933C: main (test_ft_strdup.c:28)
==243425==  Address 0x4a9f511 is 0 bytes after a block of size 1 alloc'd
==243425==    at 0x4848899: malloc (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
==243425==    by 0x10927B: ft_strdup (ft_strdup.c:54)
==243425==    by 0x10933C: main (test_ft_strdup.c:28)
==243425== 
==243425== Invalid read of size 1
==243425==    at 0x484ED84: __strlen_sse2 (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
==243425==    by 0x48EADB0: __vfprintf_internal (vfprintf-internal.c:1517)
==243425==    by 0x48D481E: printf (printf.c:33)
==243425==    by 0x10935F: main (test_ft_strdup.c:29)
==243425==  Address 0x4a9f511 is 0 bytes after a block of size 1 alloc'd
==243425==    at 0x4848899: malloc (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
==243425==    by 0x10927B: ft_strdup (ft_strdup.c:54)
==243425==    by 0x10933C: main (test_ft_strdup.c:28)
==243425== 
"1" duplicated : "1"
==243425== 
==243425== HEAP SUMMARY:
==243425==     in use at exit: 0 bytes in 0 blocks
==243425==   total heap usage: 4 allocs, 4 frees, 1,029 bytes allocated
==243425== 
==243425== All heap blocks were freed -- no leaks are possible
==243425== 
==243425== For lists of detected and suppressed errors, rerun with: -s
==243425== ERROR SUMMARY: 6 errors from 6 contexts (suppressed: 0 from 0)
e3r11p9% vi ft_strdup.c                                                           
e3r11p9% cat ft_strdup.c 
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_strdup.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: hauerbac <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2023/02/22 14:07:10 by hauerbac          #+#    #+#             */
/*   Updated: 2023/02/24 10:27:09 by hauerbac         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include <stdlib.h>

int	ft_strlen(char *str)
{
	int	i;

	i = 0;
	while (str && str[i] != '\0')
		i++;
	return (i);
}

char	*ft_strncpy(char *dest, char *src, unsigned int n)
{
	unsigned int	i;

	if (src && dest && n > 0)
	{
		i = 0;
		while (i < n && src[i] != '\0')
		{
			dest[i] = src[i];
			i++;
		}
		while (i < n)
		{
			dest[i] = '\0';
			i++;
		}
	}
	return (dest);
}

char	*ft_strdup(char *src)
{
	int		src_len;
	char	*ptr;

	if (src)
	{
		src_len = ft_strlen(src);
		ptr = (char *) malloc((src_len + 1) * sizeof(char));
		if (ptr)
		{
			ft_strncpy(ptr, src, src_len + 1);
			return (ptr);
		}
	}
	return (NULL);
}
e3r11p9% gcc -Wall -Wextra -Werror -o test_ft_strdup -g3 ft_strdup.c test_ft_strdup.c
e3r11p9% ls -al                                                                      
total 68
drwxr-xr-x 2 hauerbac 2023_paris  4096 Feb 24 10:27 .
drwxr-xr-x 5 hauerbac 2023_paris  4096 Feb 22 19:16 ..
-rw-r--r-- 1 hauerbac 2023_paris  1518 Feb 24 10:27 ft_strdup.c
-rwxr-xr-x 1 hauerbac 2023_paris 52984 Feb 24 10:27 test_ft_strdup
-rw-r--r-- 1 hauerbac 2023_paris  1338 Feb 24 10:21 test_ft_strdup.c
e3r11p9% valgrind ./test_ft_strdup                                                  
==243855== Memcheck, a memory error detector
==243855== Copyright (C) 2002-2017, and GNU GPL'd, by Julian Seward et al.
==243855== Using Valgrind-3.18.1 and LibVEX; rerun with -h for copyright info
==243855== Command: ./test_ft_strdup
==243855== 
"Toto" duplicated : "Toto"
"" duplicated : ""
"1" duplicated : "1"
==243855== 
==243855== HEAP SUMMARY:
==243855==     in use at exit: 0 bytes in 0 blocks
==243855==   total heap usage: 4 allocs, 4 frees, 1,032 bytes allocated
==243855== 
==243855== All heap blocks were freed -- no leaks are possible
==243855== 
==243855== For lists of detected and suppressed errors, rerun with: -s
==243855== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
e3r11p9% cd ../ex01
e3r11p9% ls -al
total 32
drwxr-xr-x 2 hauerbac 2023_paris  4096 Feb 23 09:07 .
drwxr-xr-x 5 hauerbac 2023_paris  4096 Feb 22 19:16 ..
-rw-r--r-- 1 hauerbac 2023_paris  1235 Feb 23 09:05 ft_range.c
-rwxr-xr-x 1 hauerbac 2023_paris 16280 Feb 23 09:07 test_ft_range
-rw-r--r-- 1 hauerbac 2023_paris  2294 Feb 22 19:07 test_ft_range.c
e3r11p9% cat ft_range.c 
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_range.c                                         :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: hauerbac <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2023/02/22 17:26:36 by hauerbac          #+#    #+#             */
/*   Updated: 2023/02/23 09:05:04 by hauerbac         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include <stdlib.h>

int	*ft_range(int min, int max)
{
	int	range_len;
	int	*ptr;
	int	i;
	int	value;

	if (min < max)
	{
		range_len = max - min;
		ptr = (int *) malloc(range_len * sizeof(int));
		if (ptr)
		{
			value = min;
			i = 0;
			while (i < range_len && value < max)
				ptr[i++] = value++;
			return (ptr);
		}
	}
	return (NULL);
}
e3r11p9% cat test_ft_range.c
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   test_ft_range.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: hauerbac <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2023/02/22 17:56:00 by hauerbac          #+#    #+#             */
/*   Updated: 2023/02/22 19:07:10 by hauerbac         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>

int	*ft_range(int min, int max);

void	ft_putnbr(int nb)
{
	long	nb_in_long;
	int		digit_to_char;

	nb_in_long = nb;
	if (nb_in_long < 0)
	{
		write(1, "-", 1);
		nb_in_long = nb_in_long * -1;
	}
	if (nb_in_long < 10)
	{
		digit_to_char = nb_in_long + '0';
		write(1, &digit_to_char, 1);
	}
	else
	{
		ft_putnbr(nb_in_long / 10);
		ft_putnbr(nb_in_long % 10);
	}
}

void	ft_print_int_tab(int *tab, int size)
{
	int	i;

	if (tab != NULL && size > 0)
	{
		write(1, "[", 1);
		i = 0;
		while (i < size)
		{
			ft_putnbr(tab[i]);
			if (i < size - 1)
				write(1, ", ", 2);
			i++;
		}
		write(1, "]", 1);
	}
}

int	main(void)
{
	int	min;
	int	max;
	int	*tab1;
	int	*tab2;
	int	*tab3;
	int	*tab4;

	min = 3;
	max = 8;
	tab1 = ft_range(min, max);
	printf("Pour min = %d et max = %d, tab1 =\n", min, max);
	ft_print_int_tab(tab1, max - min);
	free(tab1);
	min = 42;
	max = 42;
	tab2 = ft_range(min, max);
	printf("\nPour min = %d et max = %d, tab2 =\n", min, max);
	ft_print_int_tab(tab2, max - min);
	free(tab2);
	min = -42;
	max = 43;
	tab3 = ft_range(min, max);
	printf("\nPour min = %d et max = %d, tab3 =\n", min, max);
	ft_print_int_tab(tab3, max - min);
	free(tab3);
	min = 42;
	max = -1;
	tab4 = ft_range(min, max);
	printf("\nPour min = %d et max = %d, tab4 =\n", min, max);
	ft_print_int_tab(tab4, max - min);
	free(tab4);
	return (0);
}
e3r11p9% gcc -Wall -Wextra -Werror -o test_ft_range -g3 ft_range.c test_ft_range.c   
e3r11p9% ls -al
total 88
drwxr-xr-x 2 hauerbac 2023_paris  4096 Feb 24 10:37 .
drwxr-xr-x 5 hauerbac 2023_paris  4096 Feb 22 19:16 ..
-rw-r--r-- 1 hauerbac 2023_paris  1235 Feb 23 09:05 ft_range.c
-rwxr-xr-x 1 hauerbac 2023_paris 71144 Feb 24 10:37 test_ft_range
-rw-r--r-- 1 hauerbac 2023_paris  2294 Feb 22 19:07 test_ft_range.c
e3r11p9% valgrind ./test_ft_range                                            
==245676== Memcheck, a memory error detector
==245676== Copyright (C) 2002-2017, and GNU GPL'd, by Julian Seward et al.
==245676== Using Valgrind-3.18.1 and LibVEX; rerun with -h for copyright info
==245676== Command: ./test_ft_range
==245676== 
Pour min = 3 et max = 8, tab1 =
[3, 4, 5, 6, 7]
Pour min = 42 et max = 42, tab2 =

Pour min = -42 et max = 43, tab3 =
[-42, -41, -40, -39, -38, -37, -36, -35, -34, -33, -32, -31, -30, -29, -28, -27, -26, -25, -24, -23, -22, -21, -20, -19, -18, -17, -16, -15, -14, -13, -12, -11, -10, -9, -8, -7, -6, -5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42]
Pour min = 42 et max = -1, tab4 =
==245676== 
==245676== HEAP SUMMARY:
==245676==     in use at exit: 0 bytes in 0 blocks
==245676==   total heap usage: 3 allocs, 3 frees, 1,384 bytes allocated
==245676== 
==245676== All heap blocks were freed -- no leaks are possible
==245676== 
==245676== For lists of detected and suppressed errors, rerun with: -s
==245676== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
e3r11p9% gcc -Wall -Wextra -Werror -fsanitize=address -o test_ft_range -g3 ft_range.c test_ft_range.c
e3r11p9% ls -al
total 92
drwxr-xr-x 2 hauerbac 2023_paris  4096 Feb 24 11:00 .
drwxr-xr-x 5 hauerbac 2023_paris  4096 Feb 22 19:16 ..
-rw-r--r-- 1 hauerbac 2023_paris  1235 Feb 23 09:05 ft_range.c
-rwxr-xr-x 1 hauerbac 2023_paris 76280 Feb 24 11:00 test_ft_range
-rw-r--r-- 1 hauerbac 2023_paris  2294 Feb 22 19:07 test_ft_range.c
e3r11p9% ./test_ft_range 
Pour min = 3 et max = 8, tab1 =
[3, 4, 5, 6, 7]
Pour min = 42 et max = 42, tab2 =

Pour min = -42 et max = 43, tab3 =
[-42, -41, -40, -39, -38, -37, -36, -35, -34, -33, -32, -31, -30, -29, -28, -27, -26, -25, -24, -23, -22, -21, -20, -19, -18, -17, -16, -15, -14, -13, -12, -11, -10, -9, -8, -7, -6, -5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42]
Pour min = 42 et max = -1, tab4 =
e3r11p9% valgrind ./test_ft_range                                                                    
==249728== Memcheck, a memory error detector
==249728== Copyright (C) 2002-2017, and GNU GPL'd, by Julian Seward et al.
==249728== Using Valgrind-3.18.1 and LibVEX; rerun with -h for copyright info
==249728== Command: ./test_ft_range
==249728== 
==249728==ASan runtime does not come first in initial library list; you should either link runtime to your application or manually preload it with LD_PRELOAD.
==249728== 
==249728== Process terminating with default action of signal 11 (SIGSEGV)
==249728==  General Protection Fault
==249728==    at 0x52F6F42: __pthread_once_slow (pthread_once.c:114)
==249728==    by 0x53C5A52: __rpc_thread_variables (rpc_thread.c:59)
==249728==    by 0x5418D8C: free_mem (in /usr/lib/x86_64-linux-gnu/libc.so.6)
==249728==    by 0x54188C1: __libc_freeres (in /usr/lib/x86_64-linux-gnu/libc.so.6)
==249728==    by 0x483F1B2: _vgnU_freeres (in /usr/libexec/valgrind/vgpreload_core-amd64-linux.so)
==249728==    by 0x4A5C3DF: ???
==249728==    by 0x49522B6: __sanitizer::Die() (sanitizer_termination.cpp:59)
==249728==    by 0x4928398: __asan::AsanCheckDynamicRTPrereqs() (asan_linux.cpp:181)
==249728==    by 0x4934544: __asan::AsanInitInternal() [clone .part.0] (asan_rtl.cpp:420)
==249728==    by 0x40065BD: _dl_init (dl-init.c:102)
==249728==    by 0x40202E9: ??? (in /usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2)
==249728== 
==249728== HEAP SUMMARY:
==249728==     in use at exit: 0 bytes in 0 blocks
==249728==   total heap usage: 0 allocs, 0 frees, 0 bytes allocated
==249728== 
==249728== All heap blocks were freed -- no leaks are possible
==249728== 
==249728== For lists of detected and suppressed errors, rerun with: -s
==249728== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
e3r11p9% cd ../ex02
e3r11p9% ls -al
total 40
drwxr-xr-x 2 hauerbac 2023_paris  4096 Feb 23 20:30 .
drwxr-xr-x 5 hauerbac 2023_paris  4096 Feb 22 19:16 ..
-rw-r--r-- 1 hauerbac 2023_paris  1930 Feb 23 09:57 ft_ultimate_range_0.c
-rw-r--r-- 1 hauerbac 2023_paris  1643 Feb 23 20:06 ft_ultimate_range.c
-rwxr-xr-x 1 hauerbac 2023_paris 18912 Feb 23 20:30 test_ft_ultimate_range
-rw-r--r-- 1 hauerbac 2023_paris  3231 Feb 23 20:30 test_ft_ultimate_range.c
e3r11p9% gcc -Wall -Wextra -Werror -fsanitize=address -o test_ft_ultimate_range -g3 ft_ultimate_range.c test_ft_ultimate_range.c 
test_ft_ultimate_range.c: In function â€˜ft_print_int_tabâ€™:
test_ft_ultimate_range.c:45:6: error: variable â€˜valâ€™ set but not used [-Werror=unused-but-set-variable]
   45 |  int val;
      |      ^~~
test_ft_ultimate_range.c: In function â€˜mainâ€™:
test_ft_ultimate_range.c:85:6: error: unused variable â€˜tab4_sizeâ€™ [-Werror=unused-variable]
   85 |  int tab4_size;
      |      ^~~~~~~~~
test_ft_ultimate_range.c:84:8: error: unused variable â€˜tab4â€™ [-Werror=unused-variable]
   84 |  int **tab4 = NULL;
      |        ^~~~
test_ft_ultimate_range.c:83:6: error: unused variable â€˜tab3_sizeâ€™ [-Werror=unused-variable]
   83 |  int tab3_size;
      |      ^~~~~~~~~
test_ft_ultimate_range.c:82:8: error: unused variable â€˜tab3â€™ [-Werror=unused-variable]
   82 |  int **tab3 = NULL;
      |        ^~~~
test_ft_ultimate_range.c:81:6: error: unused variable â€˜tab2_sizeâ€™ [-Werror=unused-variable]
   81 |  int tab2_size;
      |      ^~~~~~~~~
test_ft_ultimate_range.c:80:8: error: unused variable â€˜tab2â€™ [-Werror=unused-variable]
   80 |  int **tab2 = NULL;
      |        ^~~~
test_ft_ultimate_range.c:79:6: error: variable â€˜tab1_sizeâ€™ set but not used [-Werror=unused-but-set-variable]
   79 |  int tab1_size;
      |      ^~~~~~~~~
test_ft_ultimate_range.c:77:8: error: unused variable â€˜ptrâ€™ [-Werror=unused-variable]
   77 |  int **ptr;
      |        ^~~
cc1: all warnings being treated as errors
------------------------------------------------------------------------------------------------------------------------------------
e3r11p9% cat ../ex01/test_ft_range.c
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   test_ft_range.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: hauerbac <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2023/02/22 17:56:00 by hauerbac          #+#    #+#             */
/*   Updated: 2023/02/22 19:07:10 by hauerbac         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>

int	*ft_range(int min, int max);

void	ft_putnbr(int nb)
{
	long	nb_in_long;
	int		digit_to_char;

	nb_in_long = nb;
	if (nb_in_long < 0)
	{
		write(1, "-", 1);
		nb_in_long = nb_in_long * -1;
	}
	if (nb_in_long < 10)
	{
		digit_to_char = nb_in_long + '0';
		write(1, &digit_to_char, 1);
	}
	else
	{
		ft_putnbr(nb_in_long / 10);
		ft_putnbr(nb_in_long % 10);
	}
}

void	ft_print_int_tab(int *tab, int size)
{
	int	i;

	if (tab != NULL && size > 0)
	{
		write(1, "[", 1);
		i = 0;
		while (i < size)
		{
			ft_putnbr(tab[i]);
			if (i < size - 1)
				write(1, ", ", 2);
			i++;
		}
		write(1, "]", 1);
	}
}

int	main(void)
{
	int	min;
	int	max;
	int	*tab1;
	int	*tab2;
	int	*tab3;
	int	*tab4;

	min = 3;
	max = 8;
	tab1 = ft_range(min, max);
	printf("Pour min = %d et max = %d, tab1 =\n", min, max);
	ft_print_int_tab(tab1, max - min);
	free(tab1);
	min = 42;
	max = 42;
	tab2 = ft_range(min, max);
	printf("\nPour min = %d et max = %d, tab2 =\n", min, max);
	ft_print_int_tab(tab2, max - min);
	free(tab2);
	min = -42;
	max = 43;
	tab3 = ft_range(min, max);
	printf("\nPour min = %d et max = %d, tab3 =\n", min, max);
	ft_print_int_tab(tab3, max - min);
	free(tab3);
	min = 42;
	max = -1;
	tab4 = ft_range(min, max);
	printf("\nPour min = %d et max = %d, tab4 =\n", min, max);
	ft_print_int_tab(tab4, max - min);
	free(tab4);
	return (0);
}
e3r11p9% cat test_ft_ultimate_range.c
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   test_ft_ultimate_range.c                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: hauerbac <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2023/02/22 17:56:00 by hauerbac          #+#    #+#             */
/*   Updated: 2023/02/23 20:30:15 by hauerbac         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>

int	ft_ultimate_range(int **range, int min, int max);

void	ft_putnbr(int nb)
{
	long	nb_in_long;
	int		digit_to_char;

	nb_in_long = nb;
	if (nb_in_long < 0)
	{
		write(1, "-", 1);
		nb_in_long = nb_in_long * -1;
	}
	if (nb_in_long < 10)
	{
		digit_to_char = nb_in_long + '0';
		write(1, &digit_to_char, 1);
	}
	else
	{
		ft_putnbr(nb_in_long / 10);
		ft_putnbr(nb_in_long % 10);
	}
}

void	ft_print_int_tab(int **tab, int size)
{
	int	i;
	int	val;

	printf("The returned size of range is %d.\n", size);
	printf("tab = %p\n", tab);
	printf("tab[0] = %p\n", tab[0]);
	printf("tab[0][0] = %d\n", tab[0][0]);
	if (tab != NULL && tab[0] != NULL && size > 0)
	{
		write(1, "[", 1);
		i = 0;
		val = 0;
		while (i < size)
		{
			val = tab[0][0];
			printf("%d", tab[0][0]);
			//ft_putnbr(tab[0][i]);
			if (i < size - 1)
				write(1, ", ", 2);
			i++;
		}
		write(1, "]", 1);
	}
	else if (size == 0)
		printf("\nNone array - Reason : If the value of min is greater or equal to maxâ€™s value, range will point on NULL and it should return 0.");
	else if (size == -1)
		printf("\nIncomplete array - Reason : The size of range should be returned (or -1 on error).");
}

int	main(void)
{
	int	min;
	int	max;
	int	**ptr;
	int	*tab1 = NULL;
	int	tab1_size;
	int	**tab2 = NULL;
	int	tab2_size;
	int	**tab3 = NULL;
	int	tab3_size;
	int	**tab4 = NULL;
	int	tab4_size;

	min = 3;
	max = 8;
	tab1_size = ft_ultimate_range(&tab1, min, max);
	printf("Pour min = %d et max = %d, tab1 =\n", min, max);
	printf("&tab1 = %p\n", &tab1);
	printf("tab1[0] = %d\n", tab1[0]);
	/*ptr = &tab1;
	printf("ptr = %p\n", ptr);
	ft_print_int_tab(ptr, tab1_size);*/
	//free(*tab1);
	/*free(*ptr);
	free(ptr);*/
	/*min = 42;
	max = 42;
	tab2_size = ft_ultimate_range(tab2, min, max);
	printf("\nPour min = %d et max = %d, tab2 =\n", min, max);
	ft_print_int_tab(*tab2, tab2_size);
	free(*tab2);
	free(tab2);
	min = -42;
	max = 43;
	tab3_size = ft_ultimate_range(tab3, min, max);
	printf("\nPour min = %d et max = %d, tab3 =\n", min, max);
	ft_print_int_tab(*tab3, tab3_size);
	free(*tab3);
	free(tab3);
	min = 42;
	max = -1;
	tab4_size = ft_ultimate_range(tab4, min, max);
	printf("\nPour min = %d et max = %d, tab4 =\n", min, max);
	ft_print_int_tab(*tab4, tab4_size);
	free(*tab4);
	free(tab4);*/
	return (0);
}
e3r11p9% vi test_ft_ultimate_range.c 
e3r11p9% cat test_ft_ultimate_range.c
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   test_ft_ultimate_range.c                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: hauerbac <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2023/02/22 17:56:00 by hauerbac          #+#    #+#             */
/*   Updated: 2023/02/27 17:00:30 by hauerbac         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>

int	ft_ultimate_range(int **range, int min, int max);


void	ft_putnbr(int nb)
{
	long	nb_in_long;
	int		digit_to_char;

	nb_in_long = nb;
	if (nb_in_long < 0)
	{
		write(1, "-", 1);
		nb_in_long = nb_in_long * -1;
	}
	if (nb_in_long < 10)
	{
		digit_to_char = nb_in_long + '0';
		write(1, &digit_to_char, 1);
	}
	else
	{
		ft_putnbr(nb_in_long / 10);
		ft_putnbr(nb_in_long % 10);
	}
}

void	ft_print_int_tab(int *tab, int size)
{
	int	i;

	if (tab != NULL && size > 0)
	{
		write(1, "[", 1);
		i = 0;
		while (i < size)
		{
			ft_putnbr(tab[i]);
			if (i < size - 1)
				write(1, ", ", 2);
			i++;
		}
		write(1, "]", 1);
	}
}

void	ft_print_int_tab(int **tab, int size)
{
	int	i;
	int	val;

	printf("The returned size of range is %d.\n", size);
	printf("tab = %p\n", tab);
	printf("tab[0] = %p\n", tab[0]);
	printf("tab[0][0] = %d\n", tab[0][0]);
	if (tab != NULL && *tab != NULL && size > 0)
	{
		ft_print_int_tab(*tab, size);
	}
	else if (size == 0)
		printf("\nNone array - Reason : If the value of min is greater or equal to maxâ€™s value, range will point on NULL and it should return 0.");
	else if (size == -1)
		printf("\nIncomplete array - Reason : The size of range should be returned (or -1 on error).");
}

int	main(void)
{
	int	min;
	int	max;
	int	**ptr;
	int	*tab1 = NULL;
	int	tab1_size;
	int	**tab2 = NULL;
	int	tab2_size;
	int	**tab3 = NULL;
	int	tab3_size;
	int	**tab4 = NULL;
	int	tab4_size;

	min = 3;
	max = 8;
	tab1_size = ft_ultimate_range(&tab1, min, max);
	printf("Pour min = %d et max = %d, tab1 =\n", min, max);
	printf("&tab1 = %p\n", &tab1);
	printf("tab1[0] = %d\n", tab1[0]);
	/*ptr = &tab1;
	printf("ptr = %p\n", ptr);
	ft_print_int_tab(ptr, tab1_size);*/
	//free(*tab1);
	/*free(*ptr);
	free(ptr);*/
	/*min = 42;
	max = 42;
	tab2_size = ft_ultimate_range(tab2, min, max);
	printf("\nPour min = %d et max = %d, tab2 =\n", min, max);
	ft_print_int_tab(*tab2, tab2_size);
	free(*tab2);
	free(tab2);
	min = -42;
	max = 43;
	tab3_size = ft_ultimate_range(tab3, min, max);
	printf("\nPour min = %d et max = %d, tab3 =\n", min, max);
	ft_print_int_tab(*tab3, tab3_size);
	free(*tab3);
	free(tab3);
	min = 42;
	max = -1;
	tab4_size = ft_ultimate_range(tab4, min, max);
	printf("\nPour min = %d et max = %d, tab4 =\n", min, max);
	ft_print_int_tab(*tab4, tab4_size);
	free(*tab4);
	free(tab4);*/
	return (0);
}
e3r11p9% ls -al
total 40
drwxr-xr-x 2 hauerbac 2023_paris  4096 Feb 27 17:00 .
drwxr-xr-x 5 hauerbac 2023_paris  4096 Feb 22 19:16 ..
-rw-r--r-- 1 hauerbac 2023_paris  1930 Feb 23 09:57 ft_ultimate_range_0.c
-rw-r--r-- 1 hauerbac 2023_paris  1643 Feb 23 20:06 ft_ultimate_range.c
-rwxr-xr-x 1 hauerbac 2023_paris 18912 Feb 23 20:30 test_ft_ultimate_range
-rw-r--r-- 1 hauerbac 2023_paris  3290 Feb 27 17:00 test_ft_ultimate_range.c
e3r11p9% gcc -Wall -Wextra -Werror -o test_ft_ultimate_range ft_ultimate_range.c test_ft_ultimate_range.c 
test_ft_ultimate_range.c:62:6: error: conflicting types for â€˜ft_print_int_tabâ€™
   62 | void ft_print_int_tab(int **tab, int size)
      |      ^~~~~~~~~~~~~~~~
test_ft_ultimate_range.c:43:6: note: previous definition of â€˜ft_print_int_tabâ€™ was here
   43 | void ft_print_int_tab(int *tab, int size)
      |      ^~~~~~~~~~~~~~~~
test_ft_ultimate_range.c: In function â€˜ft_print_int_tabâ€™:
test_ft_ultimate_range.c:73:20: error: passing argument 1 of â€˜ft_print_int_tabâ€™ from incompatible pointer type [-Werror=incompatible-pointer-types]
   73 |   ft_print_int_tab(*tab, size);
      |                    ^~~~
      |                    |
      |                    int *
test_ft_ultimate_range.c:62:29: note: expected â€˜int **â€™ but argument is of type â€˜int *â€™
   62 | void ft_print_int_tab(int **tab, int size)
      |                       ~~~~~~^~~
test_ft_ultimate_range.c:65:6: error: unused variable â€˜valâ€™ [-Werror=unused-variable]
   65 |  int val;
      |      ^~~
test_ft_ultimate_range.c:64:6: error: unused variable â€˜iâ€™ [-Werror=unused-variable]
   64 |  int i;
      |      ^
test_ft_ultimate_range.c: In function â€˜mainâ€™:
test_ft_ultimate_range.c:93:6: error: unused variable â€˜tab4_sizeâ€™ [-Werror=unused-variable]
   93 |  int tab4_size;
      |      ^~~~~~~~~
test_ft_ultimate_range.c:92:8: error: unused variable â€˜tab4â€™ [-Werror=unused-variable]
   92 |  int **tab4 = NULL;
      |        ^~~~
test_ft_ultimate_range.c:91:6: error: unused variable â€˜tab3_sizeâ€™ [-Werror=unused-variable]
   91 |  int tab3_size;
      |      ^~~~~~~~~
test_ft_ultimate_range.c:90:8: error: unused variable â€˜tab3â€™ [-Werror=unused-variable]
   90 |  int **tab3 = NULL;
      |        ^~~~
test_ft_ultimate_range.c:89:6: error: unused variable â€˜tab2_sizeâ€™ [-Werror=unused-variable]
   89 |  int tab2_size;
      |      ^~~~~~~~~
test_ft_ultimate_range.c:88:8: error: unused variable â€˜tab2â€™ [-Werror=unused-variable]
   88 |  int **tab2 = NULL;
      |        ^~~~
test_ft_ultimate_range.c:87:6: error: variable â€˜tab1_sizeâ€™ set but not used [-Werror=unused-but-set-variable]
   87 |  int tab1_size;
      |      ^~~~~~~~~
test_ft_ultimate_range.c:85:8: error: unused variable â€˜ptrâ€™ [-Werror=unused-variable]
   85 |  int **ptr;
      |        ^~~
cc1: all warnings being treated as errors
e3r11p9% vi test_ft_ultimate_range.c                                                                    
e3r11p9% cat test_ft_ultimate_range.c                                                                   
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   test_ft_ultimate_range.c                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: hauerbac <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2023/02/22 17:56:00 by hauerbac          #+#    #+#             */
/*   Updated: 2023/02/27 17:02:52 by hauerbac         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>

int	ft_ultimate_range(int **range, int min, int max);


void	ft_putnbr(int nb)
{
	long	nb_in_long;
	int		digit_to_char;

	nb_in_long = nb;
	if (nb_in_long < 0)
	{
		write(1, "-", 1);
		nb_in_long = nb_in_long * -1;
	}
	if (nb_in_long < 10)
	{
		digit_to_char = nb_in_long + '0';
		write(1, &digit_to_char, 1);
	}
	else
	{
		ft_putnbr(nb_in_long / 10);
		ft_putnbr(nb_in_long % 10);
	}
}

void	ft_print_int_tab(int *tab, int size)
{
	int	i;

	if (tab != NULL && size > 0)
	{
		write(1, "[", 1);
		i = 0;
		while (i < size)
		{
			ft_putnbr(tab[i]);
			if (i < size - 1)
				write(1, ", ", 2);
			i++;
		}
		write(1, "]", 1);
	}
}

void	ft_print_ptr_int_tab(int **tab, int size)
{
	int	i;
	int	val;

	printf("The returned size of range is %d.\n", size);
	printf("tab = %p\n", tab);
	printf("tab[0] = %p\n", tab[0]);
	printf("tab[0][0] = %d\n", tab[0][0]);
	if (tab != NULL && *tab != NULL && size > 0)
	{
		ft_print_int_tab(*tab, size);
	}
	else if (size == 0)
		printf("\nNone array - Reason : If the value of min is greater or equal to maxâ€™s value, range will point on NULL and it should return 0.");
	else if (size == -1)
		printf("\nIncomplete array - Reason : The size of range should be returned (or -1 on error).");
}

int	main(void)
{
	int	min;
	int	max;
	int	**ptr;
	int	*tab1 = NULL;
	int	tab1_size;
	int	**tab2 = NULL;
	int	tab2_size;
	int	**tab3 = NULL;
	int	tab3_size;
	int	**tab4 = NULL;
	int	tab4_size;

	min = 3;
	max = 8;
	tab1_size = ft_ultimate_range(&tab1, min, max);
	printf("Pour min = %d et max = %d, tab1 =\n", min, max);
	printf("&tab1 = %p\n", &tab1);
	ft_print_ptr_int_tab(*tab2, tab2_size);
	/*ptr = &tab1;
	printf("ptr = %p\n", ptr);
	ft_print_int_tab(ptr, tab1_size);*/
	//free(*tab1);
	/*free(*ptr);
	free(ptr);*/
	/*min = 42;
	max = 42;
	tab2_size = ft_ultimate_range(tab2, min, max);
	printf("\nPour min = %d et max = %d, tab2 =\n", min, max);
	ft_print_int_tab(*tab2, tab2_size);
	free(*tab2);
	free(tab2);
	min = -42;
	max = 43;
	tab3_size = ft_ultimate_range(tab3, min, max);
	printf("\nPour min = %d et max = %d, tab3 =\n", min, max);
	ft_print_int_tab(*tab3, tab3_size);
	free(*tab3);
	free(tab3);
	min = 42;
	max = -1;
	tab4_size = ft_ultimate_range(tab4, min, max);
	printf("\nPour min = %d et max = %d, tab4 =\n", min, max);
	ft_print_int_tab(*tab4, tab4_size);
	free(*tab4);
	free(tab4);*/
	return (0);
}
e3r11p9% ls -al                                                                                          
total 40
drwxr-xr-x 2 hauerbac 2023_paris  4096 Feb 27 17:02 .
drwxr-xr-x 5 hauerbac 2023_paris  4096 Feb 22 19:16 ..
-rw-r--r-- 1 hauerbac 2023_paris  1930 Feb 23 09:57 ft_ultimate_range_0.c
-rw-r--r-- 1 hauerbac 2023_paris  1643 Feb 23 20:06 ft_ultimate_range.c
-rwxr-xr-x 1 hauerbac 2023_paris 18912 Feb 23 20:30 test_ft_ultimate_range
-rw-r--r-- 1 hauerbac 2023_paris  3299 Feb 27 17:02 test_ft_ultimate_range.c
e3r11p9% gcc -Wall -Wextra -Werror -o test_ft_ultimate_range ft_ultimate_range.c test_ft_ultimate_range.c
test_ft_ultimate_range.c: In function â€˜ft_print_ptr_int_tabâ€™:
test_ft_ultimate_range.c:65:6: error: unused variable â€˜valâ€™ [-Werror=unused-variable]
   65 |  int val;
      |      ^~~
test_ft_ultimate_range.c:64:6: error: unused variable â€˜iâ€™ [-Werror=unused-variable]
   64 |  int i;
      |      ^
test_ft_ultimate_range.c: In function â€˜mainâ€™:
test_ft_ultimate_range.c:100:23: error: passing argument 1 of â€˜ft_print_ptr_int_tabâ€™ from incompatible pointer type [-Werror=incompatible-pointer-types]
  100 |  ft_print_ptr_int_tab(*tab2, tab2_size);
      |                       ^~~~~
      |                       |
      |                       int *
test_ft_ultimate_range.c:62:33: note: expected â€˜int **â€™ but argument is of type â€˜int *â€™
   62 | void ft_print_ptr_int_tab(int **tab, int size)
      |                           ~~~~~~^~~
test_ft_ultimate_range.c:93:6: error: unused variable â€˜tab4_sizeâ€™ [-Werror=unused-variable]
   93 |  int tab4_size;
      |      ^~~~~~~~~
test_ft_ultimate_range.c:92:8: error: unused variable â€˜tab4â€™ [-Werror=unused-variable]
   92 |  int **tab4 = NULL;
      |        ^~~~
test_ft_ultimate_range.c:91:6: error: unused variable â€˜tab3_sizeâ€™ [-Werror=unused-variable]
   91 |  int tab3_size;
      |      ^~~~~~~~~
test_ft_ultimate_range.c:90:8: error: unused variable â€˜tab3â€™ [-Werror=unused-variable]
   90 |  int **tab3 = NULL;
      |        ^~~~
test_ft_ultimate_range.c:87:6: error: variable â€˜tab1_sizeâ€™ set but not used [-Werror=unused-but-set-variable]
   87 |  int tab1_size;
      |      ^~~~~~~~~
test_ft_ultimate_range.c:85:8: error: unused variable â€˜ptrâ€™ [-Werror=unused-variable]
   85 |  int **ptr;
      |        ^~~
test_ft_ultimate_range.c:100:2: error: â€˜tab2_sizeâ€™ is used uninitialized in this function [-Werror=uninitialized]
  100 |  ft_print_ptr_int_tab(*tab2, tab2_size);
      |  ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
cc1: all warnings being treated as errors
e3r11p9% vi test_ft_ultimate_range.c                                                                    
e3r11p9% cat test_ft_ultimate_range.c                                                                    
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   test_ft_ultimate_range.c                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: hauerbac <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2023/02/22 17:56:00 by hauerbac          #+#    #+#             */
/*   Updated: 2023/02/27 17:07:57 by hauerbac         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>

int	ft_ultimate_range(int **range, int min, int max);


void	ft_putnbr(int nb)
{
	long	nb_in_long;
	int		digit_to_char;

	nb_in_long = nb;
	if (nb_in_long < 0)
	{
		write(1, "-", 1);
		nb_in_long = nb_in_long * -1;
	}
	if (nb_in_long < 10)
	{
		digit_to_char = nb_in_long + '0';
		write(1, &digit_to_char, 1);
	}
	else
	{
		ft_putnbr(nb_in_long / 10);
		ft_putnbr(nb_in_long % 10);
	}
}

void	ft_print_int_tab(int *tab, int size)
{
	int	i;

	if (tab != NULL && size > 0)
	{
		write(1, "[", 1);
		i = 0;
		while (i < size)
		{
			ft_putnbr(tab[i]);
			if (i < size - 1)
				write(1, ", ", 2);
			i++;
		}
		write(1, "]", 1);
	}
}

void	ft_print_ptr_int_tab(int **tab, int size)
{
	printf("The returned size of range is %d.\n", size);
	printf("tab = %p\n", tab);
	printf("tab[0] = %p\n", tab[0]);
	printf("tab[0][0] = %d\n", tab[0][0]);
	if (tab != NULL && *tab != NULL && size > 0)
	{
		ft_print_int_tab(*tab, size);
	}
	else if (size == 0)
		printf("\nNone array - Reason : If the value of min is greater or equal to maxâ€™s value, range will point on NULL and it should return 0.");
	else if (size == -1)
		printf("\nIncomplete array - Reason : The size of range should be returned (or -1 on error).");
}

int	main(void)
{
	int	min;
	int	max;
	//int	**ptr;
	int	*tab1 = NULL;
	int	tab1_size;
	/*int	*tab2 = NULL;
	int	tab2_size;
	int	*tab3 = NULL;
	int	tab3_size;
	int	*tab4 = NULL;
	int	tab4_size;*/

	min = 3;
	max = 8;
	tab1_size = ft_ultimate_range(&tab1, min, max);
	printf("Pour min = %d et max = %d, tab1 =\n", min, max);
	printf("&tab1 = %p\n", &tab1);
	ft_print_ptr_int_tab(*tab2, tab2_size);
	/*ptr = &tab1;
	printf("ptr = %p\n", ptr);
	ft_print_int_tab(ptr, tab1_size);*/
	//free(*tab1);
	/*free(*ptr);
	free(ptr);*/
	/*min = 42;
	max = 42;
	tab2_size = ft_ultimate_range(tab2, min, max);
	printf("\nPour min = %d et max = %d, tab2 =\n", min, max);
	ft_print_int_tab(*tab2, tab2_size);
	free(*tab2);
	free(tab2);
	min = -42;
	max = 43;
	tab3_size = ft_ultimate_range(tab3, min, max);
	printf("\nPour min = %d et max = %d, tab3 =\n", min, max);
	ft_print_int_tab(*tab3, tab3_size);
	free(*tab3);
	free(tab3);
	min = 42;
	max = -1;
	tab4_size = ft_ultimate_range(tab4, min, max);
	printf("\nPour min = %d et max = %d, tab4 =\n", min, max);
	ft_print_int_tab(*tab4, tab4_size);
	free(*tab4);
	free(tab4);*/
	return (0);
}
e3r11p9% gcc -Wall -Wextra -Werror -o test_ft_ultimate_range ft_ultimate_range.c test_ft_ultimate_range.c
test_ft_ultimate_range.c: In function â€˜mainâ€™:
test_ft_ultimate_range.c:97:24: error: â€˜tab2â€™ undeclared (first use in this function); did you mean â€˜tab1â€™?
   97 |  ft_print_ptr_int_tab(*tab2, tab2_size);
      |                        ^~~~
      |                        tab1
test_ft_ultimate_range.c:97:24: note: each undeclared identifier is reported only once for each function it appears in
test_ft_ultimate_range.c:97:30: error: â€˜tab2_sizeâ€™ undeclared (first use in this function); did you mean â€˜tab1_sizeâ€™?
   97 |  ft_print_ptr_int_tab(*tab2, tab2_size);
      |                              ^~~~~~~~~
      |                              tab1_size
test_ft_ultimate_range.c:84:6: error: variable â€˜tab1_sizeâ€™ set but not used [-Werror=unused-but-set-variable]
   84 |  int tab1_size;
      |      ^~~~~~~~~
cc1: all warnings being treated as errors
e3r11p9% vi test_ft_ultimate_range.c                                                                    
e3r11p9% cat test_ft_ultimate_range.c                                                                    
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   test_ft_ultimate_range.c                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: hauerbac <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2023/02/22 17:56:00 by hauerbac          #+#    #+#             */
/*   Updated: 2023/02/27 17:08:42 by hauerbac         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>

int	ft_ultimate_range(int **range, int min, int max);


void	ft_putnbr(int nb)
{
	long	nb_in_long;
	int		digit_to_char;

	nb_in_long = nb;
	if (nb_in_long < 0)
	{
		write(1, "-", 1);
		nb_in_long = nb_in_long * -1;
	}
	if (nb_in_long < 10)
	{
		digit_to_char = nb_in_long + '0';
		write(1, &digit_to_char, 1);
	}
	else
	{
		ft_putnbr(nb_in_long / 10);
		ft_putnbr(nb_in_long % 10);
	}
}

void	ft_print_int_tab(int *tab, int size)
{
	int	i;

	if (tab != NULL && size > 0)
	{
		write(1, "[", 1);
		i = 0;
		while (i < size)
		{
			ft_putnbr(tab[i]);
			if (i < size - 1)
				write(1, ", ", 2);
			i++;
		}
		write(1, "]", 1);
	}
}

void	ft_print_ptr_int_tab(int **tab, int size)
{
	printf("The returned size of range is %d.\n", size);
	printf("tab = %p\n", tab);
	printf("tab[0] = %p\n", tab[0]);
	printf("tab[0][0] = %d\n", tab[0][0]);
	if (tab != NULL && *tab != NULL && size > 0)
	{
		ft_print_int_tab(*tab, size);
	}
	else if (size == 0)
		printf("\nNone array - Reason : If the value of min is greater or equal to maxâ€™s value, range will point on NULL and it should return 0.");
	else if (size == -1)
		printf("\nIncomplete array - Reason : The size of range should be returned (or -1 on error).");
}

int	main(void)
{
	int	min;
	int	max;
	//int	**ptr;
	int	*tab1 = NULL;
	int	tab1_size;
	/*int	*tab2 = NULL;
	int	tab2_size;
	int	*tab3 = NULL;
	int	tab3_size;
	int	*tab4 = NULL;
	int	tab4_size;*/

	min = 3;
	max = 8;
	tab1_size = ft_ultimate_range(&tab1, min, max);
	printf("Pour min = %d et max = %d, tab1 =\n", min, max);
	printf("&tab1 = %p\n", &tab1);
	ft_print_ptr_int_tab(*tab1, tab1_size);
	/*ptr = &tab1;
	printf("ptr = %p\n", ptr);
	ft_print_int_tab(ptr, tab1_size);*/
	//free(*tab1);
	/*free(*ptr);
	free(ptr);*/
	/*min = 42;
	max = 42;
	tab2_size = ft_ultimate_range(tab2, min, max);
	printf("\nPour min = %d et max = %d, tab2 =\n", min, max);
	ft_print_int_tab(*tab2, tab2_size);
	free(*tab2);
	free(tab2);
	min = -42;
	max = 43;
	tab3_size = ft_ultimate_range(tab3, min, max);
	printf("\nPour min = %d et max = %d, tab3 =\n", min, max);
	ft_print_int_tab(*tab3, tab3_size);
	free(*tab3);
	free(tab3);
	min = 42;
	max = -1;
	tab4_size = ft_ultimate_range(tab4, min, max);
	printf("\nPour min = %d et max = %d, tab4 =\n", min, max);
	ft_print_int_tab(*tab4, tab4_size);
	free(*tab4);
	free(tab4);*/
	return (0);
}
e3r11p9% gcc -Wall -Wextra -Werror -o test_ft_ultimate_range ft_ultimate_range.c test_ft_ultimate_range.c
test_ft_ultimate_range.c: In function â€˜mainâ€™:
test_ft_ultimate_range.c:97:23: error: passing argument 1 of â€˜ft_print_ptr_int_tabâ€™ makes pointer from integer without a cast [-Werror=int-conversion]
   97 |  ft_print_ptr_int_tab(*tab1, tab1_size);
      |                       ^~~~~
      |                       |
      |                       int
test_ft_ultimate_range.c:62:33: note: expected â€˜int **â€™ but argument is of type â€˜intâ€™
   62 | void ft_print_ptr_int_tab(int **tab, int size)
      |                           ~~~~~~^~~
cc1: all warnings being treated as errors
e3r11p9% vi test_ft_ultimate_range.c                                                                    
e3r11p9% vi test_ft_ultimate_range.c                                                                    
e3r11p9% cat test_ft_ultimate_range.c                                                                    
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   test_ft_ultimate_range.c                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: hauerbac <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2023/02/22 17:56:00 by hauerbac          #+#    #+#             */
/*   Updated: 2023/02/27 17:10:03 by hauerbac         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>

int	ft_ultimate_range(int **range, int min, int max);


void	ft_putnbr(int nb)
{
	long	nb_in_long;
	int		digit_to_char;

	nb_in_long = nb;
	if (nb_in_long < 0)
	{
		write(1, "-", 1);
		nb_in_long = nb_in_long * -1;
	}
	if (nb_in_long < 10)
	{
		digit_to_char = nb_in_long + '0';
		write(1, &digit_to_char, 1);
	}
	else
	{
		ft_putnbr(nb_in_long / 10);
		ft_putnbr(nb_in_long % 10);
	}
}

void	ft_print_int_tab(int *tab, int size)
{
	int	i;

	if (tab != NULL && size > 0)
	{
		write(1, "[", 1);
		i = 0;
		while (i < size)
		{
			ft_putnbr(tab[i]);
			if (i < size - 1)
				write(1, ", ", 2);
			i++;
		}
		write(1, "]", 1);
	}
}

void	ft_print_ptr_int_tab(int **tab, int size)
{
	printf("The returned size of range is %d.\n", size);
	printf("tab = %p\n", tab);
	printf("tab[0] = %p\n", tab[0]);
	printf("tab[0][0] = %d\n", tab[0][0]);
	if (tab != NULL && *tab != NULL && size > 0)
	{
		ft_print_int_tab(*tab, size);
	}
	else if (size == 0)
		printf("\nNone array - Reason : If the value of min is greater or equal to maxâ€™s value, range will point on NULL and it should return 0.");
	else if (size == -1)
		printf("\nIncomplete array - Reason : The size of range should be returned (or -1 on error).");
}

int	main(void)
{
	int	min;
	int	max;
	//int	**ptr;
	int	*tab1 = NULL;
	int	tab1_size;
	/*int	*tab2 = NULL;
	int	tab2_size;
	int	*tab3 = NULL;
	int	tab3_size;
	int	*tab4 = NULL;
	int	tab4_size;*/

	min = 3;
	max = 8;
	tab1_size = ft_ultimate_range(&tab1, min, max);
	printf("Pour min = %d et max = %d, tab1 =\n", min, max);
	printf("&tab1 = %p\n", &tab1);
	ft_print_ptr_int_tab(&tab1, tab1_size);
	/*ptr = &tab1;
	printf("ptr = %p\n", ptr);
	ft_print_int_tab(ptr, tab1_size);*/
	//free(*tab1);
	/*free(*ptr);
	free(ptr);*/
	/*min = 42;
	max = 42;
	tab2_size = ft_ultimate_range(tab2, min, max);
	printf("\nPour min = %d et max = %d, tab2 =\n", min, max);
	ft_print_int_tab(*tab2, tab2_size);
	free(*tab2);
	free(tab2);
	min = -42;
	max = 43;
	tab3_size = ft_ultimate_range(tab3, min, max);
	printf("\nPour min = %d et max = %d, tab3 =\n", min, max);
	ft_print_int_tab(*tab3, tab3_size);
	free(*tab3);
	free(tab3);
	min = 42;
	max = -1;
	tab4_size = ft_ultimate_range(tab4, min, max);
	printf("\nPour min = %d et max = %d, tab4 =\n", min, max);
	ft_print_int_tab(*tab4, tab4_size);
	free(*tab4);
	free(tab4);*/
	return (0);
}
e3r11p9% gcc -Wall -Wextra -Werror -o test_ft_ultimate_range ft_ultimate_range.c test_ft_ultimate_range.c
e3r11p9% ./test_ft_ultimate_range 
Pour min = 3 et max = 8, tab1 =
&tab1 = 0x7ffff5542bc0
The returned size of range is 5.
tab = 0x7ffff5542bc0
tab[0] = (nil)
zsh: segmentation fault (core dumped)  ./test_ft_ultimate_range
e3r11p9% vi test_ft_ultimate_range.c                                                                    
e3r11p9% cat test_ft_ultimate_range.c                                                                    
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   test_ft_ultimate_range.c                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: hauerbac <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2023/02/22 17:56:00 by hauerbac          #+#    #+#             */
/*   Updated: 2023/02/27 17:11:09 by hauerbac         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>

int	ft_ultimate_range(int **range, int min, int max);


void	ft_putnbr(int nb)
{
	long	nb_in_long;
	int		digit_to_char;

	nb_in_long = nb;
	if (nb_in_long < 0)
	{
		write(1, "-", 1);
		nb_in_long = nb_in_long * -1;
	}
	if (nb_in_long < 10)
	{
		digit_to_char = nb_in_long + '0';
		write(1, &digit_to_char, 1);
	}
	else
	{
		ft_putnbr(nb_in_long / 10);
		ft_putnbr(nb_in_long % 10);
	}
}

void	ft_print_int_tab(int *tab, int size)
{
	int	i;

	if (tab != NULL && size > 0)
	{
		write(1, "[", 1);
		i = 0;
		while (i < size)
		{
			ft_putnbr(tab[i]);
			if (i < size - 1)
				write(1, ", ", 2);
			i++;
		}
		write(1, "]", 1);
	}
}

void	ft_print_ptr_int_tab(int **tab, int size)
{
	printf("The returned size of range is %d.\n", size);
	printf("tab = %p\n", tab);
	if (tab != NULL && *tab != NULL && size > 0)
	{
		ft_print_int_tab(*tab, size);
	}
	else if (size == 0)
		printf("\nNone array - Reason : If the value of min is greater or equal to maxâ€™s value, range will point on NULL and it should return 0.");
	else if (size == -1)
		printf("\nIncomplete array - Reason : The size of range should be returned (or -1 on error).");
}

int	main(void)
{
	int	min;
	int	max;
	//int	**ptr;
	int	*tab1 = NULL;
	int	tab1_size;
	/*int	*tab2 = NULL;
	int	tab2_size;
	int	*tab3 = NULL;
	int	tab3_size;
	int	*tab4 = NULL;
	int	tab4_size;*/

	min = 3;
	max = 8;
	tab1_size = ft_ultimate_range(&tab1, min, max);
	printf("Pour min = %d et max = %d, tab1 =\n", min, max);
	printf("&tab1 = %p\n", &tab1);
	ft_print_ptr_int_tab(&tab1, tab1_size);
	/*ptr = &tab1;
	printf("ptr = %p\n", ptr);
	ft_print_int_tab(ptr, tab1_size);*/
	//free(*tab1);
	/*free(*ptr);
	free(ptr);*/
	/*min = 42;
	max = 42;
	tab2_size = ft_ultimate_range(tab2, min, max);
	printf("\nPour min = %d et max = %d, tab2 =\n", min, max);
	ft_print_int_tab(*tab2, tab2_size);
	free(*tab2);
	free(tab2);
	min = -42;
	max = 43;
	tab3_size = ft_ultimate_range(tab3, min, max);
	printf("\nPour min = %d et max = %d, tab3 =\n", min, max);
	ft_print_int_tab(*tab3, tab3_size);
	free(*tab3);
	free(tab3);
	min = 42;
	max = -1;
	tab4_size = ft_ultimate_range(tab4, min, max);
	printf("\nPour min = %d et max = %d, tab4 =\n", min, max);
	ft_print_int_tab(*tab4, tab4_size);
	free(*tab4);
	free(tab4);*/
	return (0);
}
e3r11p9% gcc -Wall -Wextra -Werror -o test_ft_ultimate_range ft_ultimate_range.c test_ft_ultimate_range.c
e3r11p9% ./test_ft_ultimate_range                                                                      
Pour min = 3 et max = 8, tab1 =
&tab1 = 0x7fffcc885ab0
The returned size of range is 5.
tab = 0x7fffcc885ab0
e3r11p9% vi test_ft_ultimate_range.c                                                                    
e3r11p9% cat test_ft_ultimate_range.c                                                                    
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   test_ft_ultimate_range.c                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: hauerbac <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2023/02/22 17:56:00 by hauerbac          #+#    #+#             */
/*   Updated: 2023/02/27 17:12:12 by hauerbac         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>

int	ft_ultimate_range(int **range, int min, int max);


void	ft_putnbr(int nb)
{
	long	nb_in_long;
	int		digit_to_char;

	nb_in_long = nb;
	if (nb_in_long < 0)
	{
		write(1, "-", 1);
		nb_in_long = nb_in_long * -1;
	}
	if (nb_in_long < 10)
	{
		digit_to_char = nb_in_long + '0';
		write(1, &digit_to_char, 1);
	}
	else
	{
		ft_putnbr(nb_in_long / 10);
		ft_putnbr(nb_in_long % 10);
	}
}

void	ft_print_int_tab(int *tab, int size)
{
	int	i;

	if (tab != NULL && size > 0)
	{
		write(1, "[", 1);
		i = 0;
		while (i < size)
		{
			ft_putnbr(tab[i]);
			if (i < size - 1)
				write(1, ", ", 2);
			i++;
		}
		write(1, "]", 1);
	}
}

void	ft_print_ptr_int_tab(int **tab, int size)
{
	printf("The returned size of range is %d.\n", size);
	printf("tab = %p\n", tab);
	printf("*tab = %p\n", *tab);
	if (tab != NULL && *tab != NULL && size > 0)
	{
		ft_print_int_tab(*tab, size);
	}
	else if (size == 0)
		printf("\nNone array - Reason : If the value of min is greater or equal to maxâ€™s value, range will point on NULL and it should return 0.");
	else if (size == -1)
		printf("\nIncomplete array - Reason : The size of range should be returned (or -1 on error).");
}

int	main(void)
{
	int	min;
	int	max;
	//int	**ptr;
	int	*tab1 = NULL;
	int	tab1_size;
	/*int	*tab2 = NULL;
	int	tab2_size;
	int	*tab3 = NULL;
	int	tab3_size;
	int	*tab4 = NULL;
	int	tab4_size;*/

	min = 3;
	max = 8;
	tab1_size = ft_ultimate_range(&tab1, min, max);
	printf("Pour min = %d et max = %d, tab1 =\n", min, max);
	printf("&tab1 = %p\n", &tab1);
	ft_print_ptr_int_tab(&tab1, tab1_size);
	/*ptr = &tab1;
	printf("ptr = %p\n", ptr);
	ft_print_int_tab(ptr, tab1_size);*/
	//free(*tab1);
	/*free(*ptr);
	free(ptr);*/
	/*min = 42;
	max = 42;
	tab2_size = ft_ultimate_range(tab2, min, max);
	printf("\nPour min = %d et max = %d, tab2 =\n", min, max);
	ft_print_int_tab(*tab2, tab2_size);
	free(*tab2);
	free(tab2);
	min = -42;
	max = 43;
	tab3_size = ft_ultimate_range(tab3, min, max);
	printf("\nPour min = %d et max = %d, tab3 =\n", min, max);
	ft_print_int_tab(*tab3, tab3_size);
	free(*tab3);
	free(tab3);
	min = 42;
	max = -1;
	tab4_size = ft_ultimate_range(tab4, min, max);
	printf("\nPour min = %d et max = %d, tab4 =\n", min, max);
	ft_print_int_tab(*tab4, tab4_size);
	free(*tab4);
	free(tab4);*/
	return (0);
}
e3r11p9% gcc -Wall -Wextra -Werror -o test_ft_ultimate_range ft_ultimate_range.c test_ft_ultimate_range.c
e3r11p9% ./test_ft_ultimate_range                                                                      
Pour min = 3 et max = 8, tab1 =
&tab1 = 0x7fff2827b760
The returned size of range is 5.
tab = 0x7fff2827b760
*tab = (nil)
e3r11p9% vi test_ft_ultimate_range.c                                                                    
e3r11p9% vi ft_ultimate_range.c 
e3r11p9% cat ft_ultimate_range.c 
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_ultimate_range.c                                :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: hauerbac <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2023/02/23 10:23:31 by hauerbac          #+#    #+#             */
/*   Updated: 2023/02/27 17:57:45 by hauerbac         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include <stdlib.h>
#include <stdio.h>

int	*ft_range(int min, int max)
{
	int	range_len;
	int	*ptr;
	int	i;
	int	value;

	if (min < max)
	{
		range_len = max - min;
		ptr = (int *) malloc(range_len * sizeof(int));
		if (ptr)
		{
			value = min;
			i = 0;
			while (i < range_len && value < max)
				ptr[i++] = value++;
			if (i == range_len)
				return (ptr);
			else
				return (NULL);
		}
	}
	return (NULL);
}

int	ft_ultimate_range(int **range, int min, int max)
{
	int	range_len;
	int	*ptr;

	range = NULL;
	if (min < max)
	{
		range = (int **) malloc(sizeof(int *));
		if (range == NULL)
			return (-1);
		range_len = max - min;
		ptr = ft_range(min, max);
		if (ptr)
		{
			printf("ptr = %p, *ptr = %d, *(ptr + 1) = %d\n", ptr, *ptr, *(ptr + 1));
			*range = ptr;
			printf("range = %p, *range = %p, *(*range + 1) = %d\n", range, *range, *(*range + 1));
			return (range_len);
		}
		else
			return (-1);
	}
	else
		return (0);
}
e3r11p9% gcc -Wall -Wextra -Werror -o test_ft_ultimate_range ft_ultimate_range.c test_ft_ultimate_range.c
e3r11p9% ./test_ft_ultimate_range                                                                      
ptr = 0x5617522042c0, *ptr = 3, *(ptr + 1) = 4
range = 0x5617522042a0, *range = 0x5617522042c0, *(*range + 1) = 4
Pour min = 3 et max = 8, tab1 =
&tab1 = 0x7ffd08fa1e90
The returned size of range is 5.
tab = 0x7ffd08fa1e90
*tab = (nil)
e3r11p9% vi test_ft_ultimate_range.c                                                                    
e3r11p9% cat test_ft_ultimate_range.c 
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   test_ft_ultimate_range.c                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: hauerbac <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2023/02/22 17:56:00 by hauerbac          #+#    #+#             */
/*   Updated: 2023/02/27 18:01:10 by hauerbac         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>

int	ft_ultimate_range(int **range, int min, int max);


void	ft_putnbr(int nb)
{
	long	nb_in_long;
	int		digit_to_char;

	nb_in_long = nb;
	if (nb_in_long < 0)
	{
		write(1, "-", 1);
		nb_in_long = nb_in_long * -1;
	}
	if (nb_in_long < 10)
	{
		digit_to_char = nb_in_long + '0';
		write(1, &digit_to_char, 1);
	}
	else
	{
		ft_putnbr(nb_in_long / 10);
		ft_putnbr(nb_in_long % 10);
	}
}

void	ft_print_int_tab(int *tab, int size)
{
	int	i;

	if (tab != NULL && size > 0)
	{
		write(1, "[", 1);
		i = 0;
		while (i < size)
		{
			ft_putnbr(tab[i]);
			if (i < size - 1)
				write(1, ", ", 2);
			i++;
		}
		write(1, "]", 1);
	}
}

void	ft_print_ptr_int_tab(int **tab, int size)
{
	printf("The returned size of range is %d.\n", size);
	printf("tab = %p\n", tab);
	printf("*tab = %p\n", *tab);
	if (tab != NULL && *tab != NULL && size > 0)
	{
		ft_print_int_tab(*tab, size);
	}
	else if (size == 0)
		printf("\nNone array - Reason : If the value of min is greater or equal to maxâ€™s value, range will point on NULL and it should return 0.");
	else if (size == -1)
		printf("\nIncomplete array - Reason : The size of range should be returned (or -1 on error).");
}

int	main(void)
{
	int	min;
	int	max;
	//int	**ptr;
	int	**tab1 = NULL;
	int	tab1_size;
	/*int	*tab2 = NULL;
	int	tab2_size;
	int	*tab3 = NULL;
	int	tab3_size;
	int	*tab4 = NULL;
	int	tab4_size;*/

	min = 3;
	max = 8;
	tab1_size = ft_ultimate_range(tab1, min, max);
	printf("Pour min = %d et max = %d, tab1 =\n", min, max);
	printf("tab1 = %p\n", tab1);
	ft_print_ptr_int_tab(*tab1, tab1_size);
	/*ptr = &tab1;
	printf("ptr = %p\n", ptr);
	ft_print_int_tab(ptr, tab1_size);*/
	//free(*tab1);
	/*free(*ptr);
	free(ptr);*/
	/*min = 42;
	max = 42;
	tab2_size = ft_ultimate_range(tab2, min, max);
	printf("\nPour min = %d et max = %d, tab2 =\n", min, max);
	ft_print_int_tab(*tab2, tab2_size);
	free(*tab2);
	free(tab2);
	min = -42;
	max = 43;
	tab3_size = ft_ultimate_range(tab3, min, max);
	printf("\nPour min = %d et max = %d, tab3 =\n", min, max);
	ft_print_int_tab(*tab3, tab3_size);
	free(*tab3);
	free(tab3);
	min = 42;
	max = -1;
	tab4_size = ft_ultimate_range(tab4, min, max);
	printf("\nPour min = %d et max = %d, tab4 =\n", min, max);
	ft_print_int_tab(*tab4, tab4_size);
	free(*tab4);
	free(tab4);*/
	return (0);
}
e3r11p9% gcc -Wall -Wextra -Werror -o test_ft_ultimate_range ft_ultimate_range.c test_ft_ultimate_range.c
test_ft_ultimate_range.c: In function â€˜mainâ€™:
test_ft_ultimate_range.c:96:23: error: passing argument 1 of â€˜ft_print_ptr_int_tabâ€™ from incompatible pointer type [-Werror=incompatible-pointer-types]
   96 |  ft_print_ptr_int_tab(*tab1, tab1_size);
      |                       ^~~~~
      |                       |
      |                       int *
test_ft_ultimate_range.c:62:33: note: expected â€˜int **â€™ but argument is of type â€˜int *â€™
   62 | void ft_print_ptr_int_tab(int **tab, int size)
      |                           ~~~~~~^~~
cc1: all warnings being treated as errors
e3r11p9% vi test_ft_ultimate_range.c                                                                    
e3r11p9% cat test_ft_ultimate_range.c                                                                    
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   test_ft_ultimate_range.c                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: hauerbac <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2023/02/22 17:56:00 by hauerbac          #+#    #+#             */
/*   Updated: 2023/02/27 18:01:39 by hauerbac         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>

int	ft_ultimate_range(int **range, int min, int max);


void	ft_putnbr(int nb)
{
	long	nb_in_long;
	int		digit_to_char;

	nb_in_long = nb;
	if (nb_in_long < 0)
	{
		write(1, "-", 1);
		nb_in_long = nb_in_long * -1;
	}
	if (nb_in_long < 10)
	{
		digit_to_char = nb_in_long + '0';
		write(1, &digit_to_char, 1);
	}
	else
	{
		ft_putnbr(nb_in_long / 10);
		ft_putnbr(nb_in_long % 10);
	}
}

void	ft_print_int_tab(int *tab, int size)
{
	int	i;

	if (tab != NULL && size > 0)
	{
		write(1, "[", 1);
		i = 0;
		while (i < size)
		{
			ft_putnbr(tab[i]);
			if (i < size - 1)
				write(1, ", ", 2);
			i++;
		}
		write(1, "]", 1);
	}
}

void	ft_print_ptr_int_tab(int **tab, int size)
{
	printf("The returned size of range is %d.\n", size);
	printf("tab = %p\n", tab);
	printf("*tab = %p\n", *tab);
	if (tab != NULL && *tab != NULL && size > 0)
	{
		ft_print_int_tab(*tab, size);
	}
	else if (size == 0)
		printf("\nNone array - Reason : If the value of min is greater or equal to maxâ€™s value, range will point on NULL and it should return 0.");
	else if (size == -1)
		printf("\nIncomplete array - Reason : The size of range should be returned (or -1 on error).");
}

int	main(void)
{
	int	min;
	int	max;
	//int	**ptr;
	int	**tab1 = NULL;
	int	tab1_size;
	/*int	*tab2 = NULL;
	int	tab2_size;
	int	*tab3 = NULL;
	int	tab3_size;
	int	*tab4 = NULL;
	int	tab4_size;*/

	min = 3;
	max = 8;
	tab1_size = ft_ultimate_range(tab1, min, max);
	printf("Pour min = %d et max = %d, tab1 =\n", min, max);
	printf("tab1 = %p\n", tab1);
	ft_print_ptr_int_tab(tab1, tab1_size);
	/*ptr = &tab1;
	printf("ptr = %p\n", ptr);
	ft_print_int_tab(ptr, tab1_size);*/
	//free(*tab1);
	/*free(*ptr);
	free(ptr);*/
	/*min = 42;
	max = 42;
	tab2_size = ft_ultimate_range(tab2, min, max);
	printf("\nPour min = %d et max = %d, tab2 =\n", min, max);
	ft_print_int_tab(*tab2, tab2_size);
	free(*tab2);
	free(tab2);
	min = -42;
	max = 43;
	tab3_size = ft_ultimate_range(tab3, min, max);
	printf("\nPour min = %d et max = %d, tab3 =\n", min, max);
	ft_print_int_tab(*tab3, tab3_size);
	free(*tab3);
	free(tab3);
	min = 42;
	max = -1;
	tab4_size = ft_ultimate_range(tab4, min, max);
	printf("\nPour min = %d et max = %d, tab4 =\n", min, max);
	ft_print_int_tab(*tab4, tab4_size);
	free(*tab4);
	free(tab4);*/
	return (0);
}
e3r11p9% gcc -Wall -Wextra -Werror -o test_ft_ultimate_range ft_ultimate_range.c test_ft_ultimate_range.c
e3r11p9% ./test_ft_ultimate_range                                                                      
ptr = 0x561719cab2c0, *ptr = 3, *(ptr + 1) = 4
range = 0x561719cab2a0, *range = 0x561719cab2c0, *(*range + 1) = 4
Pour min = 3 et max = 8, tab1 =
tab1 = (nil)
The returned size of range is 5.
tab = (nil)
zsh: segmentation fault (core dumped)  ./test_ft_ultimate_range
e3r11p9% vi test_ft_ultimate_range.c                                                                    
e3r11p9% cat test_ft_ultimate_range.c                                                                    
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   test_ft_ultimate_range.c                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: hauerbac <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2023/02/22 17:56:00 by hauerbac          #+#    #+#             */
/*   Updated: 2023/02/27 19:13:59 by hauerbac         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>

int	ft_ultimate_range(int **range, int min, int max);


void	ft_putnbr(int nb)
{
	long	nb_in_long;
	int		digit_to_char;

	nb_in_long = nb;
	if (nb_in_long < 0)
	{
		write(1, "-", 1);
		nb_in_long = nb_in_long * -1;
	}
	if (nb_in_long < 10)
	{
		digit_to_char = nb_in_long + '0';
		write(1, &digit_to_char, 1);
	}
	else
	{
		ft_putnbr(nb_in_long / 10);
		ft_putnbr(nb_in_long % 10);
	}
}

void	ft_print_int_tab(int *tab, int size)
{
	int	i;

	if (tab != NULL && size > 0)
	{
		write(1, "[", 1);
		i = 0;
		while (i < size)
		{
			ft_putnbr(tab[i]);
			if (i < size - 1)
				write(1, ", ", 2);
			i++;
		}
		write(1, "]", 1);
	}
}

void	ft_print_ptr_int_tab(int **tab, int size)
{
	printf("The returned size of range is %d.\n", size);
	printf("tab = %p\n", tab);
	if (tab != NULL && *tab != NULL && size > 0)
	{
		printf("*tab = %p\n", *tab);
		ft_print_int_tab(*tab, size);
	}
	else if (size == 0)
		printf("\nNone array - Reason : If the value of min is greater or equal to maxâ€™s value, range will point on NULL and it should return 0.");
	else if (size == -1)
		printf("\nIncomplete array - Reason : The size of range should be returned (or -1 on error).");
	else
		printf("\nSegmentation fault - Reason : tab == (nil).");
}

int	main(void)
{
	int	min;
	int	max;
	//int	**ptr;
	int	**tab1 = NULL;
	int	tab1_size;
	/*int	*tab2 = NULL;
	int	tab2_size;
	int	*tab3 = NULL;
	int	tab3_size;
	int	*tab4 = NULL;
	int	tab4_size;*/

	min = 3;
	max = 8;
	tab1_size = ft_ultimate_range(tab1, min, max);
	printf("Pour min = %d et max = %d, tab1 =\n", min, max);
	printf("tab1 = %p\n", tab1);
	ft_print_ptr_int_tab(tab1, tab1_size);
	/*ptr = &tab1;
	printf("ptr = %p\n", ptr);
	ft_print_int_tab(ptr, tab1_size);*/
	//free(*tab1);
	/*free(*ptr);
	free(ptr);*/
	/*min = 42;
	max = 42;
	tab2_size = ft_ultimate_range(tab2, min, max);
	printf("\nPour min = %d et max = %d, tab2 =\n", min, max);
	ft_print_int_tab(*tab2, tab2_size);
	free(*tab2);
	free(tab2);
	min = -42;
	max = 43;
	tab3_size = ft_ultimate_range(tab3, min, max);
	printf("\nPour min = %d et max = %d, tab3 =\n", min, max);
	ft_print_int_tab(*tab3, tab3_size);
	free(*tab3);
	free(tab3);
	min = 42;
	max = -1;
	tab4_size = ft_ultimate_range(tab4, min, max);
	printf("\nPour min = %d et max = %d, tab4 =\n", min, max);
	ft_print_int_tab(*tab4, tab4_size);
	free(*tab4);
	free(tab4);*/
	return (0);
}
e3r11p9% gcc -Wall -Wextra -Werror -o test_ft_ultimate_range ft_ultimate_range.c test_ft_ultimate_range.c
e3r11p9% ./test_ft_ultimate_range                                                                      
ptr = 0x5642c628b2c0, *ptr = 3, *(ptr + 1) = 4
range = 0x5642c628b2a0, *range = 0x5642c628b2c0, *(*range + 1) = 4
Pour min = 3 et max = 8, tab1 =
tab1 = (nil)
The returned size of range is 5.
tab = (nil)

Segmentation fault - Reason : tab == (nil).%                                                                               e3r11p9% vi test_ft_ultimate_range.c                                                                    
e3r11p9% cat test_ft_ultimate_range.c                                                                    
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   test_ft_ultimate_range.c                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: hauerbac <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2023/02/22 17:56:00 by hauerbac          #+#    #+#             */
/*   Updated: 2023/02/27 19:14:52 by hauerbac         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>

int	ft_ultimate_range(int **range, int min, int max);


void	ft_putnbr(int nb)
{
	long	nb_in_long;
	int		digit_to_char;

	nb_in_long = nb;
	if (nb_in_long < 0)
	{
		write(1, "-", 1);
		nb_in_long = nb_in_long * -1;
	}
	if (nb_in_long < 10)
	{
		digit_to_char = nb_in_long + '0';
		write(1, &digit_to_char, 1);
	}
	else
	{
		ft_putnbr(nb_in_long / 10);
		ft_putnbr(nb_in_long % 10);
	}
}

void	ft_print_int_tab(int *tab, int size)
{
	int	i;

	if (tab != NULL && size > 0)
	{
		write(1, "[", 1);
		i = 0;
		while (i < size)
		{
			ft_putnbr(tab[i]);
			if (i < size - 1)
				write(1, ", ", 2);
			i++;
		}
		write(1, "]", 1);
	}
}

void	ft_print_ptr_int_tab(int **tab, int size)
{
	printf("The returned size of range is %d.\n", size);
	printf("tab = %p\n", tab);
	if (tab != NULL && *tab != NULL && size > 0)
	{
		printf("*tab = %p\n", *tab);
		ft_print_int_tab(*tab, size);
	}
	else if (size == 0)
		printf("\nNone array - Reason : If the value of min is greater or equal to maxâ€™s value, range will point on NULL and it should return 0.");
	else if (size == -1)
		printf("\nIncomplete array - Reason : The size of range should be returned (or -1 on error).");
	else
		printf("\nSegmentation fault - Reason : tab == (nil).");
}

int	main(void)
{
	int	min;
	int	max;
	//int	**ptr;
	int	**tab1;
	int	tab1_size;
	/*int	*tab2 = NULL;
	int	tab2_size;
	int	*tab3 = NULL;
	int	tab3_size;
	int	*tab4 = NULL;
	int	tab4_size;*/

	min = 3;
	max = 8;
	tab1_size = ft_ultimate_range(tab1, min, max);
	printf("Pour min = %d et max = %d, tab1 =\n", min, max);
	printf("tab1 = %p\n", tab1);
	ft_print_ptr_int_tab(tab1, tab1_size);
	/*ptr = &tab1;
	printf("ptr = %p\n", ptr);
	ft_print_int_tab(ptr, tab1_size);*/
	//free(*tab1);
	/*free(*ptr);
	free(ptr);*/
	/*min = 42;
	max = 42;
	tab2_size = ft_ultimate_range(tab2, min, max);
	printf("\nPour min = %d et max = %d, tab2 =\n", min, max);
	ft_print_int_tab(*tab2, tab2_size);
	free(*tab2);
	free(tab2);
	min = -42;
	max = 43;
	tab3_size = ft_ultimate_range(tab3, min, max);
	printf("\nPour min = %d et max = %d, tab3 =\n", min, max);
	ft_print_int_tab(*tab3, tab3_size);
	free(*tab3);
	free(tab3);
	min = 42;
	max = -1;
	tab4_size = ft_ultimate_range(tab4, min, max);
	printf("\nPour min = %d et max = %d, tab4 =\n", min, max);
	ft_print_int_tab(*tab4, tab4_size);
	free(*tab4);
	free(tab4);*/
	return (0);
}
e3r11p9% gcc -Wall -Wextra -Werror -o test_ft_ultimate_range ft_ultimate_range.c test_ft_ultimate_range.c
test_ft_ultimate_range.c: In function â€˜mainâ€™:
test_ft_ultimate_range.c:95:14: error: â€˜tab1â€™ is used uninitialized in this function [-Werror=uninitialized]
   95 |  tab1_size = ft_ultimate_range(tab1, min, max);
      |              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
cc1: all warnings being treated as errors
e3r11p9% vi test_ft_ultimate_range.c                                                                    
e3r11p9% cat test_ft_ultimate_range.c                                                                    
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   test_ft_ultimate_range.c                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: hauerbac <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2023/02/22 17:56:00 by hauerbac          #+#    #+#             */
/*   Updated: 2023/02/27 19:22:48 by hauerbac         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>

int	ft_ultimate_range(int **range, int min, int max);


void	ft_putnbr(int nb)
{
	long	nb_in_long;
	int		digit_to_char;

	nb_in_long = nb;
	if (nb_in_long < 0)
	{
		write(1, "-", 1);
		nb_in_long = nb_in_long * -1;
	}
	if (nb_in_long < 10)
	{
		digit_to_char = nb_in_long + '0';
		write(1, &digit_to_char, 1);
	}
	else
	{
		ft_putnbr(nb_in_long / 10);
		ft_putnbr(nb_in_long % 10);
	}
}

void	ft_print_int_tab(int *tab, int size)
{
	int	i;

	if (tab != NULL && size > 0)
	{
		write(1, "[", 1);
		i = 0;
		while (i < size)
		{
			ft_putnbr(tab[i]);
			if (i < size - 1)
				write(1, ", ", 2);
			i++;
		}
		write(1, "]", 1);
	}
}

void	ft_print_ptr_int_tab(int **tab, int size)
{
	printf("The returned size of range is %d.\n", size);
	printf("tab = %p\n", tab);
	if (tab != NULL && *tab != NULL && size > 0)
	{
		printf("*tab = %p\n", *tab);
		ft_print_int_tab(*tab, size);
	}
	else if (size == 0)
		printf("\nNone array - Reason : If the value of min is greater or equal to maxâ€™s value, range will point on NULL and it should return 0.");
	else if (size == -1)
		printf("\nIncomplete array - Reason : The size of range should be returned (or -1 on error).");
	else
		printf("\nSegmentation fault - Reason : tab == (nil).");
}

int	main(void)
{
	int	min;
	int	max;
	int	**ptr = NULL;
	int	*tab1 = NULL;
	int	tab1_size;
	/*int	*tab2 = NULL;
	int	tab2_size;
	int	*tab3 = NULL;
	int	tab3_size;
	int	*tab4 = NULL;
	int	tab4_size;*/

	min = 3;
	max = 8;
	ptr = &tab1;
	printf("ptr = %p\n", ptr);
	tab1_size = ft_ultimate_range(ptr, min, max);
	printf("2 ptr = %p\n", ptr);
	printf("Pour min = %d et max = %d, tab1 =\n", min, max);
	printf("tab1 = %p\n", tab1);
	ft_print_ptr_int_tab(tab1, tab1_size);
	//free(*tab1);
	/*free(*ptr);
	free(ptr);*/
	/*min = 42;
	max = 42;
	tab2_size = ft_ultimate_range(tab2, min, max);
	printf("\nPour min = %d et max = %d, tab2 =\n", min, max);
	ft_print_int_tab(*tab2, tab2_size);
	free(*tab2);
	free(tab2);
	min = -42;
	max = 43;
	tab3_size = ft_ultimate_range(tab3, min, max);
	printf("\nPour min = %d et max = %d, tab3 =\n", min, max);
	ft_print_int_tab(*tab3, tab3_size);
	free(*tab3);
	free(tab3);
	min = 42;
	max = -1;
	tab4_size = ft_ultimate_range(tab4, min, max);
	printf("\nPour min = %d et max = %d, tab4 =\n", min, max);
	ft_print_int_tab(*tab4, tab4_size);
	free(*tab4);
	free(tab4);*/
	return (0);
}
e3r11p9% gcc -Wall -Wextra -Werror -o test_ft_ultimate_range ft_ultimate_range.c test_ft_ultimate_range.c
test_ft_ultimate_range.c: In function â€˜mainâ€™:
test_ft_ultimate_range.c:101:23: error: passing argument 1 of â€˜ft_print_ptr_int_tabâ€™ from incompatible pointer type [-Werror=incompatible-pointer-types]
  101 |  ft_print_ptr_int_tab(tab1, tab1_size);
      |                       ^~~~
      |                       |
      |                       int *
test_ft_ultimate_range.c:62:33: note: expected â€˜int **â€™ but argument is of type â€˜int *â€™
   62 | void ft_print_ptr_int_tab(int **tab, int size)
      |                           ~~~~~~^~~
cc1: all warnings being treated as errors
e3r11p9% vi test_ft_ultimate_range.c                                                                    
e3r11p9% cat test_ft_ultimate_range.c                                                                    
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   test_ft_ultimate_range.c                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: hauerbac <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2023/02/22 17:56:00 by hauerbac          #+#    #+#             */
/*   Updated: 2023/02/27 19:23:20 by hauerbac         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>

int	ft_ultimate_range(int **range, int min, int max);


void	ft_putnbr(int nb)
{
	long	nb_in_long;
	int		digit_to_char;

	nb_in_long = nb;
	if (nb_in_long < 0)
	{
		write(1, "-", 1);
		nb_in_long = nb_in_long * -1;
	}
	if (nb_in_long < 10)
	{
		digit_to_char = nb_in_long + '0';
		write(1, &digit_to_char, 1);
	}
	else
	{
		ft_putnbr(nb_in_long / 10);
		ft_putnbr(nb_in_long % 10);
	}
}

void	ft_print_int_tab(int *tab, int size)
{
	int	i;

	if (tab != NULL && size > 0)
	{
		write(1, "[", 1);
		i = 0;
		while (i < size)
		{
			ft_putnbr(tab[i]);
			if (i < size - 1)
				write(1, ", ", 2);
			i++;
		}
		write(1, "]", 1);
	}
}

void	ft_print_ptr_int_tab(int **tab, int size)
{
	printf("The returned size of range is %d.\n", size);
	printf("tab = %p\n", tab);
	if (tab != NULL && *tab != NULL && size > 0)
	{
		printf("*tab = %p\n", *tab);
		ft_print_int_tab(*tab, size);
	}
	else if (size == 0)
		printf("\nNone array - Reason : If the value of min is greater or equal to maxâ€™s value, range will point on NULL and it should return 0.");
	else if (size == -1)
		printf("\nIncomplete array - Reason : The size of range should be returned (or -1 on error).");
	else
		printf("\nSegmentation fault - Reason : tab == (nil).");
}

int	main(void)
{
	int	min;
	int	max;
	int	**ptr = NULL;
	int	*tab1 = NULL;
	int	tab1_size;
	/*int	*tab2 = NULL;
	int	tab2_size;
	int	*tab3 = NULL;
	int	tab3_size;
	int	*tab4 = NULL;
	int	tab4_size;*/

	min = 3;
	max = 8;
	ptr = &tab1;
	printf("ptr = %p\n", ptr);
	tab1_size = ft_ultimate_range(ptr, min, max);
	printf("2 ptr = %p\n", ptr);
	printf("Pour min = %d et max = %d, tab1 =\n", min, max);
	printf("tab1 = %p\n", tab1);
	ft_print_ptr_int_tab(ptr, tab1_size);
	//free(*tab1);
	/*free(*ptr);
	free(ptr);*/
	/*min = 42;
	max = 42;
	tab2_size = ft_ultimate_range(tab2, min, max);
	printf("\nPour min = %d et max = %d, tab2 =\n", min, max);
	ft_print_int_tab(*tab2, tab2_size);
	free(*tab2);
	free(tab2);
	min = -42;
	max = 43;
	tab3_size = ft_ultimate_range(tab3, min, max);
	printf("\nPour min = %d et max = %d, tab3 =\n", min, max);
	ft_print_int_tab(*tab3, tab3_size);
	free(*tab3);
	free(tab3);
	min = 42;
	max = -1;
	tab4_size = ft_ultimate_range(tab4, min, max);
	printf("\nPour min = %d et max = %d, tab4 =\n", min, max);
	ft_print_int_tab(*tab4, tab4_size);
	free(*tab4);
	free(tab4);*/
	return (0);
}
e3r11p9% gcc -Wall -Wextra -Werror -o test_ft_ultimate_range ft_ultimate_range.c test_ft_ultimate_range.c
e3r11p9% ./test_ft_ultimate_range                                                                      
ptr = 0x7ffc229dacd8
ptr = 0x5632834416d0, *ptr = 3, *(ptr + 1) = 4
range = 0x5632834416b0, *range = 0x5632834416d0, *(*range + 1) = 4
2 ptr = 0x7ffc229dacd8
Pour min = 3 et max = 8, tab1 =
tab1 = (nil)
The returned size of range is 5.
tab = 0x7ffc229dacd8

Segmentation fault - Reason : tab == (nil).%                                                                               e3r11p9% vi test_ft_ultimate_range.c                                                                    
e3r11p9% cat test_ft_ultimate_range.c                                                                    
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   test_ft_ultimate_range.c                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: hauerbac <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2023/02/22 17:56:00 by hauerbac          #+#    #+#             */
/*   Updated: 2023/02/27 19:25:13 by hauerbac         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>

int	ft_ultimate_range(int **range, int min, int max);


void	ft_putnbr(int nb)
{
	long	nb_in_long;
	int		digit_to_char;

	nb_in_long = nb;
	if (nb_in_long < 0)
	{
		write(1, "-", 1);
		nb_in_long = nb_in_long * -1;
	}
	if (nb_in_long < 10)
	{
		digit_to_char = nb_in_long + '0';
		write(1, &digit_to_char, 1);
	}
	else
	{
		ft_putnbr(nb_in_long / 10);
		ft_putnbr(nb_in_long % 10);
	}
}

void	ft_print_int_tab(int *tab, int size)
{
	int	i;

	if (tab != NULL && size > 0)
	{
		write(1, "[", 1);
		i = 0;
		while (i < size)
		{
			ft_putnbr(tab[i]);
			if (i < size - 1)
				write(1, ", ", 2);
			i++;
		}
		write(1, "]", 1);
	}
}

void	ft_print_ptr_int_tab(int **tab, int size)
{
	printf("The returned size of range is %d.\n", size);
	printf("tab = %p\n", tab);
	if (tab != NULL && *tab != NULL && size > 0)
	{
		printf("*tab = %p\n", *tab);
		ft_print_int_tab(*tab, size);
	}
	else if (size == 0)
		printf("\nNone array - Reason : If the value of min is greater or equal to maxâ€™s value, range will point on NULL and it should return 0.");
	else if (size == -1)
		printf("\nIncomplete array - Reason : The size of range should be returned (or -1 on error).");
	else
		printf("\nSegmentation fault - Reason : tab == (nil).");
}

int	main(void)
{
	int	min;
	int	max;
	int	**ptr = NULL;
	int	*tab1 = NULL;
	int	tab1_size;
	/*int	*tab2 = NULL;
	int	tab2_size;
	int	*tab3 = NULL;
	int	tab3_size;
	int	*tab4 = NULL;
	int	tab4_size;*/

	min = 3;
	max = 8;
	ptr = &tab1;
	printf("ptr = %p\n", ptr);
	tab1_size = ft_ultimate_range(ptr, min, max);
	tab1 = *ptr;
	printf("2 ptr = %p\n", ptr);
	printf("Pour min = %d et max = %d, tab1 =\n", min, max);
	printf("tab1 = %p\n", tab1);
	ft_print_ptr_int_tab(ptr, tab1_size);
	//free(*tab1);
	/*free(*ptr);
	free(ptr);*/
	/*min = 42;
	max = 42;
	tab2_size = ft_ultimate_range(tab2, min, max);
	printf("\nPour min = %d et max = %d, tab2 =\n", min, max);
	ft_print_int_tab(*tab2, tab2_size);
	free(*tab2);
	free(tab2);
	min = -42;
	max = 43;
	tab3_size = ft_ultimate_range(tab3, min, max);
	printf("\nPour min = %d et max = %d, tab3 =\n", min, max);
	ft_print_int_tab(*tab3, tab3_size);
	free(*tab3);
	free(tab3);
	min = 42;
	max = -1;
	tab4_size = ft_ultimate_range(tab4, min, max);
	printf("\nPour min = %d et max = %d, tab4 =\n", min, max);
	ft_print_int_tab(*tab4, tab4_size);
	free(*tab4);
	free(tab4);*/
	return (0);
}
e3r11p9% gcc -Wall -Wextra -Werror -o test_ft_ultimate_range ft_ultimate_range.c test_ft_ultimate_range.c
e3r11p9% ./test_ft_ultimate_range                                                                      
ptr = 0x7ffdec5b99b8
ptr = 0x55752fd366d0, *ptr = 3, *(ptr + 1) = 4
range = 0x55752fd366b0, *range = 0x55752fd366d0, *(*range + 1) = 4
2 ptr = 0x7ffdec5b99b8
Pour min = 3 et max = 8, tab1 =
tab1 = (nil)
The returned size of range is 5.
tab = 0x7ffdec5b99b8

Segmentation fault - Reason : tab == (nil).%                                                                               e3r11p9% vi test_ft_ultimate_range.c                                                                    
e3r11p9% cat test_ft_ultimate_range.c                                                                    
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   test_ft_ultimate_range.c                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: hauerbac <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2023/02/22 17:56:00 by hauerbac          #+#    #+#             */
/*   Updated: 2023/02/27 19:29:22 by hauerbac         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>

int	ft_ultimate_range(int **range, int min, int max);


void	ft_putnbr(int nb)
{
	long	nb_in_long;
	int		digit_to_char;

	nb_in_long = nb;
	if (nb_in_long < 0)
	{
		write(1, "-", 1);
		nb_in_long = nb_in_long * -1;
	}
	if (nb_in_long < 10)
	{
		digit_to_char = nb_in_long + '0';
		write(1, &digit_to_char, 1);
	}
	else
	{
		ft_putnbr(nb_in_long / 10);
		ft_putnbr(nb_in_long % 10);
	}
}

void	ft_print_int_tab(int *tab, int size)
{
	int	i;

	if (tab != NULL && size > 0)
	{
		write(1, "[", 1);
		i = 0;
		while (i < size)
		{
			ft_putnbr(tab[i]);
			if (i < size - 1)
				write(1, ", ", 2);
			i++;
		}
		write(1, "]", 1);
	}
}

void	ft_print_ptr_int_tab(int **tab, int size)
{
	printf("The returned size of range is %d.\n", size);
	printf("tab = %p\n", tab);
	if (tab != NULL && *tab != NULL && size > 0)
	{
		printf("*tab = %p\n", *tab);
		ft_print_int_tab(*tab, size);
	}
	else if (size == 0)
		printf("\nNone array - Reason : If the value of min is greater or equal to maxâ€™s value, range will point on NULL and it should return 0.");
	else if (size == -1)
		printf("\nIncomplete array - Reason : The size of range should be returned (or -1 on error).");
	else
		printf("\nSegmentation fault - Reason : tab == (nil).");
}

int	main(void)
{
	int	min;
	int	max;
	int	**ptr = NULL;
	int	tab1[0] = {};
	int	tab1_size;
	/*int	*tab2 = NULL;
	int	tab2_size;
	int	*tab3 = NULL;
	int	tab3_size;
	int	*tab4 = NULL;
	int	tab4_size;*/

	min = 3;
	max = 8;
	ptr = &tab1;
	printf("ptr = %p\n", ptr);
	tab1_size = ft_ultimate_range(ptr, min, max);
	tab1 = *ptr;
	printf("2 ptr = %p\n", ptr);
	printf("Pour min = %d et max = %d, tab1 =\n", min, max);
	printf("tab1 = %p\n", tab1);
	ft_print_ptr_int_tab(ptr, tab1_size);
	//free(*tab1);
	/*free(*ptr);
	free(ptr);*/
	/*min = 42;
	max = 42;
	tab2_size = ft_ultimate_range(tab2, min, max);
	printf("\nPour min = %d et max = %d, tab2 =\n", min, max);
	ft_print_int_tab(*tab2, tab2_size);
	free(*tab2);
	free(tab2);
	min = -42;
	max = 43;
	tab3_size = ft_ultimate_range(tab3, min, max);
	printf("\nPour min = %d et max = %d, tab3 =\n", min, max);
	ft_print_int_tab(*tab3, tab3_size);
	free(*tab3);
	free(tab3);
	min = 42;
	max = -1;
	tab4_size = ft_ultimate_range(tab4, min, max);
	printf("\nPour min = %d et max = %d, tab4 =\n", min, max);
	ft_print_int_tab(*tab4, tab4_size);
	free(*tab4);
	free(tab4);*/
	return (0);
}
e3r11p9% gcc -Wall -Wextra -Werror -o test_ft_ultimate_range ft_ultimate_range.c test_ft_ultimate_range.c
test_ft_ultimate_range.c: In function â€˜mainâ€™:
test_ft_ultimate_range.c:95:6: error: assignment to â€˜int **â€™ from incompatible pointer type â€˜int (*)[0]â€™ [-Werror=incompatible-pointer-types]
   95 |  ptr = &tab1;
      |      ^
test_ft_ultimate_range.c:98:7: error: assignment to expression with array type
   98 |  tab1 = *ptr;
      |       ^
cc1: all warnings being treated as errors
e3r11p9% vi test_ft_ultimate_range.c                                                                    
e3r11p9% cat test_ft_ultimate_range.c                                                                    
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   test_ft_ultimate_range.c                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: hauerbac <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2023/02/22 17:56:00 by hauerbac          #+#    #+#             */
/*   Updated: 2023/02/27 19:29:58 by hauerbac         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>

int	ft_ultimate_range(int **range, int min, int max);


void	ft_putnbr(int nb)
{
	long	nb_in_long;
	int		digit_to_char;

	nb_in_long = nb;
	if (nb_in_long < 0)
	{
		write(1, "-", 1);
		nb_in_long = nb_in_long * -1;
	}
	if (nb_in_long < 10)
	{
		digit_to_char = nb_in_long + '0';
		write(1, &digit_to_char, 1);
	}
	else
	{
		ft_putnbr(nb_in_long / 10);
		ft_putnbr(nb_in_long % 10);
	}
}

void	ft_print_int_tab(int *tab, int size)
{
	int	i;

	if (tab != NULL && size > 0)
	{
		write(1, "[", 1);
		i = 0;
		while (i < size)
		{
			ft_putnbr(tab[i]);
			if (i < size - 1)
				write(1, ", ", 2);
			i++;
		}
		write(1, "]", 1);
	}
}

void	ft_print_ptr_int_tab(int **tab, int size)
{
	printf("The returned size of range is %d.\n", size);
	printf("tab = %p\n", tab);
	if (tab != NULL && *tab != NULL && size > 0)
	{
		printf("*tab = %p\n", *tab);
		ft_print_int_tab(*tab, size);
	}
	else if (size == 0)
		printf("\nNone array - Reason : If the value of min is greater or equal to maxâ€™s value, range will point on NULL and it should return 0.");
	else if (size == -1)
		printf("\nIncomplete array - Reason : The size of range should be returned (or -1 on error).");
	else
		printf("\nSegmentation fault - Reason : tab == (nil).");
}

int	main(void)
{
	int	min;
	int	max;
	int	**ptr = NULL;
	int	tab1[] = {};
	int	tab1_size;
	/*int	*tab2 = NULL;
	int	tab2_size;
	int	*tab3 = NULL;
	int	tab3_size;
	int	*tab4 = NULL;
	int	tab4_size;*/

	min = 3;
	max = 8;
	ptr = &tab1;
	printf("ptr = %p\n", ptr);
	tab1_size = ft_ultimate_range(ptr, min, max);
	tab1 = *ptr;
	printf("2 ptr = %p\n", ptr);
	printf("Pour min = %d et max = %d, tab1 =\n", min, max);
	printf("tab1 = %p\n", tab1);
	ft_print_ptr_int_tab(ptr, tab1_size);
	//free(*tab1);
	/*free(*ptr);
	free(ptr);*/
	/*min = 42;
	max = 42;
	tab2_size = ft_ultimate_range(tab2, min, max);
	printf("\nPour min = %d et max = %d, tab2 =\n", min, max);
	ft_print_int_tab(*tab2, tab2_size);
	free(*tab2);
	free(tab2);
	min = -42;
	max = 43;
	tab3_size = ft_ultimate_range(tab3, min, max);
	printf("\nPour min = %d et max = %d, tab3 =\n", min, max);
	ft_print_int_tab(*tab3, tab3_size);
	free(*tab3);
	free(tab3);
	min = 42;
	max = -1;
	tab4_size = ft_ultimate_range(tab4, min, max);
	printf("\nPour min = %d et max = %d, tab4 =\n", min, max);
	ft_print_int_tab(*tab4, tab4_size);
	free(*tab4);
	free(tab4);*/
	return (0);
}
e3r11p9% gcc -Wall -Wextra -Werror -o test_ft_ultimate_range ft_ultimate_range.c test_ft_ultimate_range.c
test_ft_ultimate_range.c: In function â€˜mainâ€™:
test_ft_ultimate_range.c:95:6: error: assignment to â€˜int **â€™ from incompatible pointer type â€˜int (*)[0]â€™ [-Werror=incompatible-pointer-types]
   95 |  ptr = &tab1;
      |      ^
test_ft_ultimate_range.c:98:7: error: assignment to expression with array type
   98 |  tab1 = *ptr;
      |       ^
cc1: all warnings being treated as errors
e3r11p9% vi test_ft_ultimate_range.c                                                                    
e3r11p9% cat test_ft_ultimate_range.c                                                                    
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   test_ft_ultimate_range.c                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: hauerbac <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2023/02/22 17:56:00 by hauerbac          #+#    #+#             */
/*   Updated: 2023/02/27 19:31:22 by hauerbac         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>

int	ft_ultimate_range(int **range, int min, int max);


void	ft_putnbr(int nb)
{
	long	nb_in_long;
	int		digit_to_char;

	nb_in_long = nb;
	if (nb_in_long < 0)
	{
		write(1, "-", 1);
		nb_in_long = nb_in_long * -1;
	}
	if (nb_in_long < 10)
	{
		digit_to_char = nb_in_long + '0';
		write(1, &digit_to_char, 1);
	}
	else
	{
		ft_putnbr(nb_in_long / 10);
		ft_putnbr(nb_in_long % 10);
	}
}

void	ft_print_int_tab(int *tab, int size)
{
	int	i;

	if (tab != NULL && size > 0)
	{
		write(1, "[", 1);
		i = 0;
		while (i < size)
		{
			ft_putnbr(tab[i]);
			if (i < size - 1)
				write(1, ", ", 2);
			i++;
		}
		write(1, "]", 1);
	}
}

void	ft_print_ptr_int_tab(int **tab, int size)
{
	printf("The returned size of range is %d.\n", size);
	printf("tab = %p\n", tab);
	if (tab != NULL && *tab != NULL && size > 0)
	{
		printf("*tab = %p\n", *tab);
		ft_print_int_tab(*tab, size);
	}
	else if (size == 0)
		printf("\nNone array - Reason : If the value of min is greater or equal to maxâ€™s value, range will point on NULL and it should return 0.");
	else if (size == -1)
		printf("\nIncomplete array - Reason : The size of range should be returned (or -1 on error).");
	else
		printf("\nSegmentation fault - Reason : tab == (nil).");
}

int	main(void)
{
	int	min;
	int	max;
	int	**ptr = NULL;
	int	tab1[] = {};
	int	tab1_size;
	/*int	*tab2 = NULL;
	int	tab2_size;
	int	*tab3 = NULL;
	int	tab3_size;
	int	*tab4 = NULL;
	int	tab4_size;*/

	min = 3;
	max = 8;
	/*ptr = &tab1;
	printf("ptr = %p\n", ptr);*/
	tab1_size = ft_ultimate_range(&tab1, min, max);
	/*tab1 = *ptr;
	printf("2 ptr = %p\n", ptr);*/
	printf("Pour min = %d et max = %d, tab1 =\n", min, max);
	printf("tab1 = %p\n", tab1);
	ft_print_ptr_int_tab(&tab1, tab1_size);
	//free(*tab1);
	/*free(*ptr);
	free(ptr);*/
	/*min = 42;
	max = 42;
	tab2_size = ft_ultimate_range(tab2, min, max);
	printf("\nPour min = %d et max = %d, tab2 =\n", min, max);
	ft_print_int_tab(*tab2, tab2_size);
	free(*tab2);
	free(tab2);
	min = -42;
	max = 43;
	tab3_size = ft_ultimate_range(tab3, min, max);
	printf("\nPour min = %d et max = %d, tab3 =\n", min, max);
	ft_print_int_tab(*tab3, tab3_size);
	free(*tab3);
	free(tab3);
	min = 42;
	max = -1;
	tab4_size = ft_ultimate_range(tab4, min, max);
	printf("\nPour min = %d et max = %d, tab4 =\n", min, max);
	ft_print_int_tab(*tab4, tab4_size);
	free(*tab4);
	free(tab4);*/
	return (0);
}
e3r11p9% gcc -Wall -Wextra -Werror -o test_ft_ultimate_range ft_ultimate_range.c test_ft_ultimate_range.c
test_ft_ultimate_range.c: In function â€˜mainâ€™:
test_ft_ultimate_range.c:97:32: error: passing argument 1 of â€˜ft_ultimate_rangeâ€™ from incompatible pointer type [-Werror=incompatible-pointer-types]
   97 |  tab1_size = ft_ultimate_range(&tab1, min, max);
      |                                ^~~~~
      |                                |
      |                                int (*)[0]
test_ft_ultimate_range.c:17:29: note: expected â€˜int **â€™ but argument is of type â€˜int (*)[0]â€™
   17 | int ft_ultimate_range(int **range, int min, int max);
      |                       ~~~~~~^~~~~
test_ft_ultimate_range.c:102:23: error: passing argument 1 of â€˜ft_print_ptr_int_tabâ€™ from incompatible pointer type [-Werror=incompatible-pointer-types]
  102 |  ft_print_ptr_int_tab(&tab1, tab1_size);
      |                       ^~~~~
      |                       |
      |                       int (*)[0]
test_ft_ultimate_range.c:62:33: note: expected â€˜int **â€™ but argument is of type â€˜int (*)[0]â€™
   62 | void ft_print_ptr_int_tab(int **tab, int size)
      |                           ~~~~~~^~~
test_ft_ultimate_range.c:83:8: error: unused variable â€˜ptrâ€™ [-Werror=unused-variable]
   83 |  int **ptr = NULL;
      |        ^~~
cc1: all warnings being treated as errors
e3r11p9% vi test_ft_ultimate_range.c                                                                    
e3r11p9% cat test_ft_ultimate_range.c                                                                    
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   test_ft_ultimate_range.c                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: hauerbac <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2023/02/22 17:56:00 by hauerbac          #+#    #+#             */
/*   Updated: 2023/02/27 19:31:58 by hauerbac         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>

int	ft_ultimate_range(int **range, int min, int max);


void	ft_putnbr(int nb)
{
	long	nb_in_long;
	int		digit_to_char;

	nb_in_long = nb;
	if (nb_in_long < 0)
	{
		write(1, "-", 1);
		nb_in_long = nb_in_long * -1;
	}
	if (nb_in_long < 10)
	{
		digit_to_char = nb_in_long + '0';
		write(1, &digit_to_char, 1);
	}
	else
	{
		ft_putnbr(nb_in_long / 10);
		ft_putnbr(nb_in_long % 10);
	}
}

void	ft_print_int_tab(int *tab, int size)
{
	int	i;

	if (tab != NULL && size > 0)
	{
		write(1, "[", 1);
		i = 0;
		while (i < size)
		{
			ft_putnbr(tab[i]);
			if (i < size - 1)
				write(1, ", ", 2);
			i++;
		}
		write(1, "]", 1);
	}
}

void	ft_print_ptr_int_tab(int **tab, int size)
{
	printf("The returned size of range is %d.\n", size);
	printf("tab = %p\n", tab);
	if (tab != NULL && *tab != NULL && size > 0)
	{
		printf("*tab = %p\n", *tab);
		ft_print_int_tab(*tab, size);
	}
	else if (size == 0)
		printf("\nNone array - Reason : If the value of min is greater or equal to maxâ€™s value, range will point on NULL and it should return 0.");
	else if (size == -1)
		printf("\nIncomplete array - Reason : The size of range should be returned (or -1 on error).");
	else
		printf("\nSegmentation fault - Reason : tab == (nil).");
}

int	main(void)
{
	int	min;
	int	max;
	//int	**ptr = NULL;
	int	tab1[] = {0};
	int	tab1_size;
	/*int	*tab2 = NULL;
	int	tab2_size;
	int	*tab3 = NULL;
	int	tab3_size;
	int	*tab4 = NULL;
	int	tab4_size;*/

	min = 3;
	max = 8;
	/*ptr = &tab1;
	printf("ptr = %p\n", ptr);*/
	tab1_size = ft_ultimate_range(&tab1, min, max);
	/*tab1 = *ptr;
	printf("2 ptr = %p\n", ptr);*/
	printf("Pour min = %d et max = %d, tab1 =\n", min, max);
	printf("tab1 = %p\n", tab1);
	ft_print_ptr_int_tab(&tab1, tab1_size);
	//free(*tab1);
	/*free(*ptr);
	free(ptr);*/
	/*min = 42;
	max = 42;
	tab2_size = ft_ultimate_range(tab2, min, max);
	printf("\nPour min = %d et max = %d, tab2 =\n", min, max);
	ft_print_int_tab(*tab2, tab2_size);
	free(*tab2);
	free(tab2);
	min = -42;
	max = 43;
	tab3_size = ft_ultimate_range(tab3, min, max);
	printf("\nPour min = %d et max = %d, tab3 =\n", min, max);
	ft_print_int_tab(*tab3, tab3_size);
	free(*tab3);
	free(tab3);
	min = 42;
	max = -1;
	tab4_size = ft_ultimate_range(tab4, min, max);
	printf("\nPour min = %d et max = %d, tab4 =\n", min, max);
	ft_print_int_tab(*tab4, tab4_size);
	free(*tab4);
	free(tab4);*/
	return (0);
}
e3r11p9% gcc -Wall -Wextra -Werror -o test_ft_ultimate_range ft_ultimate_range.c test_ft_ultimate_range.c
test_ft_ultimate_range.c: In function â€˜mainâ€™:
test_ft_ultimate_range.c:97:32: error: passing argument 1 of â€˜ft_ultimate_rangeâ€™ from incompatible pointer type [-Werror=incompatible-pointer-types]
   97 |  tab1_size = ft_ultimate_range(&tab1, min, max);
      |                                ^~~~~
      |                                |
      |                                int (*)[1]
test_ft_ultimate_range.c:17:29: note: expected â€˜int **â€™ but argument is of type â€˜int (*)[1]â€™
   17 | int ft_ultimate_range(int **range, int min, int max);
      |                       ~~~~~~^~~~~
test_ft_ultimate_range.c:102:23: error: passing argument 1 of â€˜ft_print_ptr_int_tabâ€™ from incompatible pointer type [-Werror=incompatible-pointer-types]
  102 |  ft_print_ptr_int_tab(&tab1, tab1_size);
      |                       ^~~~~
      |                       |
      |                       int (*)[1]
test_ft_ultimate_range.c:62:33: note: expected â€˜int **â€™ but argument is of type â€˜int (*)[1]â€™
   62 | void ft_print_ptr_int_tab(int **tab, int size)
      |                           ~~~~~~^~~
cc1: all warnings being treated as errors
e3r11p9% vi test_ft_ultimate_range.c                                                                    
e3r11p9% cat test_ft_ultimate_range.c                                                                    
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   test_ft_ultimate_range.c                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: hauerbac <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2023/02/22 17:56:00 by hauerbac          #+#    #+#             */
/*   Updated: 2023/02/27 19:53:46 by hauerbac         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>

int	ft_ultimate_range(int **range, int min, int max);


void	ft_putnbr(int nb)
{
	long	nb_in_long;
	int		digit_to_char;

	nb_in_long = nb;
	if (nb_in_long < 0)
	{
		write(1, "-", 1);
		nb_in_long = nb_in_long * -1;
	}
	if (nb_in_long < 10)
	{
		digit_to_char = nb_in_long + '0';
		write(1, &digit_to_char, 1);
	}
	else
	{
		ft_putnbr(nb_in_long / 10);
		ft_putnbr(nb_in_long % 10);
	}
}

void	ft_print_int_tab(int *tab, int size)
{
	int	i;

	if (tab != NULL && size > 0)
	{
		write(1, "[", 1);
		i = 0;
		while (i < size)
		{
			ft_putnbr(tab[i]);
			if (i < size - 1)
				write(1, ", ", 2);
			i++;
		}
		write(1, "]", 1);
	}
}

void	ft_print_ptr_int_tab(int **tab, int size)
{
	printf("The returned size of range is %d.\n", size);
	printf("tab = %p\n", tab);
	if (tab != NULL && *tab != NULL && size > 0)
	{
		printf("*tab = %p\n", *tab);
		ft_print_int_tab(*tab, size);
	}
	else if (size == 0)
		printf("\nNone array - Reason : If the value of min is greater or equal to maxâ€™s value, range will point on NULL and it should return 0.");
	else if (size == -1)
		printf("\nIncomplete array - Reason : The size of range should be returned (or -1 on error).");
	else
		printf("\nSegmentation fault - Reason : tab == (nil).");
}

int	main(void)
{
	int	min;
	int	max;
	//int	**ptr = NULL;
	int	*tab1 = {0};
	int	tab1_size;
	/*int	*tab2 = NULL;
	int	tab2_size;
	int	*tab3 = NULL;
	int	tab3_size;
	int	*tab4 = NULL;
	int	tab4_size;*/

	min = 3;
	max = 8;
	/*ptr = &tab1;
	printf("ptr = %p\n", ptr);*/
	tab1_size = ft_ultimate_range(&tab1, min, max);
	/*tab1 = *ptr;
	printf("2 ptr = %p\n", ptr);*/
	printf("Pour min = %d et max = %d, tab1 =\n", min, max);
	printf("tab1 = %p\n", tab1);
	ft_print_ptr_int_tab(&tab1, tab1_size);
	//free(*tab1);
	/*free(*ptr);
	free(ptr);*/
	/*min = 42;
	max = 42;
	tab2_size = ft_ultimate_range(tab2, min, max);
	printf("\nPour min = %d et max = %d, tab2 =\n", min, max);
	ft_print_int_tab(*tab2, tab2_size);
	free(*tab2);
	free(tab2);
	min = -42;
	max = 43;
	tab3_size = ft_ultimate_range(tab3, min, max);
	printf("\nPour min = %d et max = %d, tab3 =\n", min, max);
	ft_print_int_tab(*tab3, tab3_size);
	free(*tab3);
	free(tab3);
	min = 42;
	max = -1;
	tab4_size = ft_ultimate_range(tab4, min, max);
	printf("\nPour min = %d et max = %d, tab4 =\n", min, max);
	ft_print_int_tab(*tab4, tab4_size);
	free(*tab4);
	free(tab4);*/
	return (0);
}
e3r11p9% gcc -Wall -Wextra -Werror -o test_ft_ultimate_range ft_ultimate_range.c test_ft_ultimate_range.c
e3r11p9% ./test_ft_ultimate_range                                                                      
ptr = 0x56397f3072c0, *ptr = 3, *(ptr + 1) = 4
range = 0x56397f3072a0, *range = 0x56397f3072c0, *(*range + 1) = 4
Pour min = 3 et max = 8, tab1 =
tab1 = (nil)
The returned size of range is 5.
tab = 0x7ffe8385e920

Segmentation fault - Reason : tab == (nil).%                                                                               e3r11p9% vi test_ft_ultimate_range.c                                                                    
e3r11p9% cat test_ft_ultimate_range.c                                                                    
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   test_ft_ultimate_range.c                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: hauerbac <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2023/02/22 17:56:00 by hauerbac          #+#    #+#             */
/*   Updated: 2023/02/27 19:57:14 by hauerbac         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>

int	ft_ultimate_range(int **range, int min, int max);


void	ft_putnbr(int nb)
{
	long	nb_in_long;
	int		digit_to_char;

	nb_in_long = nb;
	if (nb_in_long < 0)
	{
		write(1, "-", 1);
		nb_in_long = nb_in_long * -1;
	}
	if (nb_in_long < 10)
	{
		digit_to_char = nb_in_long + '0';
		write(1, &digit_to_char, 1);
	}
	else
	{
		ft_putnbr(nb_in_long / 10);
		ft_putnbr(nb_in_long % 10);
	}
}

void	ft_print_int_tab(int *tab, int size)
{
	int	i;

	if (tab != NULL && size > 0)
	{
		write(1, "[", 1);
		i = 0;
		while (i < size)
		{
			ft_putnbr(tab[i]);
			if (i < size - 1)
				write(1, ", ", 2);
			i++;
		}
		write(1, "]", 1);
	}
}

void	ft_print_ptr_int_tab(int **tab, int size)
{
	printf("The returned size of range is %d.\n", size);
	printf("tab = %p\n", tab);
	if (tab != NULL && *tab != NULL && size > 0)
	{
		printf("*tab = %p\n", *tab);
		ft_print_int_tab(*tab, size);
	}
	else if (size == 0)
		printf("\nNone array - Reason : If the value of min is greater or equal to maxâ€™s value, range will point on NULL and it should return 0.");
	else if (size == -1)
		printf("\nIncomplete array - Reason : The size of range should be returned (or -1 on error).");
	else
		printf("\nSegmentation fault - Reason : tab == (nil).");
}

int	main(void)
{
	int	min;
	int	max;
	int	*tab1 = {};
	int	tab1_size;
	/*int	*tab2 = {};
	int	tab2_size;
	int	*tab3 = {};
	int	tab3_size;
	int	*tab4 = {};
	int	tab4_size;*/

	min = 3;
	max = 8;
	tab1_size = ft_ultimate_range(&tab1, min, max);
	printf("Pour min = %d et max = %d, tab1 =\n", min, max);
	printf("tab1 = %p\n", tab1);
	ft_print_ptr_int_tab(&tab1, tab1_size);
	//free(*tab1);
	/*free(*ptr);
	free(ptr);*/
	/*min = 42;
	max = 42;
	tab2_size = ft_ultimate_range(tab2, min, max);
	printf("\nPour min = %d et max = %d, tab2 =\n", min, max);
	ft_print_int_tab(*tab2, tab2_size);
	free(*tab2);
	free(tab2);
	min = -42;
	max = 43;
	tab3_size = ft_ultimate_range(tab3, min, max);
	printf("\nPour min = %d et max = %d, tab3 =\n", min, max);
	ft_print_int_tab(*tab3, tab3_size);
	free(*tab3);
	free(tab3);
	min = 42;
	max = -1;
	tab4_size = ft_ultimate_range(tab4, min, max);
	printf("\nPour min = %d et max = %d, tab4 =\n", min, max);
	ft_print_int_tab(*tab4, tab4_size);
	free(*tab4);
	free(tab4);*/
	return (0);
}
e3r11p9% gcc -Wall -Wextra -Werror -o test_ft_ultimate_range ft_ultimate_range.c test_ft_ultimate_range.c
test_ft_ultimate_range.c: In function â€˜mainâ€™:
test_ft_ultimate_range.c:83:14: error: empty scalar initializer
   83 |  int *tab1 = {};
      |              ^
test_ft_ultimate_range.c:83:14: note: (near initialization for â€˜tab1â€™)
e3r11p9% vi test_ft_ultimate_range.c                                                                   
e3r11p9% cat test_ft_ultimate_range.c                                                                    
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   test_ft_ultimate_range.c                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: hauerbac <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2023/02/22 17:56:00 by hauerbac          #+#    #+#             */
/*   Updated: 2023/02/27 19:57:50 by hauerbac         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>

int	ft_ultimate_range(int **range, int min, int max);


void	ft_putnbr(int nb)
{
	long	nb_in_long;
	int		digit_to_char;

	nb_in_long = nb;
	if (nb_in_long < 0)
	{
		write(1, "-", 1);
		nb_in_long = nb_in_long * -1;
	}
	if (nb_in_long < 10)
	{
		digit_to_char = nb_in_long + '0';
		write(1, &digit_to_char, 1);
	}
	else
	{
		ft_putnbr(nb_in_long / 10);
		ft_putnbr(nb_in_long % 10);
	}
}

void	ft_print_int_tab(int *tab, int size)
{
	int	i;

	if (tab != NULL && size > 0)
	{
		write(1, "[", 1);
		i = 0;
		while (i < size)
		{
			ft_putnbr(tab[i]);
			if (i < size - 1)
				write(1, ", ", 2);
			i++;
		}
		write(1, "]", 1);
	}
}

void	ft_print_ptr_int_tab(int **tab, int size)
{
	printf("The returned size of range is %d.\n", size);
	printf("tab = %p\n", tab);
	if (tab != NULL && *tab != NULL && size > 0)
	{
		printf("*tab = %p\n", *tab);
		ft_print_int_tab(*tab, size);
	}
	else if (size == 0)
		printf("\nNone array - Reason : If the value of min is greater or equal to maxâ€™s value, range will point on NULL and it should return 0.");
	else if (size == -1)
		printf("\nIncomplete array - Reason : The size of range should be returned (or -1 on error).");
	else
		printf("\nSegmentation fault - Reason : tab == (nil).");
}

int	main(void)
{
	int	min;
	int	max;
	int	*tab1 = {-1};
	int	tab1_size;
	/*int	*tab2 = {-1};
	int	tab2_size;
	int	*tab3 = {-1};
	int	tab3_size;
	int	*tab4 = {-1};
	int	tab4_size;*/

	min = 3;
	max = 8;
	tab1_size = ft_ultimate_range(&tab1, min, max);
	printf("Pour min = %d et max = %d, tab1 =\n", min, max);
	printf("tab1 = %p\n", tab1);
	ft_print_ptr_int_tab(&tab1, tab1_size);
	//free(*tab1);
	/*free(*ptr);
	free(ptr);*/
	/*min = 42;
	max = 42;
	tab2_size = ft_ultimate_range(tab2, min, max);
	printf("\nPour min = %d et max = %d, tab2 =\n", min, max);
	ft_print_int_tab(*tab2, tab2_size);
	free(*tab2);
	free(tab2);
	min = -42;
	max = 43;
	tab3_size = ft_ultimate_range(tab3, min, max);
	printf("\nPour min = %d et max = %d, tab3 =\n", min, max);
	ft_print_int_tab(*tab3, tab3_size);
	free(*tab3);
	free(tab3);
	min = 42;
	max = -1;
	tab4_size = ft_ultimate_range(tab4, min, max);
	printf("\nPour min = %d et max = %d, tab4 =\n", min, max);
	ft_print_int_tab(*tab4, tab4_size);
	free(*tab4);
	free(tab4);*/
	return (0);
}
e3r11p9% ./test_ft_ultimate_range                                                                      
ptr = 0x5638575f32c0, *ptr = 3, *(ptr + 1) = 4
range = 0x5638575f32a0, *range = 0x5638575f32c0, *(*range + 1) = 4
Pour min = 3 et max = 8, tab1 =
tab1 = (nil)
The returned size of range is 5.
tab = 0x7ffd751f2d00

Segmentation fault - Reason : tab == (nil).%                                                                               
-------------------------------------------------------------------------------------------------------------------------
e3r11p9% cd ../../c_07
e3r11p9% cd ex03
e3r11p9% ls
ft_strjoin.c
e3r11p9% vi ft_strjoin.c 
e3r11p9% cat ft_strjoin.c 
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_strjoin.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: hauerbac <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2023/02/28 12:56:26 by hauerbac          #+#    #+#             */
/*   Updated: 2023/02/28 12:56:31 by hauerbac         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include <stdlib.h>

int	ft_strlen(char *str)
{
	int	i;

	i = 0;
	if (str)
		while (str[i] != '\0')
			i++;
	return (i);
}

char	*ft_strncat_at_index(char *dest, char *src, unsigned int nb, int index)
{
	int		i;
	int		j;

	if (dest && src && nb > 0 && index >= 0)
	{
		i = index;
		j = 0;
		while ((unsigned int) j < nb && src[j] != '\0')
		{
			dest[i] = src[j];
			i++;
			j++;
		}
		dest[i] = '\0';
	}
	return (dest);
}

char	*ft_strjoin(int size, char **strs, char *sep)
{
	char	*result;
	int		i;
	int		j;
	//int		k;
	int		sep_len;
	int		strings_total_len;

	result = NULL;
	if (size > 0 && strs && sep && strs[0])
	{
		strings_total_len = 0;
		i = 0;
		while (i < size && strs[i])
			strings_total_len += ft_strlen(strs[i++]);
		sep_len = ft_strlen(sep);
		result = (char *) malloc((((size - 1) * sep_len) + strings_total_len + 1) * sizeof(char));
		if (!result)
			return (NULL);
		i = 0;
		//k = 0;
		j = 0;
                while (i < size && strs[i])
                {
                        result = ft_strncat_at_index(result, strs[i], ft_strlen(strs[i]), j);
			/*j = 0;
                        while (strs[i][j] && k <= ((size - 1) * sep_len) + strings_total_len)
                        {
                                result[k] = strs[i][j];
                                j++;
				k++;
                        }*/
			j += ft_strlen(strs[i]);
                        if (i != size - 1)
			{
                        	result = ft_strncat_at_index(result, sep, sep_len, j);
				j += sep_len;
				/*j = 0;
	                        while (sep[j] && k <= ((size - 1) * sep_len) + strings_total_len)
        	                {
                	                result[k] = sep[j];
                        	        j++;
					k++;
				}*/
                        }
                        i++;
                }
		if (j < ((size - 1) * sep_len) + strings_total_len + 1)
		//if (k < ((size - 1) * sep_len) + strings_total_len + 1)
			result[j] = '\0';
			//result[k] = '\0';
	}
	else
	{
		result = (char *) malloc(sizeof(char));
		if (result)
			result[0] = '\0';
	}
	return (result);
}
e3r11p9% vi test_ft_strjoin.c 
e3r11p9% cat test_ft_strjoin.c 
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   test_ft_strjoin.c                                  :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: hauerbac <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2023/02/28 13:02:48 by hauerbac          #+#    #+#             */
/*   Updated: 2023/02/28 13:02:55 by hauerbac         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include <stdio.h>

char	*ft_strjoin(int size, char **strs, char *sep);

int	main(int argc, char **argv)
{
	int	i;

	if (argc == 4)
		printf("size == %d, sep == %s => %s\n", argv[1], argv[3], ft_strjoin(argv[1], argv[2], argv[3]));
	return (0);
}
e3r11p9% gcc -Wall -Wextra -Werror -o test_ft_strjoin ft_strjoin.c test_ft_strjoin.c 
test_ft_strjoin.c: In function â€˜mainâ€™:
test_ft_strjoin.c:22:76: error: passing argument 1 of â€˜ft_strjoinâ€™ makes integer from pointer without a cast [-Werror=int-conversion]
   22 |   printf("size == %d, sep == %s => %s\n", argv[1], argv[3], ft_strjoin(argv[1], argv[2], argv[3]));
      |                                                                        ~~~~^~~
      |                                                                            |
      |                                                                            char *
test_ft_strjoin.c:15:22: note: expected â€˜intâ€™ but argument is of type â€˜char *â€™
   15 | char *ft_strjoin(int size, char **strs, char *sep);
      |                  ~~~~^~~~
test_ft_strjoin.c:22:85: error: passing argument 2 of â€˜ft_strjoinâ€™ from incompatible pointer type [-Werror=incompatible-pointer-types]
   22 |   printf("size == %d, sep == %s => %s\n", argv[1], argv[3], ft_strjoin(argv[1], argv[2], argv[3]));
      |                                                                                 ~~~~^~~
      |                                                                                     |
      |                                                                                     char *
test_ft_strjoin.c:15:35: note: expected â€˜char **â€™ but argument is of type â€˜char *â€™
   15 | char *ft_strjoin(int size, char **strs, char *sep);
      |                            ~~~~~~~^~~~
test_ft_strjoin.c:22:20: error: format â€˜%dâ€™ expects argument of type â€˜intâ€™, but argument 2 has type â€˜char *â€™ [-Werror=format=]
   22 |   printf("size == %d, sep == %s => %s\n", argv[1], argv[3], ft_strjoin(argv[1], argv[2], argv[3]));
      |                   ~^                      ~~~~~~~
      |                    |                          |
      |                    int                        char *
      |                   %s
test_ft_strjoin.c:19:6: error: unused variable â€˜iâ€™ [-Werror=unused-variable]
   19 |  int i;
      |      ^
cc1: all warnings being treated as errors
e3r11p9% vi test_ft_strjoin.c                                                      
e3r11p9% cat test_ft_strjoin.c 
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   test_ft_strjoin.c                                  :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: hauerbac <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2023/02/28 13:02:48 by hauerbac          #+#    #+#             */
/*   Updated: 2023/02/28 13:08:04 by hauerbac         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include <stdio.h>

char	*ft_strjoin(int size, char **strs, char *sep);

int	main(int argc, char **argv)
{
	int	i;
	char	*strs[] = {"Toto", " TITUTA  ", "", "42"};

	if (argc == 2)
		printf("size == 4, sep == %s => %s\n", argv[1], ft_strjoin(4, strs, argv[1]));
	return (0);
}
e3r11p9% gcc -Wall -Wextra -Werror -o test_ft_strjoin ft_strjoin.c test_ft_strjoin.c
test_ft_strjoin.c: In function â€˜mainâ€™:
test_ft_strjoin.c:19:6: error: unused variable â€˜iâ€™ [-Werror=unused-variable]
   19 |  int i;
      |      ^
cc1: all warnings being treated as errors
e3r11p9% vi test_ft_strjoin.c                                                      
e3r11p9% cat test_ft_strjoin.c 
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   test_ft_strjoin.c                                  :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: hauerbac <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2023/02/28 13:02:48 by hauerbac          #+#    #+#             */
/*   Updated: 2023/02/28 13:08:22 by hauerbac         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include <stdio.h>

char	*ft_strjoin(int size, char **strs, char *sep);

int	main(int argc, char **argv)
{
	char	*strs[] = {"Toto", " TITUTA  ", "", "42"};

	if (argc == 2)
		printf("size == 4, sep == %s => %s\n", argv[1], ft_strjoin(4, strs, argv[1]));
	return (0);
}
e3r11p9% gcc -Wall -Wextra -Werror -o test_ft_strjoin ft_strjoin.c test_ft_strjoin.c
e3r11p9% ./test_ft_strjoin 
e3r11p9% ./test_ft_strjoin "' "
size == 4, sep == '  => Toto'  TITUTA  ' ' 42
e3r11p9% ./test_ft_strjoin "' " | cat -e
size == 4, sep == '  => Toto'  TITUTA  ' ' 42$
e3r11p9% vi test_ft_strjoin.c                                                      
e3r11p9% cat test_ft_strjoin.c 
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   test_ft_strjoin.c                                  :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: hauerbac <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2023/02/28 13:02:48 by hauerbac          #+#    #+#             */
/*   Updated: 2023/02/28 13:10:53 by hauerbac         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include <stdio.h>

char	*ft_strjoin(int size, char **strs, char *sep);

int	main(int argc, char **argv)
{
	char	*strs[] = {"Toto", " TITUTA  ", "", "42"};

	if (argc == 2)
		printf("size == 4, sep == %s => %s\n", argv[1], ft_strjoin(4, strs, argv[1]));
		printf("size == 0, sep == %s => %s\n", argv[1], ft_strjoin(0, strs, argv[1]));
	return (0);
}
e3r11p9% norminette -R test_ft_strjoin.c
ft_strjoin.c: Error!
Error: WRONG_SCOPE_COMMENT  (line:  51, col:   5):	Comment is invalid in this scope
Error: VAR_DECL_START_FUNC  (line:  52, col:   1):	Variable declaration not at start of function
Error: VAR_DECL_START_FUNC  (line:  53, col:   1):	Variable declaration not at start of function
Error: LINE_TOO_LONG        (line:  63, col:  82):	line too long
Error: WRONG_SCOPE_COMMENT  (line:  67, col:   9):	Comment is invalid in this scope
Error: TOO_FEW_TAB          (line:  69, col:   1):	Missing tabs for indent level
Error: SPACE_REPLACE_TAB    (line:  69, col:  17):	Found space when expecting tab
Error: TOO_FEW_TAB          (line:  70, col:   1):	Missing tabs for indent level
Error: SPACE_EMPTY_LINE     (line:  70, col:  17):	Space on empty line
Error: SPACE_REPLACE_TAB    (line:  71, col:  25):	Found space when expecting tab
Error: LINE_TOO_LONG        (line:  71, col:  85):	line too long
Error: LINE_TOO_LONG        (line:  72, col:   1):	line too long
Error: WRONG_SCOPE_COMMENT  (line:  72, col:  13):	Comment is invalid in this scope
Error: TOO_FEW_TAB          (line:  80, col:   1):	Missing tabs for indent level
Error: SPACE_REPLACE_TAB    (line:  80, col:  25):	Found space when expecting tab
Error: SPACE_REPLACE_TAB    (line:  82, col:  25):	Found space when expecting tab
Error: LINE_TOO_LONG        (line:  82, col:  82):	line too long
Error: LINE_TOO_LONG        (line:  84, col:   1):	line too long
Error: WRONG_SCOPE_COMMENT  (line:  84, col:  17):	Comment is invalid in this scope
Error: TOO_FEW_TAB          (line:  91, col:   1):	Missing tabs for indent level
Error: SPACE_EMPTY_LINE     (line:  91, col:  25):	Space on empty line
Error: SPACE_REPLACE_TAB    (line:  92, col:  25):	Found space when expecting tab
Error: TOO_FEW_TAB          (line:  93, col:   1):	Missing tabs for indent level
Error: SPACE_EMPTY_LINE     (line:  93, col:  17):	Space on empty line
Error: WRONG_SCOPE_COMMENT  (line:  95, col:   9):	Comment is invalid in this scope
Error: WRONG_SCOPE_COMMENT  (line:  97, col:  13):	Comment is invalid in this scope
Error: TOO_MANY_LINES       (line: 106, col:   1):	Function has more than 25 lines
test_ft_strjoin.c: Error!
Error: DECL_ASSIGN_LINE     (line:  19, col:  21):	Declaration and assignation on a single line
Error: LINE_TOO_LONG        (line:  22, col:  82):	line too long
Error: TOO_MANY_TAB         (line:  23, col:   1):	Extra tabs for indent level
Error: LINE_TOO_LONG        (line:  23, col:  82):	line too long
e3r11p9% vi test_ft_strjoin.c          
e3r11p9% vi ft_strjoin.c 
e3r11p9% cat ft_strjoin.c 
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_strjoin.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: hauerbac <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2023/02/28 12:56:26 by hauerbac          #+#    #+#             */
/*   Updated: 2023/02/28 13:24:36 by hauerbac         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include <stdlib.h>

int	ft_strlen(char *str)
{
	int	i;

	i = 0;
	if (str)
		while (str[i] != '\0')
			i++;
	return (i);
}

char	*ft_strncat_at_index(char *dest, char *src, unsigned int nb, int index)
{
	int		i;
	int		j;

	if (dest && src && nb > 0 && index >= 0)
	{
		i = index;
		j = 0;
		while ((unsigned int) j < nb && src[j] != '\0')
		{
			dest[i] = src[j];
			i++;
			j++;
		}
		dest[i] = '\0';
	}
	return (dest);
}

char	*ft_cat_strs(int size, char **strs, char *sep, int strings_total_len, int sep_len)
{
	char	*result;
	int		i;
	int		j;
	
	result = (char *) malloc((((size - 1) * sep_len) + strings_total_len + 1)
		* sizeof(char));
	if (!result)
		return (NULL);
	i = 0;
	j = 0;
	while (i < size && strs[i])
	{
		result = ft_strncat_at_index(result, strs[i], ft_strlen(strs[i]), j);
		j += ft_strlen(strs[i]);
		if (i != size - 1)
		{
			result = ft_strncat_at_index(result, sep, sep_len, j);
			j += sep_len;
		}
		i++;
	}
	if (j < ((size - 1) * sep_len) + strings_total_len + 1)
		result[j] = '\0';
	return (result);
}

char	*ft_strjoin(int size, char **strs, char *sep)
{
	char	*result;
	int		i;
	int		j;
	int		sep_len;
	int		strings_total_len;

	result = NULL;
	if (size > 0 && strs && sep && strs[0])
	{
		strings_total_len = 0;
		i = 0;
		while (i < size && strs[i])
			strings_total_len += ft_strlen(strs[i++]);
		sep_len = ft_strlen(sep);
		result = ft_cat_strs(size, strs, sep, strings_total_len, sep_len);
	}
	else
	{
		result = (char *) malloc(sizeof(char));
		if (result)
			result[0] = '\0';
	}
	return (result);
}
e3r11p9% norminette -R ft_strjoin.c 
ft_strjoin.c: Error!
Error: LINE_TOO_LONG        (line:  46, col:  82):	line too long
Error: TOO_MANY_ARGS        (line:  46, col:  91):	Function has more than 4 arguments
Error: SPACE_EMPTY_LINE     (line:  51, col:   1):	Space on empty line
Error: TOO_FEW_TAB          (line:  53, col:   1):	Missing tabs for indent level
test_ft_strjoin.c: Error!
Error: DECL_ASSIGN_LINE     (line:  19, col:  21):	Declaration and assignation on a single line
Error: LINE_TOO_LONG        (line:  22, col:  82):	line too long
Error: TOO_MANY_TAB         (line:  23, col:   1):	Extra tabs for indent level
Error: LINE_TOO_LONG        (line:  23, col:  82):	line too long
e3r11p9% vi ft_strjoin.c          
e3r11p9% cat ft_strjoin.c 
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_strjoin.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: hauerbac <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2023/02/28 12:56:26 by hauerbac          #+#    #+#             */
/*   Updated: 2023/02/28 13:39:56 by hauerbac         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include <stdlib.h>

int	ft_strlen(char *str)
{
	int	i;

	i = 0;
	if (str)
		while (str[i] != '\0')
			i++;
	return (i);
}

char	*ft_strncat_at_index(char *dest, char *src, unsigned int nb, int index)
{
	int		i;
	int		j;

	if (dest && src && nb > 0 && index >= 0)
	{
		i = index;
		j = 0;
		while ((unsigned int) j < nb && src[j] != '\0')
		{
			dest[i] = src[j];
			i++;
			j++;
		}
		dest[i] = '\0';
	}
	return (dest);
}

char	*ft_cat_strs(int size, char **strs, char *sep, char *result)
{
	int	sep_len;
	int	i;
	int	j;
	
	sep_len = ft_strlen(sep);
	i = 0;
	j = 0;
	while (i < size && strs[i])
	{
		result = ft_strncat_at_index(result, strs[i], ft_strlen(strs[i]), j);
		j += ft_strlen(strs[i]);
		if (i != size - 1)
		{
			result = ft_strncat_at_index(result, sep, sep_len, j);
			j += sep_len;
		}
		i++;
	}
	if (j < ft_strlen(result))
		result[j] = '\0';
	return (result);
}

char	*ft_strjoin(int size, char **strs, char *sep)
{
	char	*result;
	int		i;
	int		j;
	int		sep_len;
	int		strings_total_len;

	result = (char *) malloc(sizeof(char));
	if (result)
		result[0] = '\0';
	if (size > 0 && strs && sep && strs[0])
	{
		strings_total_len = 0;
		i = 0;
		while (i < size && strs[i])
			strings_total_len += ft_strlen(strs[i++]);
		sep_len = ft_strlen(sep);
		if (result)
			free(result);
		result = (char *) malloc((((size - 1) * sep_len) + strings_total_len + 1)
			* sizeof(char));
		if (!result)
			return (NULL);
		result = ft_cat_strs(size, strs, sep, result);
	}
	return (result);
}
e3r11p9% norminette -R ft_strjoin.c
ft_strjoin.c: Error!
Error: SPACE_EMPTY_LINE     (line:  51, col:   1):	Space on empty line
Error: LINE_TOO_LONG        (line:  91, col:  82):	line too long
Error: TOO_FEW_TAB          (line:  92, col:   1):	Missing tabs for indent level
test_ft_strjoin.c: Error!
Error: DECL_ASSIGN_LINE     (line:  19, col:  21):	Declaration and assignation on a single line
Error: LINE_TOO_LONG        (line:  22, col:  82):	line too long
Error: TOO_MANY_TAB         (line:  23, col:   1):	Extra tabs for indent level
Error: LINE_TOO_LONG        (line:  23, col:  82):	line too long
e3r11p9% vi ft_strjoin.c          
e3r11p9% cat ft_strjoin.c          
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_strjoin.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: hauerbac <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2023/02/28 12:56:26 by hauerbac          #+#    #+#             */
/*   Updated: 2023/02/28 13:42:36 by hauerbac         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include <stdlib.h>

int	ft_strlen(char *str)
{
	int	i;

	i = 0;
	if (str)
		while (str[i] != '\0')
			i++;
	return (i);
}

char	*ft_strncat_at_index(char *dest, char *src, unsigned int nb, int index)
{
	int		i;
	int		j;

	if (dest && src && nb > 0 && index >= 0)
	{
		i = index;
		j = 0;
		while ((unsigned int) j < nb && src[j] != '\0')
		{
			dest[i] = src[j];
			i++;
			j++;
		}
		dest[i] = '\0';
	}
	return (dest);
}

char	*ft_cat_strs(int size, char **strs, char *sep, char *result)
{
	int	sep_len;
	int	i;
	int	j;

	sep_len = ft_strlen(sep);
	i = 0;
	j = 0;
	while (i < size && strs[i])
	{
		result = ft_strncat_at_index(result, strs[i], ft_strlen(strs[i]), j);
		j += ft_strlen(strs[i]);
		if (i != size - 1)
		{
			result = ft_strncat_at_index(result, sep, sep_len, j);
			j += sep_len;
		}
		i++;
	}
	if (j < ft_strlen(result))
		result[j] = '\0';
	return (result);
}

char	*ft_strjoin(int size, char **strs, char *sep)
{
	char	*result;
	int		i;
	int		j;
	int		sep_len;
	int		strings_total_len;

	result = (char *) malloc(sizeof(char));
	if (result)
		result[0] = '\0';
	if (size > 0 && strs && sep && strs[0])
	{
		strings_total_len = 0;
		i = 0;
		while (i < size && strs[i])
			strings_total_len += ft_strlen(strs[i++]);
		sep_len = ft_strlen(sep);
		if (result)
			free(result);
		result = (char *) malloc((((size - 1) * sep_len)
			+ strings_total_len + 1) * sizeof(char));
		if (!result)
			return (NULL);
		result = ft_cat_strs(size, strs, sep, result);
	}
	return (result);
}
e3r11p9% norminette -R ft_strjoin.c
ft_strjoin.c: Error!
Error: TOO_FEW_TAB          (line:  92, col:   1):	Missing tabs for indent level
test_ft_strjoin.c: Error!
Error: DECL_ASSIGN_LINE     (line:  19, col:  21):	Declaration and assignation on a single line
Error: LINE_TOO_LONG        (line:  22, col:  82):	line too long
Error: TOO_MANY_TAB         (line:  23, col:   1):	Extra tabs for indent level
Error: LINE_TOO_LONG        (line:  23, col:  82):	line too long
e3r11p9% vi ft_strjoin.c          
e3r11p9% cat ft_strjoin.c 
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_strjoin.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: hauerbac <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2023/02/28 12:56:26 by hauerbac          #+#    #+#             */
/*   Updated: 2023/02/28 13:43:27 by hauerbac         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include <stdlib.h>

int	ft_strlen(char *str)
{
	int	i;

	i = 0;
	if (str)
		while (str[i] != '\0')
			i++;
	return (i);
}

char	*ft_strncat_at_index(char *dest, char *src, unsigned int nb, int index)
{
	int		i;
	int		j;

	if (dest && src && nb > 0 && index >= 0)
	{
		i = index;
		j = 0;
		while ((unsigned int) j < nb && src[j] != '\0')
		{
			dest[i] = src[j];
			i++;
			j++;
		}
		dest[i] = '\0';
	}
	return (dest);
}

char	*ft_cat_strs(int size, char **strs, char *sep, char *result)
{
	int	sep_len;
	int	i;
	int	j;

	sep_len = ft_strlen(sep);
	i = 0;
	j = 0;
	while (i < size && strs[i])
	{
		result = ft_strncat_at_index(result, strs[i], ft_strlen(strs[i]), j);
		j += ft_strlen(strs[i]);
		if (i != size - 1)
		{
			result = ft_strncat_at_index(result, sep, sep_len, j);
			j += sep_len;
		}
		i++;
	}
	if (j < ft_strlen(result))
		result[j] = '\0';
	return (result);
}

char	*ft_strjoin(int size, char **strs, char *sep)
{
	char	*result;
	int		i;
	int		j;
	int		sep_len;
	int		strings_total_len;

	result = (char *) malloc(sizeof(char));
	if (result)
		result[0] = '\0';
	if (size > 0 && strs && sep && strs[0])
	{
		strings_total_len = 0;
		i = 0;
		while (i < size && strs[i])
			strings_total_len += ft_strlen(strs[i++]);
		sep_len = ft_strlen(sep);
		if (result)
			free(result);
		result = (char *) malloc((((size - 1) * sep_len)
				+ strings_total_len + 1) * sizeof(char));
		if (!result)
			return (NULL);
		result = ft_cat_strs(size, strs, sep, result);
	}
	return (result);
}
e3r11p9% vi test_ft_strjoin.c
e3r11p9% cat test_ft_strjoin.c 
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   test_ft_strjoin.c                                  :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: hauerbac <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2023/02/28 13:02:48 by hauerbac          #+#    #+#             */
/*   Updated: 2023/02/28 13:44:37 by hauerbac         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include <stdio.h>

char	*ft_strjoin(int size, char **strs, char *sep);

int	main(int argc, char **argv)
{
	char	*strs[] = {"Toto", " TITUTA  ", "", "42"};

	if (argc == 2)
	{
		printf("size == 4, sep == %s => %s\n", argv[1],
			ft_strjoin(4, strs, argv[1]));
		printf("size == 0, sep == %s => %s\n", argv[1],
			ft_strjoin(0, strs, argv[1]));
	}
	return (0);
}
e3r11p9% norminette -R ft_strjoin.c
ft_strjoin.c: Error!
Error: TOO_FEW_TAB          (line:  92, col:   1):	Missing tabs for indent level
test_ft_strjoin.c: Error!
Error: DECL_ASSIGN_LINE     (line:  19, col:  21):	Declaration and assignation on a single line
e3r11p9% vi ft_strjoin.c     
e3r11p9% cat ft_strjoin.c     
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_strjoin.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: hauerbac <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2023/02/28 12:56:26 by hauerbac          #+#    #+#             */
/*   Updated: 2023/02/28 13:46:29 by hauerbac         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include <stdlib.h>

int	ft_strlen(char *str)
{
	int	i;

	i = 0;
	if (str)
		while (str[i] != '\0')
			i++;
	return (i);
}

char	*ft_strncat_at_index(char *dest, char *src, unsigned int nb, int index)
{
	int		i;
	int		j;

	if (dest && src && nb > 0 && index >= 0)
	{
		i = index;
		j = 0;
		while ((unsigned int) j < nb && src[j] != '\0')
		{
			dest[i] = src[j];
			i++;
			j++;
		}
		dest[i] = '\0';
	}
	return (dest);
}

char	*ft_cat_strs(int size, char **strs, char *sep, char *result)
{
	int	sep_len;
	int	i;
	int	j;

	sep_len = ft_strlen(sep);
	i = 0;
	j = 0;
	while (i < size && strs[i])
	{
		result = ft_strncat_at_index(result, strs[i], ft_strlen(strs[i]), j);
		j += ft_strlen(strs[i]);
		if (i != size - 1)
		{
			result = ft_strncat_at_index(result, sep, sep_len, j);
			j += sep_len;
		}
		i++;
	}
	if (j < ft_strlen(result))
		result[j] = '\0';
	return (result);
}

char	*ft_strjoin(int size, char **strs, char *sep)
{
	char	*result;
	int		i;
	int		j;
	int		sep_len;
	int		strings_total_len;

	result = (char *) malloc(sizeof(char));
	if (result)
		result[0] = '\0';
	if (size > 0 && strs && sep && strs[0])
	{
		strings_total_len = 0;
		i = 0;
		while (i < size && strs[i])
			strings_total_len += ft_strlen(strs[i++]);
		sep_len = ft_strlen(sep);
		if (result)
			free(result);
		result = (char *) malloc((((size - 1) * sep_len)
					+ strings_total_len + 1) * sizeof(char));
		if (!result)
			return (NULL);
		result = ft_cat_strs(size, strs, sep, result);
	}
	return (result);
}
e3r11p9% norminette -R ft_strjoin.c
ft_strjoin.c: OK!
test_ft_strjoin.c: Error!
Error: DECL_ASSIGN_LINE     (line:  19, col:  21):	Declaration and assignation on a single line
e3r11p9% gcc -Wall -Wextra -Werror -o test_ft_strjoin ft_strjoin.c test_ft_strjoin.c
ft_strjoin.c: In function â€˜ft_strjoinâ€™:
ft_strjoin.c:75:7: error: unused variable â€˜jâ€™ [-Werror=unused-variable]
   75 |  int  j;
      |       ^
cc1: all warnings being treated as errors
e3r11p9% vi ft_strjoin.c                                                 
e3r11p9% cat ft_strjoin.c                                                 
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_strjoin.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: hauerbac <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2023/02/28 12:56:26 by hauerbac          #+#    #+#             */
/*   Updated: 2023/02/28 13:47:25 by hauerbac         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include <stdlib.h>

int	ft_strlen(char *str)
{
	int	i;

	i = 0;
	if (str)
		while (str[i] != '\0')
			i++;
	return (i);
}

char	*ft_strncat_at_index(char *dest, char *src, unsigned int nb, int index)
{
	int		i;
	int		j;

	if (dest && src && nb > 0 && index >= 0)
	{
		i = index;
		j = 0;
		while ((unsigned int) j < nb && src[j] != '\0')
		{
			dest[i] = src[j];
			i++;
			j++;
		}
		dest[i] = '\0';
	}
	return (dest);
}

char	*ft_cat_strs(int size, char **strs, char *sep, char *result)
{
	int	sep_len;
	int	i;
	int	j;

	sep_len = ft_strlen(sep);
	i = 0;
	j = 0;
	while (i < size && strs[i])
	{
		result = ft_strncat_at_index(result, strs[i], ft_strlen(strs[i]), j);
		j += ft_strlen(strs[i]);
		if (i != size - 1)
		{
			result = ft_strncat_at_index(result, sep, sep_len, j);
			j += sep_len;
		}
		i++;
	}
	if (j < ft_strlen(result))
		result[j] = '\0';
	return (result);
}

char	*ft_strjoin(int size, char **strs, char *sep)
{
	char	*result;
	int		i;
	int		sep_len;
	int		strings_total_len;

	result = (char *) malloc(sizeof(char));
	if (result)
		result[0] = '\0';
	if (size > 0 && strs && sep && strs[0])
	{
		strings_total_len = 0;
		i = 0;
		while (i < size && strs[i])
			strings_total_len += ft_strlen(strs[i++]);
		sep_len = ft_strlen(sep);
		if (result)
			free(result);
		result = (char *) malloc((((size - 1) * sep_len)
					+ strings_total_len + 1) * sizeof(char));
		if (!result)
			return (NULL);
		result = ft_cat_strs(size, strs, sep, result);
	}
	return (result);
}
e3r11p9% norminette -R ft_strjoin.c                                                 
ft_strjoin.c: OK!
test_ft_strjoin.c: Error!
Error: DECL_ASSIGN_LINE     (line:  19, col:  21):	Declaration and assignation on a single line
e3r11p9% gcc -Wall -Wextra -Werror -o test_ft_strjoin ft_strjoin.c test_ft_strjoin.c
e3r11p9% ls -al                                                                     
total 32
drwxr-xr-x 2 hauerbac 2023_paris  4096 Feb 28 13:47 .
drwxr-xr-x 6 hauerbac 2023_paris  4096 Feb 28 09:26 ..
-rw-r--r-- 1 hauerbac 2023_paris  2380 Feb 28 13:47 ft_strjoin.c
-rwxr-xr-x 1 hauerbac 2023_paris 16280 Feb 28 13:47 test_ft_strjoin
-rw-r--r-- 1 hauerbac 2023_paris  1254 Feb 28 13:44 test_ft_strjoin.c
e3r11p9% ./test_ft_strjoin "-'-" | cat -e 
size == 4, sep == -'- => Toto-'- TITUTA  -'--'-42$
size == 0, sep == -'- => $
--------------------------------------------------------------------------------------------------------------------------------------
e3r11p9% cd ~/c_07/ex02
e3r11p9% ls
ft_ultimate_range_0.c  ft_ultimate_range.c  test_ft_ultimate_range  test_ft_ultimate_range.c
e3r11p9% cat test_ft_ultimate_range.c
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   test_ft_ultimate_range.c                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: hauerbac <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2023/02/22 17:56:00 by hauerbac          #+#    #+#             */
/*   Updated: 2023/02/27 19:57:50 by hauerbac         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>

int	ft_ultimate_range(int **range, int min, int max);


void	ft_putnbr(int nb)
{
	long	nb_in_long;
	int		digit_to_char;

	nb_in_long = nb;
	if (nb_in_long < 0)
	{
		write(1, "-", 1);
		nb_in_long = nb_in_long * -1;
	}
	if (nb_in_long < 10)
	{
		digit_to_char = nb_in_long + '0';
		write(1, &digit_to_char, 1);
	}
	else
	{
		ft_putnbr(nb_in_long / 10);
		ft_putnbr(nb_in_long % 10);
	}
}

void	ft_print_int_tab(int *tab, int size)
{
	int	i;

	if (tab != NULL && size > 0)
	{
		write(1, "[", 1);
		i = 0;
		while (i < size)
		{
			ft_putnbr(tab[i]);
			if (i < size - 1)
				write(1, ", ", 2);
			i++;
		}
		write(1, "]", 1);
	}
}

void	ft_print_ptr_int_tab(int **tab, int size)
{
	printf("The returned size of range is %d.\n", size);
	printf("tab = %p\n", tab);
	if (tab != NULL && *tab != NULL && size > 0)
	{
		printf("*tab = %p\n", *tab);
		ft_print_int_tab(*tab, size);
	}
	else if (size == 0)
		printf("\nNone array - Reason : If the value of min is greater or equal to maxâ€™s value, range will point on NULL and it should return 0.");
	else if (size == -1)
		printf("\nIncomplete array - Reason : The size of range should be returned (or -1 on error).");
	else
		printf("\nSegmentation fault - Reason : tab == (nil).");
}

int	main(void)
{
	int	min;
	int	max;
	int	*tab1 = {-1};
	int	tab1_size;
	/*int	*tab2 = {-1};
	int	tab2_size;
	int	*tab3 = {-1};
	int	tab3_size;
	int	*tab4 = {-1};
	int	tab4_size;*/

	min = 3;
	max = 8;
	tab1_size = ft_ultimate_range(&tab1, min, max);
	printf("Pour min = %d et max = %d, tab1 =\n", min, max);
	printf("tab1 = %p\n", tab1);
	ft_print_ptr_int_tab(&tab1, tab1_size);
	//free(*tab1);
	/*free(*ptr);
	free(ptr);*/
	/*min = 42;
	max = 42;
	tab2_size = ft_ultimate_range(tab2, min, max);
	printf("\nPour min = %d et max = %d, tab2 =\n", min, max);
	ft_print_int_tab(*tab2, tab2_size);
	free(*tab2);
	free(tab2);
	min = -42;
	max = 43;
	tab3_size = ft_ultimate_range(tab3, min, max);
	printf("\nPour min = %d et max = %d, tab3 =\n", min, max);
	ft_print_int_tab(*tab3, tab3_size);
	free(*tab3);
	free(tab3);
	min = 42;
	max = -1;
	tab4_size = ft_ultimate_range(tab4, min, max);
	printf("\nPour min = %d et max = %d, tab4 =\n", min, max);
	ft_print_int_tab(*tab4, tab4_size);
	free(*tab4);
	free(tab4);*/
	return (0);
}
e3r11p9% vi test_ft_ultimate_range.c 
e3r11p9% cat test_ft_ultimate_range.c 
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   test_ft_ultimate_range.c                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: hauerbac <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2023/02/22 17:56:00 by hauerbac          #+#    #+#             */
/*   Updated: 2023/02/28 14:33:46 by hauerbac         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>

int	ft_ultimate_range(int **range, int min, int max);


void	ft_putnbr(int nb)
{
	long	nb_in_long;
	int		digit_to_char;

	nb_in_long = nb;
	if (nb_in_long < 0)
	{
		write(1, "-", 1);
		nb_in_long = nb_in_long * -1;
	}
	if (nb_in_long < 10)
	{
		digit_to_char = nb_in_long + '0';
		write(1, &digit_to_char, 1);
	}
	else
	{
		ft_putnbr(nb_in_long / 10);
		ft_putnbr(nb_in_long % 10);
	}
}

void	ft_print_int_tab(int *tab, int size)
{
	int	i;

	if (tab != NULL && size > 0)
	{
		write(1, "[", 1);
		i = 0;
		while (i < size)
		{
			ft_putnbr(tab[i]);
			if (i < size - 1)
				write(1, ", ", 2);
			i++;
		}
		write(1, "]", 1);
	}
}

void	ft_print_int_tab_with_size(int *tab, int size)
{
	printf("The returned size of range is %d.\n", size);
	printf("tab = %p\n", tab);
	if (tab != NULL && size > 0)
		ft_print_int_tab(tab, size);
	else if (size == 0)
		printf("\nNone array - Reason : If the value of min is greater or equal to maxâ€™s value, range will point on NULL and it should return 0.");
	else if (size == -1)
		printf("\nIncomplete array - Reason : The size of range should be returned (or -1 on error).");
	else
		printf("\nSegmentation fault - Reason : tab == (nil).");
}

int	main(void)
{
	int	min;
	int	max;
	int	*tab1 = {-1};
	int	tab1_size;
	/*int	*tab2 = {-1};
	int	tab2_size;
	int	*tab3 = {-1};
	int	tab3_size;
	int	*tab4 = {-1};
	int	tab4_size;*/

	min = 3;
	max = 8;
	tab1_size = ft_ultimate_range(&tab1, min, max);
	printf("Pour min = %d et max = %d, tab1 =\n", min, max);
	printf("tab1 = %p\n", tab1);
	ft_print_int_tab_with_size(tab1, tab1_size);
	//free(*tab1);
	/*free(*ptr);
	free(ptr);*/
	/*min = 42;
	max = 42;
	tab2_size = ft_ultimate_range(tab2, min, max);
	printf("\nPour min = %d et max = %d, tab2 =\n", min, max);
	ft_print_int_tab(*tab2, tab2_size);
	free(*tab2);
	free(tab2);
	min = -42;
	max = 43;
	tab3_size = ft_ultimate_range(tab3, min, max);
	printf("\nPour min = %d et max = %d, tab3 =\n", min, max);
	ft_print_int_tab(*tab3, tab3_size);
	free(*tab3);
	free(tab3);
	min = 42;
	max = -1;
	tab4_size = ft_ultimate_range(tab4, min, max);
	printf("\nPour min = %d et max = %d, tab4 =\n", min, max);
	ft_print_int_tab(*tab4, tab4_size);
	free(*tab4);
	free(tab4);*/
	return (0);
}
e3r11p9% gcc -Wall -Wextra -Werror -o test_ft_ultimate_range ft_ultimate_range.c test_ft_ultimate_range.c 
test_ft_ultimate_range.c: In function â€˜mainâ€™:
test_ft_ultimate_range.c:80:15: error: initialization of â€˜int *â€™ from â€˜intâ€™ makes pointer from integer without a cast [-Werror=int-conversion]
   80 |  int *tab1 = {-1};
      |               ^
test_ft_ultimate_range.c:80:15: note: (near initialization for â€˜tab1â€™)
cc1: all warnings being treated as errors
e3r11p9% vi test_ft_ultimate_range.c                                                                    
e3r11p9% cat test_ft_ultimate_range.c                                                                    
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   test_ft_ultimate_range.c                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: hauerbac <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2023/02/22 17:56:00 by hauerbac          #+#    #+#             */
/*   Updated: 2023/02/28 14:34:57 by hauerbac         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>

int	ft_ultimate_range(int **range, int min, int max);


void	ft_putnbr(int nb)
{
	long	nb_in_long;
	int		digit_to_char;

	nb_in_long = nb;
	if (nb_in_long < 0)
	{
		write(1, "-", 1);
		nb_in_long = nb_in_long * -1;
	}
	if (nb_in_long < 10)
	{
		digit_to_char = nb_in_long + '0';
		write(1, &digit_to_char, 1);
	}
	else
	{
		ft_putnbr(nb_in_long / 10);
		ft_putnbr(nb_in_long % 10);
	}
}

void	ft_print_int_tab(int *tab, int size)
{
	int	i;

	if (tab != NULL && size > 0)
	{
		write(1, "[", 1);
		i = 0;
		while (i < size)
		{
			ft_putnbr(tab[i]);
			if (i < size - 1)
				write(1, ", ", 2);
			i++;
		}
		write(1, "]", 1);
	}
}

void	ft_print_int_tab_with_size(int *tab, int size)
{
	printf("The returned size of range is %d.\n", size);
	printf("tab = %p\n", tab);
	if (tab != NULL && size > 0)
		ft_print_int_tab(tab, size);
	else if (size == 0)
		printf("\nNone array - Reason : If the value of min is greater or equal to maxâ€™s value, range will point on NULL and it should return 0.");
	else if (size == -1)
		printf("\nIncomplete array - Reason : The size of range should be returned (or -1 on error).");
	else
		printf("\nSegmentation fault - Reason : tab == (nil).");
}

int	main(void)
{
	int	min;
	int	max;
	int	*tab1 = {(int) -1};
	int	tab1_size;
	/*int	*tab2 = {-1};
	int	tab2_size;
	int	*tab3 = {-1};
	int	tab3_size;
	int	*tab4 = {-1};
	int	tab4_size;*/

	min = 3;
	max = 8;
	tab1_size = ft_ultimate_range(&tab1, min, max);
	printf("Pour min = %d et max = %d, tab1 =\n", min, max);
	printf("tab1 = %p\n", tab1);
	ft_print_int_tab_with_size(tab1, tab1_size);
	//free(*tab1);
	/*free(*ptr);
	free(ptr);*/
	/*min = 42;
	max = 42;
	tab2_size = ft_ultimate_range(tab2, min, max);
	printf("\nPour min = %d et max = %d, tab2 =\n", min, max);
	ft_print_int_tab(*tab2, tab2_size);
	free(*tab2);
	free(tab2);
	min = -42;
	max = 43;
	tab3_size = ft_ultimate_range(tab3, min, max);
	printf("\nPour min = %d et max = %d, tab3 =\n", min, max);
	ft_print_int_tab(*tab3, tab3_size);
	free(*tab3);
	free(tab3);
	min = 42;
	max = -1;
	tab4_size = ft_ultimate_range(tab4, min, max);
	printf("\nPour min = %d et max = %d, tab4 =\n", min, max);
	ft_print_int_tab(*tab4, tab4_size);
	free(*tab4);
	free(tab4);*/
	return (0);
}
e3r11p9% gcc -Wall -Wextra -Werror -o test_ft_ultimate_range ft_ultimate_range.c test_ft_ultimate_range.c
test_ft_ultimate_range.c: In function â€˜mainâ€™:
test_ft_ultimate_range.c:80:15: error: initialization of â€˜int *â€™ from â€˜intâ€™ makes pointer from integer without a cast [-Werror=int-conversion]
   80 |  int *tab1 = {(int) -1};
      |               ^
test_ft_ultimate_range.c:80:15: note: (near initialization for â€˜tab1â€™)
cc1: all warnings being treated as errors
e3r11p9% vi test_ft_ultimate_range.c                                                                    
e3r11p9% cat test_ft_ultimate_range.c                                                                    
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   test_ft_ultimate_range.c                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: hauerbac <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2023/02/22 17:56:00 by hauerbac          #+#    #+#             */
/*   Updated: 2023/02/28 14:35:35 by hauerbac         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>

int	ft_ultimate_range(int **range, int min, int max);


void	ft_putnbr(int nb)
{
	long	nb_in_long;
	int		digit_to_char;

	nb_in_long = nb;
	if (nb_in_long < 0)
	{
		write(1, "-", 1);
		nb_in_long = nb_in_long * -1;
	}
	if (nb_in_long < 10)
	{
		digit_to_char = nb_in_long + '0';
		write(1, &digit_to_char, 1);
	}
	else
	{
		ft_putnbr(nb_in_long / 10);
		ft_putnbr(nb_in_long % 10);
	}
}

void	ft_print_int_tab(int *tab, int size)
{
	int	i;

	if (tab != NULL && size > 0)
	{
		write(1, "[", 1);
		i = 0;
		while (i < size)
		{
			ft_putnbr(tab[i]);
			if (i < size - 1)
				write(1, ", ", 2);
			i++;
		}
		write(1, "]", 1);
	}
}

void	ft_print_int_tab_with_size(int *tab, int size)
{
	printf("The returned size of range is %d.\n", size);
	printf("tab = %p\n", tab);
	if (tab != NULL && size > 0)
		ft_print_int_tab(tab, size);
	else if (size == 0)
		printf("\nNone array - Reason : If the value of min is greater or equal to maxâ€™s value, range will point on NULL and it should return 0.");
	else if (size == -1)
		printf("\nIncomplete array - Reason : The size of range should be returned (or -1 on error).");
	else
		printf("\nSegmentation fault - Reason : tab == (nil).");
}

int	main(void)
{
	int	min;
	int	max;
	int	tab1[] = {-1};
	int	tab1_size;
	/*int	*tab2 = {-1};
	int	tab2_size;
	int	*tab3 = {-1};
	int	tab3_size;
	int	*tab4 = {-1};
	int	tab4_size;*/

	min = 3;
	max = 8;
	tab1_size = ft_ultimate_range(&tab1, min, max);
	printf("Pour min = %d et max = %d, tab1 =\n", min, max);
	printf("tab1 = %p\n", tab1);
	ft_print_int_tab_with_size(tab1, tab1_size);
	//free(*tab1);
	/*free(*ptr);
	free(ptr);*/
	/*min = 42;
	max = 42;
	tab2_size = ft_ultimate_range(tab2, min, max);
	printf("\nPour min = %d et max = %d, tab2 =\n", min, max);
	ft_print_int_tab(*tab2, tab2_size);
	free(*tab2);
	free(tab2);
	min = -42;
	max = 43;
	tab3_size = ft_ultimate_range(tab3, min, max);
	printf("\nPour min = %d et max = %d, tab3 =\n", min, max);
	ft_print_int_tab(*tab3, tab3_size);
	free(*tab3);
	free(tab3);
	min = 42;
	max = -1;
	tab4_size = ft_ultimate_range(tab4, min, max);
	printf("\nPour min = %d et max = %d, tab4 =\n", min, max);
	ft_print_int_tab(*tab4, tab4_size);
	free(*tab4);
	free(tab4);*/
	return (0);
}
e3r11p9% gcc -Wall -Wextra -Werror -o test_ft_ultimate_range ft_ultimate_range.c test_ft_ultimate_range.c
test_ft_ultimate_range.c: In function â€˜mainâ€™:
test_ft_ultimate_range.c:91:32: error: passing argument 1 of â€˜ft_ultimate_rangeâ€™ from incompatible pointer type [-Werror=incompatible-pointer-types]
   91 |  tab1_size = ft_ultimate_range(&tab1, min, max);
      |                                ^~~~~
      |                                |
      |                                int (*)[1]
test_ft_ultimate_range.c:17:29: note: expected â€˜int **â€™ but argument is of type â€˜int (*)[1]â€™
   17 | int ft_ultimate_range(int **range, int min, int max);
      |                       ~~~~~~^~~~~
cc1: all warnings being treated as errors
e3r11p9% vi test_ft_ultimate_range.c                                                                    
e3r11p9% cat test_ft_ultimate_range.c                                                                    
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   test_ft_ultimate_range.c                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: hauerbac <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2023/02/22 17:56:00 by hauerbac          #+#    #+#             */
/*   Updated: 2023/02/28 14:36:07 by hauerbac         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>

int	ft_ultimate_range(int **range, int min, int max);


void	ft_putnbr(int nb)
{
	long	nb_in_long;
	int		digit_to_char;

	nb_in_long = nb;
	if (nb_in_long < 0)
	{
		write(1, "-", 1);
		nb_in_long = nb_in_long * -1;
	}
	if (nb_in_long < 10)
	{
		digit_to_char = nb_in_long + '0';
		write(1, &digit_to_char, 1);
	}
	else
	{
		ft_putnbr(nb_in_long / 10);
		ft_putnbr(nb_in_long % 10);
	}
}

void	ft_print_int_tab(int *tab, int size)
{
	int	i;

	if (tab != NULL && size > 0)
	{
		write(1, "[", 1);
		i = 0;
		while (i < size)
		{
			ft_putnbr(tab[i]);
			if (i < size - 1)
				write(1, ", ", 2);
			i++;
		}
		write(1, "]", 1);
	}
}

void	ft_print_int_tab_with_size(int *tab, int size)
{
	printf("The returned size of range is %d.\n", size);
	printf("tab = %p\n", tab);
	if (tab != NULL && size > 0)
		ft_print_int_tab(tab, size);
	else if (size == 0)
		printf("\nNone array - Reason : If the value of min is greater or equal to maxâ€™s value, range will point on NULL and it should return 0.");
	else if (size == -1)
		printf("\nIncomplete array - Reason : The size of range should be returned (or -1 on error).");
	else
		printf("\nSegmentation fault - Reason : tab == (nil).");
}

int	main(void)
{
	int	min;
	int	max;
	int	*tab1;
	int	tab1_size;
	/*int	*tab2 = {-1};
	int	tab2_size;
	int	*tab3 = {-1};
	int	tab3_size;
	int	*tab4 = {-1};
	int	tab4_size;*/

	min = 3;
	max = 8;
	tab1_size = ft_ultimate_range(&tab1, min, max);
	printf("Pour min = %d et max = %d, tab1 =\n", min, max);
	printf("tab1 = %p\n", tab1);
	ft_print_int_tab_with_size(tab1, tab1_size);
	//free(*tab1);
	/*free(*ptr);
	free(ptr);*/
	/*min = 42;
	max = 42;
	tab2_size = ft_ultimate_range(tab2, min, max);
	printf("\nPour min = %d et max = %d, tab2 =\n", min, max);
	ft_print_int_tab(*tab2, tab2_size);
	free(*tab2);
	free(tab2);
	min = -42;
	max = 43;
	tab3_size = ft_ultimate_range(tab3, min, max);
	printf("\nPour min = %d et max = %d, tab3 =\n", min, max);
	ft_print_int_tab(*tab3, tab3_size);
	free(*tab3);
	free(tab3);
	min = 42;
	max = -1;
	tab4_size = ft_ultimate_range(tab4, min, max);
	printf("\nPour min = %d et max = %d, tab4 =\n", min, max);
	ft_print_int_tab(*tab4, tab4_size);
	free(*tab4);
	free(tab4);*/
	return (0);
}
e3r11p9% gcc -Wall -Wextra -Werror -o test_ft_ultimate_range ft_ultimate_range.c test_ft_ultimate_range.c
e3r11p9% ls -al
total 36
drwxr-xr-x 2 hauerbac 2023_paris  4096 Feb 28 14:36 .
drwxr-xr-x 6 hauerbac 2023_paris  4096 Feb 28 09:26 ..
-rw-r--r-- 1 hauerbac 2023_paris  1930 Feb 23 09:57 ft_ultimate_range_0.c
-rw-r--r-- 1 hauerbac 2023_paris  1828 Feb 27 17:57 ft_ultimate_range.c
-rwxr-xr-x 1 hauerbac 2023_paris 16344 Feb 28 14:36 test_ft_ultimate_range
-rw-r--r-- 1 hauerbac 2023_paris  3157 Feb 28 14:36 test_ft_ultimate_range.c
e3r11p9% ./test_ft_ultimate_range 
ptr = 0x55a51e34e2c0, *ptr = 3, *(ptr + 1) = 4
range = 0x55a51e34e2a0, *range = 0x55a51e34e2c0, *(*range + 1) = 4
Pour min = 3 et max = 8, tab1 =
tab1 = (nil)
The returned size of range is 5.
tab = (nil)

Segmentation fault - Reason : tab == (nil).%                                                                      e3r11p9% vi test_ft_ultimate_range.c                                                                    
e3r11p9% gcc -Wall -Wextra -Werror -o test_ft_ultimate_range ft_ultimate_range.c test_ft_ultimate_range.c
e3r11p9% ./test_ft_ultimate_range                                                                       
ptr = 0x55b1b04bc2c0, *ptr = 3, *(ptr + 1) = 4
range = 0x55b1b04bc2a0, *range = 0x55b1b04bc2c0, *(*range + 1) = 4
Pour min = 3 et max = 8, tab1 =
&tab1 = 0x7ffcb22bc3f0
tab1 = (nil)
The returned size of range is 5.
tab = (nil)

Segmentation fault - Reason : tab == (nil).%                                                                      e3r11p9% vi test_ft_ultimate_range.c                                                                    
e3r11p9% gcc -Wall -Wextra -Werror -o test_ft_ultimate_range ft_ultimate_range.c test_ft_ultimate_range.c
test_ft_ultimate_range.c: In function â€˜ft_print_int_tab_with_sizeâ€™:
test_ft_ultimate_range.c:65:17: error: format â€˜%dâ€™ expects argument of type â€˜intâ€™, but argument 2 has type â€˜int *â€™ [-Werror=format=]
   65 |  printf("tab = %d\n", tab);
      |                ~^     ~~~
      |                 |     |
      |                 int   int *
      |                %ls
cc1: all warnings being treated as errors
e3r11p9% vi test_ft_ultimate_range.c                                                                     
e3r11p9% gcc -Wall -Wextra -Werror -o test_ft_ultimate_range ft_ultimate_range.c test_ft_ultimate_range.c
e3r11p9% ./test_ft_ultimate_range                                                                       
ptr = 0x55f635c092c0, *ptr = 3, *(ptr + 1) = 4
range = 0x55f635c092a0, *range = 0x55f635c092c0, *(*range + 1) = 4
Pour min = 3 et max = 8, tab1 =
&tab1 = 0x7ffee1e93a90
tab1 = (nil)
The returned size of range is 5.
tab = (null)
e3r11p9% vi test_ft_ultimate_range.c                                                                     
e3r11p9% gcc -Wall -Wextra -Werror -o test_ft_ultimate_range ft_ultimate_range.c test_ft_ultimate_range.c
e3r11p9% ./test_ft_ultimate_range                                                                       
ptr = 0x55beb3aae2c0, *ptr = 3, *(ptr + 1) = 4
range = 0x55beb3aae2a0, *range = 0x55beb3aae2c0, *(*range + 1) = 4
Pour min = 3 et max = 8, tab1 =
&tab1 = 0x7ffd48c841d0
tab1 = (null)
The returned size of range is 5.
tab = (null)
e3r11p9% cat test_ft_ultimate_range.c
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   test_ft_ultimate_range.c                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: hauerbac <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2023/02/22 17:56:00 by hauerbac          #+#    #+#             */
/*   Updated: 2023/02/28 14:44:34 by hauerbac         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>

int	ft_ultimate_range(int **range, int min, int max);


void	ft_putnbr(int nb)
{
	long	nb_in_long;
	int		digit_to_char;

	nb_in_long = nb;
	if (nb_in_long < 0)
	{
		write(1, "-", 1);
		nb_in_long = nb_in_long * -1;
	}
	if (nb_in_long < 10)
	{
		digit_to_char = nb_in_long + '0';
		write(1, &digit_to_char, 1);
	}
	else
	{
		ft_putnbr(nb_in_long / 10);
		ft_putnbr(nb_in_long % 10);
	}
}

void	ft_print_int_tab(int *tab, int size)
{
	int	i;

	if (tab != NULL && size > 0)
	{
		write(1, "[", 1);
		i = 0;
		while (i < size)
		{
			ft_putnbr(tab[i]);
			if (i < size - 1)
				write(1, ", ", 2);
			i++;
		}
		write(1, "]", 1);
	}
}

void	ft_print_int_tab_with_size(int *tab, int size)
{
	printf("The returned size of range is %d.\n", size);
	printf("tab = %ls\n", tab);
	if (size > 0)
		ft_print_int_tab(tab, size);
	else if (size == 0)
		printf("\nNone array - Reason : If the value of min is greater or equal to maxâ€™s value, range will point on NULL and it should return 0.");
	else if (size == -1)
		printf("\nIncomplete array - Reason : The size of range should be returned (or -1 on error).");
	else
		printf("\nSegmentation fault - Reason : tab == (nil).");
}

int	main(void)
{
	int	min;
	int	max;
	int	*tab1;
	int	tab1_size;
	/*int	*tab2;
	int	tab2_size;
	int	*tab3;
	int	tab3_size;
	int	*tab4;
	int	tab4_size;*/

	min = 3;
	max = 8;
	tab1_size = ft_ultimate_range(&tab1, min, max);
	printf("Pour min = %d et max = %d, tab1 =\n", min, max);
	printf("&tab1 = %p\n", &tab1);
	printf("tab1 = %ls\n", tab1);
	ft_print_int_tab_with_size(tab1, tab1_size);
	//free(*tab1);
	/*free(*ptr);
	free(ptr);*/
	/*min = 42;
	max = 42;
	tab2_size = ft_ultimate_range(tab2, min, max);
	printf("\nPour min = %d et max = %d, tab2 =\n", min, max);
	ft_print_int_tab(*tab2, tab2_size);
	free(*tab2);
	free(tab2);
	min = -42;
	max = 43;
	tab3_size = ft_ultimate_range(tab3, min, max);
	printf("\nPour min = %d et max = %d, tab3 =\n", min, max);
	ft_print_int_tab(*tab3, tab3_size);
	free(*tab3);
	free(tab3);
	min = 42;
	max = -1;
	tab4_size = ft_ultimate_range(tab4, min, max);
	printf("\nPour min = %d et max = %d, tab4 =\n", min, max);
	ft_print_int_tab(*tab4, tab4_size);
	free(*tab4);
	free(tab4);*/
	return (0);
}
--------------------------------------------------------------------------------------------------------------------------------------
e3r11p9% vim ft_ultimate_range.c                         
e3r11p9% cat ft_ultimate_range.c
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_ultimate_range.c                                :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: hauerbac <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2023/02/23 10:23:31 by hauerbac          #+#    #+#             */
/*   Updated: 2023/02/28 16:35:21 by hauerbac         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include <stdlib.h>

int	*ft_range(int min, int max)
{
	int	range_len;
	int	*ptr;
	int	i;
	int	value;

	if (min < max)
	{
		range_len = max - min;
		ptr = (int *) malloc(range_len * sizeof(int));
		if (ptr)
		{
			value = min;
			i = 0;
			while (i < range_len && value < max)
				ptr[i++] = value++;
			if (i == range_len)
				return (ptr);
			else
				return (NULL);
		}
	}
	return (NULL);
}

int	ft_ultimate_range(int **range, int min, int max)
{
	int	range_len;
	int	*ptr;

	if (range == NULL)
		return (-1);
	if (min < max)
	{
		range_len = max - min;
		ptr = ft_range(min, max);
		if (ptr)
		{
			*range = ptr;
			return (range_len);
		}
		else
			return (-1);
	}
	else
		return (0);
}
e3r11p9% vim test_ft_ultimate_range.c                    
e3r11p9% gcc ft_ultimate_range.c test_ft_ultimate_range.c
e3r11p9% ./a.out                                         
Pour min = 3 et max = 8, tab1 =
ptr = 0x55d39e47a2a0
3, 4, 5, 6, 7, The returned size of range is 5.
ptr_tab = 0x55d39e47a2a0
[3, 4, 5, 6, 7]Warn: Any segfault will mean that arrays are not correctly allocated
5:5
0, 1, 2, 3, 4 : 0, 1, 2, 3, 4
0:0
2:2
-1, 0 : -1, 0%                                                                                                                                                      e3r11p9% vim test_ft_ultimate_range.c               
e3r11p9% cat test_ft_ultimate_range.c
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   test_ft_ultimate_range.c                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: hauerbac <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2023/02/22 17:56:00 by hauerbac          #+#    #+#             */
/*   Updated: 2023/02/28 16:48:23 by hauerbac         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>

int	ft_ultimate_range(int **range, int min, int max);


void	ft_putnbr(int nb)
{
	long	nb_in_long;
	int		digit_to_char;

	nb_in_long = nb;
	if (nb_in_long < 0)
	{
		write(1, "-", 1);
		nb_in_long = nb_in_long * -1;
	}
	if (nb_in_long < 10)
	{
		digit_to_char = nb_in_long + '0';
		write(1, &digit_to_char, 1);
	}
	else
	{
		ft_putnbr(nb_in_long / 10);
		ft_putnbr(nb_in_long % 10);
	}
}

void	ft_print_int_tab(int *tab, int size)
{
	int	i;

	if (tab != NULL && size > 0)
	{
		write(1, "[", 1);
		i = 0;
		while (i < size)
		{
			ft_putnbr(tab[i]);
			if (i < size - 1)
				write(1, ", ", 2);
			i++;
		}
		write(1, "]", 1);
	}
}

void	ft_print_int_tab_with_size(int **ptr_tab, int size)
{
	printf("The returned size of range is %d.\n", size);
	printf("ptr_tab = %p\n", ptr_tab);
	if (size > 0)
		ft_print_int_tab(*ptr_tab, size);
	else if (size == 0)
		printf("\nNone array - Reason : If the value of min is greater or equal to maxâ€™s value, range will point on NULL and it should return 0.");
	else if (size == -1)
		printf("\nIncomplete array - Reason : The size of range should be returned (or -1 on error).");
	else
		printf("\nSegmentation fault - Reason : ptr_tab == (nil).");
}

int	main(void)
{
	int	min;
	int	max;
	int	**ptr;
	int	tab1_size;
	int	tab2_size;
	int	tab3_size;
	int	tab4_size;
	int	*range;

	ptr = (int **) malloc(sizeof(int *));
	min = 3;
	max = 8;
	tab1_size = ft_ultimate_range(ptr, min, max);
	printf("Pour min = %d et max = %d, tab1 =\n", min, max);
	/*printf("ptr = %p\n", ptr);
	int i = 0;
	while (i < 5)
	{
		printf("%d, ", *(*ptr + i));
		i++;
	}*/
	ft_print_int_tab_with_size(ptr, tab1_size);
	free(*ptr);
	min = 42;
	max = 42;
	tab2_size = ft_ultimate_range(ptr, min, max);
	printf("\nPour min = %d et max = %d, tab2 =\n", min, max);
	ft_print_int_tab(*ptr, tab2_size);
	free(*ptr);
	min = -42;
	max = 43;
	tab3_size = ft_ultimate_range(ptr, min, max);
	printf("\nPour min = %d et max = %d, tab3 =\n", min, max);
	ft_print_int_tab(*ptr, tab3_size);
	free(*ptr);
	min = 42;
	max = -1;
	tab4_size = ft_ultimate_range(ptr, min, max);
	printf("\nPour min = %d et max = %d, tab4 =\n", min, max);
	ft_print_int_tab(*ptr, tab4_size);
	free(*ptr);
	free(ptr);

	printf("\nWarn: Any segfault will mean that arrays are not correctly allocated\n");
	printf("5:%d\n", ft_ultimate_range(&range, 0, 5));
	printf("0, 1, 2, 3, 4 : %d, %d, %d, %d, %d\n", range[0], range[1], range[2], range[3], range[4]);
	printf("0:%d\n", ft_ultimate_range(&range, 3, 3));
	printf("2:%d\n", ft_ultimate_range(&range, -1, 1));
	printf("-1, 0 : %d, %d", range[0], range[1]);
	return (0);
}
e3r11p9% gcc ft_ultimate_range.c test_ft_ultimate_range.c
e3r11p9% ./a.out                                         
Pour min = 3 et max = 8, tab1 =
The returned size of range is 5.
ptr_tab = 0x55a8eec532a0
[3, 4, 5, 6, 7]
Pour min = 42 et max = 42, tab2 =
free(): double free detected in tcache 2
zsh: IOT instruction (core dumped)  ./a.out
e3r11p9% vim test_ft_ultimate_range.c                    
e3r11p9% gcc ft_ultimate_range.c test_ft_ultimate_range.c
e3r11p9% ./a.out                                         
Pour min = 3 et max = 8, tab1 =
The returned size of range is 5.
ptr_tab = 0x55b59d6cc2a0
[3, 4, 5, 6, 7]
Pour min = 42 et max = 42, tab2 =
free(): double free detected in tcache 2
zsh: IOT instruction (core dumped)  ./a.out
e3r11p9% vim test_ft_ultimate_range.c                    
e3r11p9% cat test_ft_ultimate_range.c                    
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   test_ft_ultimate_range.c                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: hauerbac <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2023/02/22 17:56:00 by hauerbac          #+#    #+#             */
/*   Updated: 2023/02/28 17:01:23 by hauerbac         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>

int	ft_ultimate_range(int **range, int min, int max);


void	ft_putnbr(int nb)
{
	long	nb_in_long;
	int		digit_to_char;

	nb_in_long = nb;
	if (nb_in_long < 0)
	{
		write(1, "-", 1);
		nb_in_long = nb_in_long * -1;
	}
	if (nb_in_long < 10)
	{
		digit_to_char = nb_in_long + '0';
		write(1, &digit_to_char, 1);
	}
	else
	{
		ft_putnbr(nb_in_long / 10);
		ft_putnbr(nb_in_long % 10);
	}
}

void	ft_print_int_tab(int *tab, int size)
{
	int	i;

	if (tab != NULL && size > 0)
	{
		write(1, "[", 1);
		i = 0;
		while (i < size)
		{
			ft_putnbr(tab[i]);
			if (i < size - 1)
				write(1, ", ", 2);
			i++;
		}
		write(1, "]", 1);
	}
}

void	ft_print_int_tab_with_size(int **ptr_tab, int size)
{
	printf("The returned size of range is %d.\n", size);
	printf("ptr_tab = %p\n", ptr_tab);
	if (size > 0)
		ft_print_int_tab(*ptr_tab, size);
	else if (size == 0)
		printf("\nNone array - Reason : If the value of min is greater or equal to maxâ€™s value, range will point on NULL and it should return 0.");
	else if (size == -1)
		printf("\nIncomplete array - Reason : The size of range should be returned (or -1 on error).");
	else
		printf("\nSegmentation fault - Reason : ptr_tab == (nil).");
}

int	main(void)
{
	int	min;
	int	max;
	int	**ptr;
	int	tab1_size;
	int	tab2_size;
	int	tab3_size;
	int	tab4_size;
	int	*range;

	ptr = (int **) malloc(sizeof(int *));
	if (ptr)
	{
		min = 3;
		max = 8;
		printf("Pour min = %d et max = %d, tab1 =\n", min, max);
		tab1_size = ft_ultimate_range(ptr, min, max);
		/*printf("ptr = %p\n", ptr);
		int i = 0;
		while (i < 5)
		{
			printf("%d, ", *(*ptr + i));
			i++;
		}*/
		ft_print_int_tab_with_size(ptr, tab1_size);
		if (*ptr)
			free(*ptr);
		min = 42;
		max = 42;
		printf("\nPour min = %d et max = %d, tab2 =\n", min, max);
		tab2_size = ft_ultimate_range(ptr, min, max);
		ft_print_int_tab(*ptr, tab2_size);
		if (*ptr)
			free(*ptr);
		min = -42;
		max = 43;
		printf("\nPour min = %d et max = %d, tab3 =\n", min, max);
		tab3_size = ft_ultimate_range(ptr, min, max);
		ft_print_int_tab(*ptr, tab3_size);
		if (*ptr)
			free(*ptr);
		min = 42;
		max = -1;
		printf("\nPour min = %d et max = %d, tab4 =\n", min, max);
		tab4_size = ft_ultimate_range(ptr, min, max);
		ft_print_int_tab(*ptr, tab4_size);
		if (*ptr)
			free(*ptr);
		free(ptr);
	}

	printf("\nWarn: Any segfault will mean that arrays are not correctly allocated\n");
	printf("5:%d\n", ft_ultimate_range(&range, 0, 5));
	printf("0, 1, 2, 3, 4 : %d, %d, %d, %d, %d\n", range[0], range[1], range[2], range[3], range[4]);
	printf("0:%d\n", ft_ultimate_range(&range, 3, 3));
	printf("2:%d\n", ft_ultimate_range(&range, -1, 1));
	printf("-1, 0 : %d, %d", range[0], range[1]);
	return (0);
}
e3r11p9% gcc ft_ultimate_range.c test_ft_ultimate_range.c
e3r11p9% ./a.out                                         
Pour min = 3 et max = 8, tab1 =
The returned size of range is 5.
ptr_tab = 0x557efa0d52a0
[3, 4, 5, 6, 7]
Pour min = 42 et max = 42, tab2 =
free(): double free detected in tcache 2
zsh: IOT instruction (core dumped)  ./a.out
e3r11p9% vim test_ft_ultimate_range.c                    
e3r11p9% gcc ft_ultimate_range.c test_ft_ultimate_range.c
e3r11p9% ./a.out                                         
Pour min = 3 et max = 8, tab1 =
The returned size of range is 5.
ptr_tab = 0x5577476002a0
[3, 4, 5, 6, 7]
Pour min = 42 et max = 42, tab2 =
free(): double free detected in tcache 2
zsh: IOT instruction (core dumped)  ./a.out
e3r11p9% vim test_ft_ultimate_range.c                    
e3r11p9% gcc ft_ultimate_range.c test_ft_ultimate_range.c
e3r11p9% ./a.out                                         
Pour min = 3 et max = 8, tab1 =
The returned size of range is 5.
ptr_tab = 0x55d9eefd32a0
[3, 4, 5, 6, 7]
Pour min = 42 et max = 42, tab2 =

Pour min = -42 et max = 43, tab3 =
[-42, -41, -40, -39, -38, -37, -36, -35, -34, -33, -32, -31, -30, -29, -28, -27, -26, -25, -24, -23, -22, -21, -20, -19, -18, -17, -16, -15, -14, -13, -12, -11, -10, -9, -8, -7, -6, -5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42]
Pour min = 42 et max = -1, tab4 =

Warn: Any segfault will mean that arrays are not correctly allocated
5:5
0, 1, 2, 3, 4 : 0, 1, 2, 3, 4
0:0
2:2
-1, 0 : -1, 0%                                                                                                                                                      e3r11p9% cat test_ft_ultimate_range.c                 
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   test_ft_ultimate_range.c                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: hauerbac <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2023/02/22 17:56:00 by hauerbac          #+#    #+#             */
/*   Updated: 2023/02/28 17:14:57 by hauerbac         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>

int	ft_ultimate_range(int **range, int min, int max);


void	ft_putnbr(int nb)
{
	long	nb_in_long;
	int		digit_to_char;

	nb_in_long = nb;
	if (nb_in_long < 0)
	{
		write(1, "-", 1);
		nb_in_long = nb_in_long * -1;
	}
	if (nb_in_long < 10)
	{
		digit_to_char = nb_in_long + '0';
		write(1, &digit_to_char, 1);
	}
	else
	{
		ft_putnbr(nb_in_long / 10);
		ft_putnbr(nb_in_long % 10);
	}
}

void	ft_print_int_tab(int *tab, int size)
{
	int	i;

	if (tab != NULL && size > 0)
	{
		write(1, "[", 1);
		i = 0;
		while (i < size)
		{
			ft_putnbr(tab[i]);
			if (i < size - 1)
				write(1, ", ", 2);
			i++;
		}
		write(1, "]", 1);
	}
}

void	ft_print_int_tab_with_size(int **ptr_tab, int size)
{
	printf("The returned size of range is %d.\n", size);
	printf("ptr_tab = %p\n", ptr_tab);
	if (size > 0)
		ft_print_int_tab(*ptr_tab, size);
	else if (size == 0)
		printf("\nNone array - Reason : If the value of min is greater or equal to maxâ€™s value, range will point on NULL and it should return 0.");
	else if (size == -1)
		printf("\nIncomplete array - Reason : The size of range should be returned (or -1 on error).");
	else
		printf("\nSegmentation fault - Reason : ptr_tab == (nil).");
}

int	main(void)
{
	int	min;
	int	max;
	int	**ptr;
	int	**save_ptr;
	int	tab1_size;
	int	tab2_size;
	int	tab3_size;
	int	tab4_size;
	int	*range;

	ptr = (int **) malloc(sizeof(int *));
	save_ptr = ptr;
	if (ptr)
	{
		min = 3;
		max = 8;
		printf("Pour min = %d et max = %d, tab1 =\n", min, max);
		tab1_size = ft_ultimate_range(ptr, min, max);
		/*printf("ptr = %p\n", ptr);
		int i = 0;
		while (i < 5)
		{
			printf("%d, ", *(*ptr + i));
			i++;
		}*/
		ft_print_int_tab_with_size(ptr, tab1_size);
		/*if (*ptr)
			free(*ptr);
		ptr = save_ptr;*/
		min = 42;
		max = 42;
		printf("\nPour min = %d et max = %d, tab2 =\n", min, max);
		tab2_size = ft_ultimate_range(ptr, min, max);
		ft_print_int_tab(*ptr, tab2_size);
		/*if (*ptr)
			free(*ptr);
		ptr = save_ptr;*/
		min = -42;
		max = 43;
		printf("\nPour min = %d et max = %d, tab3 =\n", min, max);
		tab3_size = ft_ultimate_range(ptr, min, max);
		ft_print_int_tab(*ptr, tab3_size);
		/*if (*ptr)
			free(*ptr);
		ptr = save_ptr;*/
		min = 42;
		max = -1;
		printf("\nPour min = %d et max = %d, tab4 =\n", min, max);
		tab4_size = ft_ultimate_range(ptr, min, max);
		ft_print_int_tab(*ptr, tab4_size);
		if (*ptr)
			free(*ptr);
		free(ptr);
	}

	printf("\nWarn: Any segfault will mean that arrays are not correctly allocated\n");
	printf("5:%d\n", ft_ultimate_range(&range, 0, 5));
	printf("0, 1, 2, 3, 4 : %d, %d, %d, %d, %d\n", range[0], range[1], range[2], range[3], range[4]);
	printf("0:%d\n", ft_ultimate_range(&range, 3, 3));
	printf("2:%d\n", ft_ultimate_range(&range, -1, 1));
	printf("-1, 0 : %d, %d", range[0], range[1]);
	return (0);
}
------------------------------------------------------------------------------------------------------------------------------------
e3r11p9% vi test_ft_ultimate_range.c                                                                     
e3r11p9% gcc -Wall -Wextra -Werror -o test_ft_ultimate_range ft_ultimate_range.c test_ft_ultimate_range.c
e3r11p9% ./test_ft_ultimate_range                                                                       
Pour min = 3 et max = 8, tab1 =
[3, 4, 5, 6, 7]
The returned size of range is 5.
ptr_tab = 0x55659297d2a0

Pour min = 42 et max = 42, tab2 =

None array - Reason : If min >= max, range will point on NULL and it should return 0.
The returned size of range is 0.
zsh: segmentation fault (core dumped)  ./test_ft_ultimate_range
e3r11p9% vi test_ft_ultimate_range.c                                                                    
e3r11p9% gcc -Wall -Wextra -Werror -o test_ft_ultimate_range ft_ultimate_range.c test_ft_ultimate_range.c
e3r11p9% ./test_ft_ultimate_range                                                                       
Pour min = 3 et max = 8, tab1 =
[3, 4, 5, 6, 7]
The returned size of range is 5.
ptr_tab = 0x55ac356ba2a0

Pour min = 42 et max = 42, tab2 =

None array - Reason : If min >= max, range will point on NULL and it should return 0.
The returned size of range is 0.

Pour min = -42 et max = 43, tab3 =
[-42, -41, -40, -39, -38, -37, -36, -35, -34, -33, -32, -31, -30, -29, -28, -27, -26, -25, -24, -23, -22, -21, -20, -19, -18, -17, -16, -15, -14, -13, -12, -11, -10, -9, -8, -7, -6, -5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42]
The returned size of range is 85.
ptr_tab = 0x55ac356ba6d0

Pour min = 42 et max = -1, tab4 =

None array - Reason : If min >= max, range will point on NULL and it should return 0.
The returned size of range is 0.

Warn: Any segfault will mean that arrays are not correctly allocated
5:5
0, 1, 2, 3, 4 : 0, 1, 2, 3, 4
0:0
2:2
-1, 0 : -1, 0%                                                                                                                                                      e3r11p9% gcc -Wall -Wextra -Werror -o test_ft_ultimate_range -g3 ft_ultimate_range.c test_ft_ultimate_range.c
e3r11p9% valgrind --leak-check=full ./test_ft_ultimate_range                                                 
==650900== Memcheck, a memory error detector
==650900== Copyright (C) 2002-2017, and GNU GPL'd, by Julian Seward et al.
==650900== Using Valgrind-3.18.1 and LibVEX; rerun with -h for copyright info
==650900== Command: ./test_ft_ultimate_range
==650900== 
Pour min = 3 et max = 8, tab1 =
[3, 4, 5, 6, 7]
The returned size of range is 5.
ptr_tab = 0x4a9f040

Pour min = 42 et max = 42, tab2 =

None array - Reason : If min >= max, range will point on NULL and it should return 0.
The returned size of range is 0.
==650900== Conditional jump or move depends on uninitialised value(s)
==650900==    at 0x109687: main (test_ft_ultimate_range.c:136)
==650900== 

Pour min = -42 et max = 43, tab3 =
[-42, -41, -40, -39, -38, -37, -36, -35, -34, -33, -32, -31, -30, -29, -28, -27, -26, -25, -24, -23, -22, -21, -20, -19, -18, -17, -16, -15, -14, -13, -12, -11, -10, -9, -8, -7, -6, -5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42]
The returned size of range is 85.
ptr_tab = 0x4a9f580

Pour min = 42 et max = -1, tab4 =

None array - Reason : If min >= max, range will point on NULL and it should return 0.
The returned size of range is 0.

Warn: Any segfault will mean that arrays are not correctly allocated
5:5
0, 1, 2, 3, 4 : 0, 1, 2, 3, 4
0:0
2:2
-1, 0 : -1, 0==650900== 
==650900== HEAP SUMMARY:
==650900==     in use at exit: 0 bytes in 0 blocks
==650900==   total heap usage: 9 allocs, 9 frees, 1,444 bytes allocated
==650900== 
==650900== All heap blocks were freed -- no leaks are possible
==650900== 
==650900== Use --track-origins=yes to see where uninitialised values come from
==650900== For lists of detected and suppressed errors, rerun with: -s
==650900== ERROR SUMMARY: 1 errors from 1 contexts (suppressed: 0 from 0)
e3r11p9% ./test_ft_ultimate_range                                                                            
Pour min = 3 et max = 8, tab1 =
[3, 4, 5, 6, 7]
The returned size of range is 5.
ptr_tab = 0x55dd5cdfb2a0

Pour min = 42 et max = 42, tab2 =

None array - Reason : If min >= max, range will point on NULL and it should return 0.
The returned size of range is 0.
zsh: segmentation fault (core dumped)  ./test_ft_ultimate_range
e3r11p9% vi test_ft_ultimate_range.c                                                                         
e3r11p9% gcc -Wall -Wextra -Werror -o test_ft_ultimate_range -g3 ft_ultimate_range.c test_ft_ultimate_range.c
e3r11p9% valgrind --leak-check=full -s ./test_ft_ultimate_range                                              
==652176== Memcheck, a memory error detector
==652176== Copyright (C) 2002-2017, and GNU GPL'd, by Julian Seward et al.
==652176== Using Valgrind-3.18.1 and LibVEX; rerun with -h for copyright info
==652176== Command: ./test_ft_ultimate_range
==652176== 
Pour min = 3 et max = 8, tab1 =
[3, 4, 5, 6, 7]
The returned size of range is 5.
ptr_tab = 0x4a9f040

Pour min = 42 et max = 42, tab2 =

None array - Reason : If min >= max, range will point on NULL and it should return 0.
The returned size of range is 0.

Pour min = -42 et max = 43, tab3 =
[-42, -41, -40, -39, -38, -37, -36, -35, -34, -33, -32, -31, -30, -29, -28, -27, -26, -25, -24, -23, -22, -21, -20, -19, -18, -17, -16, -15, -14, -13, -12, -11, -10, -9, -8, -7, -6, -5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42]
The returned size of range is 85.
ptr_tab = 0x4a9f580

Pour min = 42 et max = -1, tab4 =

None array - Reason : If min >= max, range will point on NULL and it should return 0.
The returned size of range is 0.

Warn: Any segfault will mean that arrays are not correctly allocated
5:5
0, 1, 2, 3, 4 : 0, 1, 2, 3, 4
0:0
2:2
-1, 0 : -1, 0==652176== 
==652176== HEAP SUMMARY:
==652176==     in use at exit: 0 bytes in 0 blocks
==652176==   total heap usage: 9 allocs, 9 frees, 1,444 bytes allocated
==652176== 
==652176== All heap blocks were freed -- no leaks are possible
==652176== 
==652176== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
e3r11p9% ./test_ft_ultimate_range 
Pour min = 3 et max = 8, tab1 =
[3, 4, 5, 6, 7]
The returned size of range is 5.
ptr_tab = 0x562512c8e2a0

Pour min = 42 et max = 42, tab2 =

None array - Reason : If min >= max, range will point on NULL and it should return 0.
The returned size of range is 0.

Pour min = -42 et max = 43, tab3 =
[-42, -41, -40, -39, -38, -37, -36, -35, -34, -33, -32, -31, -30, -29, -28, -27, -26, -25, -24, -23, -22, -21, -20, -19, -18, -17, -16, -15, -14, -13, -12, -11, -10, -9, -8, -7, -6, -5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42]
The returned size of range is 85.
ptr_tab = 0x562512c8e2a0

Pour min = 42 et max = -1, tab4 =

None array - Reason : If min >= max, range will point on NULL and it should return 0.
The returned size of range is 0.

Warn: Any segfault will mean that arrays are not correctly allocated
5:5
0, 1, 2, 3, 4 : 0, 1, 2, 3, 4
0:0
2:2
-1, 0 : -1, 0%                                                                                                                                                      
e3r11p9% cat test_ft_ultimate_range.c
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   test_ft_ultimate_range.c                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: hauerbac <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2023/02/22 17:56:00 by hauerbac          #+#    #+#             */
/*   Updated: 2023/02/28 19:13:43 by hauerbac         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>

int	ft_ultimate_range(int **range, int min, int max);

void	ft_putnbr(int nb)
{
	long	nb_in_long;
	int		digit_to_char;

	nb_in_long = nb;
	if (nb_in_long < 0)
	{
		write(1, "-", 1);
		nb_in_long = nb_in_long * -1;
	}
	if (nb_in_long < 10)
	{
		digit_to_char = nb_in_long + '0';
		write(1, &digit_to_char, 1);
	}
	else
	{
		ft_putnbr(nb_in_long / 10);
		ft_putnbr(nb_in_long % 10);
	}
}

void	ft_print_int_tab(int *tab, int size)
{
	int	i;

	if (tab != NULL && size > 0)
	{
		write(1, "[", 1);
		i = 0;
		while (i < size)
		{
			ft_putnbr(tab[i]);
			if (i < size - 1)
				write(1, ", ", 2);
			i++;
		}
		write(1, "]", 1);
	}
}

void	ft_print_int_tab_with_size(int **ptr_tab, int size)
{
	if (size > 0)
	{
		if (ptr_tab && *ptr_tab)
			ft_print_int_tab(*ptr_tab, size);
		printf("\nThe returned size of range is %d.\n", size);
		printf("ptr_tab = %p\n", ptr_tab);
	}
	else if (size == 0)
	{
		printf("\nNone array - Reason : If min >= max, range will point on NULL and it should return 0.\n");
		printf("The returned size of range is %d.\n", size);
	}
	else if (size == -1)
	{
		printf("\nIncomplete array - Reason : The size of range should be returned (or -1 on error).\n");
		printf("The returned size of range is %d.\n", size);
	}
	else
		printf("\nSegmentation fault - Reason : ptr_tab == (nil).");
}

int	main(void)
{
	int	min;
	int	max;
	int	**ptr1;
	int	tab1_size;
	int	**ptr2;
	int	tab2_size;
	int	**ptr3;
	int	tab3_size;
	int	**ptr4;
	int	tab4_size;
	int	*range1;
	int	*range2;
	int	*range3;

	ptr1 = (int **) malloc(sizeof(int *));
	if (ptr1)
	{
		min = 3;
		max = 8;
		printf("Pour min = %d et max = %d, tab1 =\n", min, max);
		tab1_size = ft_ultimate_range(ptr1, min, max);
		/*if (ptr1 && *ptr1)
		{
			printf("ptr1 = %p\n", ptr1);
			int i = 0;
			while (i < 5)
			{
				printf("%d, ", *(*ptr1 + i));
				i++;
			}
		}*/
		ft_print_int_tab_with_size(ptr1, tab1_size);
		if (ptr1)
			if (*ptr1)
				free(*ptr1);
		free(ptr1);
	}
	ptr2 = (int **) malloc(sizeof(int *));
	if (ptr2)
	{
		min = 42;
		max = 42;
		printf("\nPour min = %d et max = %d, tab2 =\n", min, max);
		tab2_size = ft_ultimate_range(ptr2, min, max);
		ft_print_int_tab_with_size(ptr2, tab2_size);
		free(ptr2);
	}
	ptr3 = (int **) malloc(sizeof(int *));
	if (ptr3)
	{
		min = -42;
		max = 43;
		printf("\nPour min = %d et max = %d, tab3 =\n", min, max);
		tab3_size = ft_ultimate_range(ptr3, min, max);
		ft_print_int_tab_with_size(ptr3, tab3_size);
		if (ptr3)
			if (*ptr3)
				free(*ptr3);
		free(ptr3);
	}
	ptr4 = (int **) malloc(sizeof(int *));
	if (ptr4)
	{
		min = 42;
		max = -1;
		printf("\nPour min = %d et max = %d, tab4 =\n", min, max);
		tab4_size = ft_ultimate_range(ptr4, min, max);
		ft_print_int_tab_with_size(ptr4, tab4_size);
		free(ptr4);
	}

	printf("\nWarn: Any segfault will mean that arrays are not correctly allocated\n");
	printf("5:%d\n", ft_ultimate_range(&range1, 0, 5));
	printf("0, 1, 2, 3, 4 : %d, %d, %d, %d, %d\n", range1[0], range1[1], range1[2], range1[3], range1[4]);
	if (range1)
		free(range1);
	printf("0:%d\n", ft_ultimate_range(&range2, 3, 3));
	printf("2:%d\n", ft_ultimate_range(&range3, -1, 1));
	printf("-1, 0 : %d, %d", range3[0], range3[1]);
	if (range3)
		free(range3);
	return (0);
}
e3r11p9% cat ft_ultimate_range.c
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_ultimate_range.c                                :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: hauerbac <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2023/02/23 10:23:31 by hauerbac          #+#    #+#             */
/*   Updated: 2023/02/28 18:18:23 by hauerbac         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include <stdlib.h>

int	*ft_range(int min, int max)
{
	int	range_len;
	int	*ptr;
	int	i;
	int	value;

	if (min < max)
	{
		range_len = max - min;
		ptr = (int *) malloc(range_len * sizeof(int));
		if (ptr)
		{
			value = min;
			i = 0;
			while (i < range_len && value < max)
				ptr[i++] = value++;
			if (i == range_len)
				return (ptr);
			else
				return (NULL);
		}
	}
	return (NULL);
}

int	ft_ultimate_range(int **range, int min, int max)
{
	int	range_len;
	int	*ptr;

	if (range == NULL)
		return (-1);
	if (min < max)
	{
		range_len = max - min;
		ptr = ft_range(min, max);
		*range = ptr;
		if (ptr)
			return (range_len);
		else
			return (-1);
	}
	else
		return (0);
} 
------------------------------------------------------------------------------------------------------------------------------------
e3r11p9% mkdir ex04
e3r11p9% cd ex04
e3r11p9% vi ft_convert_base.c
e3r11p9% norminette -R CheckForbiddenSourceHeader ft_convert_base.c
ft_convert_base.c: Error!
Error: INVALID_HEADER       (line:   1, col:   1):	Missing or invalid 42 header
Error: SPACE_REPLACE_TAB    (line:  12, col:   9):	Found space when expecting tab
Error: TOO_FEW_TAB          (line:  13, col:   1):	Missing tabs for indent level
Error: SPACE_REPLACE_TAB    (line:  13, col:   9):	Found space when expecting tab
Error: TOO_FEW_TAB          (line:  14, col:   1):	Missing tabs for indent level
Error: SPACE_EMPTY_LINE     (line:  14, col:   9):	Space on empty line
Error: TOO_FEW_TAB          (line:  15, col:   1):	Missing tabs for indent level
Error: SPACE_REPLACE_TAB    (line:  15, col:  17):	Found space when expecting tab
Error: TOO_FEW_TAB          (line:  16, col:   1):	Missing tabs for indent level
Error: SPACE_REPLACE_TAB    (line:  16, col:  25):	Found space when expecting tab
Error: TOO_FEW_TAB          (line:  17, col:   1):	Missing tabs for indent level
Error: SPACE_REPLACE_TAB    (line:  17, col:  25):	Found space when expecting tab
Error: TOO_FEW_TAB          (line:  18, col:   1):	Missing tabs for indent level
Error: SPACE_REPLACE_TAB    (line:  18, col:  25):	Found space when expecting tab
Error: SPACE_REPLACE_TAB    (line:  19, col:  17):	Found space when expecting tab
Error: TOO_FEW_TAB          (line:  20, col:   1):	Missing tabs for indent level
Error: SPACE_EMPTY_LINE     (line:  20, col:   9):	Space on empty line
Error: SPACE_REPLACE_TAB    (line:  21, col:   9):	Found space when expecting tab
Error: TOO_FEW_TAB          (line:  22, col:   1):	Missing tabs for indent level
Error: SPACE_REPLACE_TAB    (line:  22, col:   9):	Found space when expecting tab
Error: LINE_TOO_LONG        (line:  98, col:  82):	line too long
e3r11p9% vi ft_convert_base.c                                      
e3r11p9% norminette -R CheckForbiddenSourceHeader ft_convert_base.c
ft_convert_base.c: Error!
Error: INVALID_HEADER       (line:   1, col:   1):	Missing or invalid 42 header
e3r11p9% vi ft_convert_base.c                                      
e3r11p9% norminette -R CheckForbiddenSourceHeader ft_convert_base.c
ft_convert_base.c: OK!
e3r11p9% vi test_ft_convert_base.c 
e3r11p9% norminette -R CheckForbiddenSourceHeader test_ft_convert_base.c 
test_ft_convert_base.c: Error!
Error: LINE_TOO_LONG        (line:  28, col:  82):	line too long
Error: LINE_TOO_LONG        (line:  30, col:  87):	line too long
Error: LINE_TOO_LONG        (line:  32, col: 103):	line too long
Error: LINE_TOO_LONG        (line:  36, col:  93):	line too long
 e3r11p9% vi ft_convert_base2.c
e3r11p9% norminette -R CheckForbiddenSourceHeader ft_convert_base2.c
ft_convert_base2.c: Error!
	Error: Unrecognized line (119, 56) while parsing line [<RPARENTHESIS>]
e3r11p9% vi ft_convert_base2.c                                      
e3r11p9% norminette -R CheckForbiddenSourceHeader ft_convert_base2.c
ft_convert_base2.c: Error!
Error: CONSECUTIVE_SPC      (line:  13, col:   4):	Two or more consecutives spaces
Error: SPACE_REPLACE_TAB    (line:  13, col:   4):	Found space when expecting tab
Error: CONSECUTIVE_SPC      (line:  31, col:   4):	Two or more consecutives spaces
Error: SPACE_BEFORE_FUNC    (line:  31, col:   8):	space before function name
Error: TOO_FEW_TAB          (line:  33, col:   1):	Missing tabs for indent level
Error: SPACE_REPLACE_TAB    (line:  33, col:   9):	Found space when expecting tab
Error: CONSECUTIVE_SPC      (line:  33, col:  12):	Two or more consecutives spaces
Error: SPACE_REPLACE_TAB    (line:  33, col:  12):	Found space when expecting tab
Error: TOO_FEW_TAB          (line:  34, col:   1):	Missing tabs for indent level
Error: SPACE_REPLACE_TAB    (line:  34, col:   9):	Found space when expecting tab
Error: CONSECUTIVE_SPC      (line:  34, col:  12):	Two or more consecutives spaces
Error: SPACE_REPLACE_TAB    (line:  34, col:  12):	Found space when expecting tab
Error: SPACE_REPLACE_TAB    (line:  36, col:   9):	Found space when expecting tab
Error: TOO_FEW_TAB          (line:  37, col:   1):	Missing tabs for indent level
Error: SPACE_REPLACE_TAB    (line:  37, col:   9):	Found space when expecting tab
Error: TOO_FEW_TAB          (line:  38, col:   1):	Missing tabs for indent level
Error: SPACE_EMPTY_LINE     (line:  38, col:   9):	Space on empty line
Error: SPACE_REPLACE_TAB    (line:  39, col:  17):	Found space when expecting tab
Error: TOO_FEW_TAB          (line:  40, col:   1):	Missing tabs for indent level
Error: SPACE_REPLACE_TAB    (line:  40, col:  17):	Found space when expecting tab
Error: TOO_FEW_TAB          (line:  41, col:   1):	Missing tabs for indent level
Error: SPACE_EMPTY_LINE     (line:  41, col:  17):	Space on empty line
Error: TOO_FEW_TAB          (line:  42, col:   1):	Missing tabs for indent level
Error: SPACE_REPLACE_TAB    (line:  42, col:  25):	Found space when expecting tab
Error: TOO_FEW_TAB          (line:  43, col:   1):	Missing tabs for indent level
Error: SPACE_REPLACE_TAB    (line:  43, col:  33):	Found space when expecting tab
Error: SPACE_REPLACE_TAB    (line:  44, col:  25):	Found space when expecting tab
Error: TOO_FEW_TAB          (line:  45, col:   1):	Missing tabs for indent level
Error: SPACE_EMPTY_LINE     (line:  45, col:  17):	Space on empty line
Error: TOO_FEW_TAB          (line:  46, col:   1):	Missing tabs for indent level
Error: SPACE_EMPTY_LINE     (line:  46, col:   9):	Space on empty line
Error: TOO_FEW_TAB          (line:  47, col:   1):	Missing tabs for indent level
Error: SPACE_REPLACE_TAB    (line:  47, col:   9):	Found space when expecting tab
Error: CONSECUTIVE_SPC      (line:  80, col:   4):	Two or more consecutives spaces
Error: SPACE_BEFORE_FUNC    (line:  80, col:   8):	space before function name
Error: LINE_TOO_LONG        (line:  80, col:  82):	line too long
Error: TOO_FEW_TAB          (line:  82, col:   1):	Missing tabs for indent level
Error: SPACE_REPLACE_TAB    (line:  82, col:   9):	Found space when expecting tab
Error: CONSECUTIVE_SPC      (line:  82, col:  12):	Two or more consecutives spaces
Error: SPACE_REPLACE_TAB    (line:  82, col:  12):	Found space when expecting tab
Error: TOO_FEW_TAB          (line:  83, col:   1):	Missing tabs for indent level
Error: SPACE_REPLACE_TAB    (line:  83, col:   9):	Found space when expecting tab
Error: CONSECUTIVE_SPC      (line:  83, col:  12):	Two or more consecutives spaces
Error: SPACE_REPLACE_TAB    (line:  83, col:  12):	Found space when expecting tab
Error: SPACE_REPLACE_TAB    (line:  85, col:   9):	Found space when expecting tab
Error: TOO_FEW_TAB          (line:  86, col:   1):	Missing tabs for indent level
Error: SPACE_REPLACE_TAB    (line:  86, col:   9):	Found space when expecting tab
Error: TOO_FEW_TAB          (line:  87, col:   1):	Missing tabs for indent level
Error: SPACE_EMPTY_LINE     (line:  87, col:   9):	Space on empty line
Error: SPACE_REPLACE_TAB    (line:  88, col:  17):	Found space when expecting tab
Error: TOO_FEW_TAB          (line:  89, col:   1):	Missing tabs for indent level
Error: SPACE_REPLACE_TAB    (line:  89, col:  17):	Found space when expecting tab
Error: TOO_FEW_TAB          (line:  90, col:   1):	Missing tabs for indent level
Error: SPACE_EMPTY_LINE     (line:  90, col:  17):	Space on empty line
Error: TOO_FEW_TAB          (line:  91, col:   1):	Missing tabs for indent level
Error: SPACE_REPLACE_TAB    (line:  91, col:  25):	Found space when expecting tab
Error: SPACE_REPLACE_TAB    (line:  93, col:  25):	Found space when expecting tab
Error: TOO_FEW_TAB          (line:  94, col:   1):	Missing tabs for indent level
Error: SPACE_EMPTY_LINE     (line:  94, col:  17):	Space on empty line
Error: TOO_FEW_TAB          (line:  95, col:   1):	Missing tabs for indent level
Error: SPACE_EMPTY_LINE     (line:  95, col:   9):	Space on empty line
Error: TOO_FEW_TAB          (line:  96, col:   1):	Missing tabs for indent level
Error: SPACE_REPLACE_TAB    (line:  96, col:   9):	Found space when expecting tab
Error: MISALIGNED_VAR_DECL  (line: 102, col:  17):	Misaligned variable declaration
Error: MISALIGNED_VAR_DECL  (line: 103, col:  21):	Misaligned variable declaration
Error: MISALIGNED_VAR_DECL  (line: 104, col:  21):	Misaligned variable declaration
Error: LINE_TOO_LONG        (line: 117, col:  82):	line too long
e3r11p9% vi ft_convert_base2.c                                      
e3r11p9% norminette -R CheckForbiddenSourceHeader ft_convert_base2.c
ft_convert_base2.c: Error!
Error: MISALIGNED_VAR_DECL  (line: 102, col:  17):	Misaligned variable declaration
Error: MISALIGNED_VAR_DECL  (line: 103, col:  21):	Misaligned variable declaration
Error: MISALIGNED_VAR_DECL  (line: 104, col:  21):	Misaligned variable declaration
Error: LINE_TOO_LONG        (line: 117, col:  82):	line too long
e3r11p9% vi ft_convert_base2.c                                      
e3r11p9% norminette -R CheckForbiddenSourceHeader ft_convert_base2.c
ft_convert_base2.c: Error!
Error: LINE_TOO_LONG        (line: 117, col:  82):	line too long
e3r11p9% vi ft_convert_base2.c                                      
e3r11p9% norminette -R CheckForbiddenSourceHeader ft_convert_base2.c
ft_convert_base2.c: Error!
Error: LINE_TOO_LONG        (line: 117, col:  87):	line too long
e3r11p9% vi ft_convert_base2.c                                      
e3r11p9% norminette -R CheckForbiddenSourceHeader ft_convert_base2.c
ft_convert_base2.c: Error!
Error: TOO_MANY_LINES       (line: 127, col:   1):	Function has more than 25 lines
e3r11p9% vi ft_convert_base2.c                                      
e3r11p9% norminette -R CheckForbiddenSourceHeader ft_convert_base2.c
ft_convert_base2.c: OK!
e3r11p9% cat ft_convert_base2.c
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_convert_base2.c                                 :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: hauerbac <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2023/03/01 12:00:09 by hauerbac          #+#    #+#             */
/*   Updated: 2023/03/01 12:19:04 by hauerbac         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

int	ft_error_or_base(const char *str);

unsigned int	ft_spaces_truncating(const char *str)
{
	unsigned int	i;

	i = 0;
	if (str)
	{
		while (str[i]
			&& (str[i] == ' ' || str[i] == '\f'
				|| str[i] == '\n' || str[i] == '\r'
				|| str[i] == '\t' || str[i] == '\v'))
			i++;
	}
	return (i);
}

int	ft_char_is_into_base(char *characters_for_base, char c, int base_len)
{
	int	i;
	int	result;

	result = 0;
	if (characters_for_base && c != '\0' && base_len > 0)
	{
		i = 0;
		while (i < base_len && characters_for_base[i])
		{
			if (c == characters_for_base[i])
				return (1);
			i++;
		}
	}
	return (result);
}

int	ft_error_or_sign(unsigned int boundaries[2], const char *str, char *base
		, int base_len)
{
	int				result;
	unsigned int	i;

	result = 0;
	boundaries[0] = -1;
	boundaries[1] = -2;
	if (str)
	{
		result = 1;
		i = ft_spaces_truncating(str);
		while (str[i] && (str[i] == '+' || str[i] == '-'))
		{
			if (str[i] == '-')
				result = -1 * result;
			i++;
		}
		if (str[i] && ft_char_is_into_base(base, str[i], base_len))
			boundaries[0] = (unsigned int)i;
		while (str[i] && ft_char_is_into_base(base, str[i], base_len))
			boundaries[1] = (unsigned int)i++;
		if (boundaries[0] == -1 || boundaries[1] == -2
			|| boundaries[0] > boundaries[1])
			result = 0;
	}
	return (result);
}

int	c_in_10(char *characters_for_base, char c, int base_len)
{
	int	i;
	int	result;

	result = -1;
	if (characters_for_base && c != '\0' && base_len > 0)
	{
		i = 0;
		while (i < base_len && characters_for_base[i])
		{
			if (c == characters_for_base[i])
				return (i);
			i++;
		}
	}
	return (result);
}

int	ft_atoi_base(char *str, char *base)
{
	int				len;
	long			res;
	unsigned int	boundaries[2];
	unsigned int	i;

	len = ft_error_or_base(base);
	if (len)
	{
		res = (long) ft_error_or_sign(boundaries, str, base, len);
		if (res == 0)
			return (0);
		else
		{
			i = boundaries[0];
			res *= ft_c_into_10(base, str[i], len);
			while (i <= boundaries[1])
				res = (res * len) + c_in_10(base, str[i], len);
		}
		if ((int) res < INT_MIN || (int) res > INT_MAX)
			return (0);
		else
			return ((int) res);
	}
	else
		return (0);
}
e3r11p9% vi ft_convert_base2.c                                      
e3r11p9% norminette -R CheckForbiddenSourceHeader ft_convert_base2.c
ft_convert_base2.c: OK!
e3r11p9% cat ft_convert_base2.c                                     
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_convert_base2.c                                 :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: hauerbac <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2023/03/01 12:00:09 by hauerbac          #+#    #+#             */
/*   Updated: 2023/03/01 12:21:41 by hauerbac         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include <limits.h>

int	ft_error_or_base(const char *str);

unsigned int	ft_spaces_truncating(const char *str)
{
	unsigned int	i;

	i = 0;
	if (str)
	{
		while (str[i]
			&& (str[i] == ' ' || str[i] == '\f'
				|| str[i] == '\n' || str[i] == '\r'
				|| str[i] == '\t' || str[i] == '\v'))
			i++;
	}
	return (i);
}

int	ft_char_is_into_base(char *characters_for_base, char c, int base_len)
{
	int	i;
	int	result;

	result = 0;
	if (characters_for_base && c != '\0' && base_len > 0)
	{
		i = 0;
		while (i < base_len && characters_for_base[i])
		{
			if (c == characters_for_base[i])
				return (1);
			i++;
		}
	}
	return (result);
}

int	ft_error_or_sign(unsigned int boundaries[2], const char *str, char *base
		, int base_len)
{
	int				result;
	unsigned int	i;

	result = 0;
	boundaries[0] = -1;
	boundaries[1] = -2;
	if (str)
	{
		result = 1;
		i = ft_spaces_truncating(str);
		while (str[i] && (str[i] == '+' || str[i] == '-'))
		{
			if (str[i] == '-')
				result = -1 * result;
			i++;
		}
		if (str[i] && ft_char_is_into_base(base, str[i], base_len))
			boundaries[0] = (unsigned int)i;
		while (str[i] && ft_char_is_into_base(base, str[i], base_len))
			boundaries[1] = (unsigned int)i++;
		if (boundaries[0] == -1 || boundaries[1] == -2
			|| boundaries[0] > boundaries[1])
			result = 0;
	}
	return (result);
}

int	c_in_10(char *characters_for_base, char c, int base_len)
{
	int	i;
	int	result;

	result = -1;
	if (characters_for_base && c != '\0' && base_len > 0)
	{
		i = 0;
		while (i < base_len && characters_for_base[i])
		{
			if (c == characters_for_base[i])
				return (i);
			i++;
		}
	}
	return (result);
}

int	ft_atoi_base(char *str, char *base)
{
	int				len;
	long			res;
	unsigned int	boundaries[2];
	unsigned int	i;

	len = ft_error_or_base(base);
	if (len)
	{
		res = (long) ft_error_or_sign(boundaries, str, base, len);
		if (res == 0)
			return (0);
		else
		{
			i = boundaries[0];
			res *= ft_c_into_10(base, str[i], len);
			while (i <= boundaries[1])
				res = (res * len) + c_in_10(base, str[i], len);
		}
		if ((int) res < INT_MIN || (int) res > INT_MAX)
			return (0);
		else
			return ((int) res);
	}
	else
		return (0);
}
e3r11p9% vi ft_convert_base2.c                                      
e3r11p9% vi ft_convert_base2.c 
e3r11p9% norminette -R CheckForbiddenSourceHeader ft_convert_base2.c
ft_convert_base2.c: OK!
e3r11p9% cat ft_convert_base2.c                                     
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_convert_base2.c                                 :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: hauerbac <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2023/03/01 12:00:09 by hauerbac          #+#    #+#             */
/*   Updated: 2023/03/01 13:09:40 by hauerbac         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include <limits.h>

int	ft_error_or_base(const char *str);

unsigned int	ft_spaces_truncating(const char *str)
{
	unsigned int	i;

	i = 0;
	if (str)
	{
		while (str[i]
			&& (str[i] == ' ' || str[i] == '\f'
				|| str[i] == '\n' || str[i] == '\r'
				|| str[i] == '\t' || str[i] == '\v'))
			i++;
	}
	return (i);
}

int	ft_char_is_into_base(char *characters_for_base, char c, int base_len)
{
	int	i;
	int	result;

	result = 0;
	if (characters_for_base && c != '\0' && base_len > 0)
	{
		i = 0;
		while (i < base_len && characters_for_base[i])
		{
			if (c == characters_for_base[i])
				return (1);
			i++;
		}
	}
	return (result);
}

int	ft_error_or_sign(unsigned int boundaries[2], const char *str, char *base
		, int base_len)
{
	int				result;
	unsigned int	i;

	result = 0;
	boundaries[0] = -1;
	boundaries[1] = -2;
	if (str)
	{
		result = 1;
		i = ft_spaces_truncating(str);
		while (str[i] && (str[i] == '+' || str[i] == '-'))
		{
			if (str[i] == '-')
				result = -1 * result;
			i++;
		}
		if (str[i] && ft_char_is_into_base(base, str[i], base_len))
			boundaries[0] = (unsigned int)i;
		while (str[i] && ft_char_is_into_base(base, str[i], base_len))
			boundaries[1] = (unsigned int)i++;
		if (boundaries[0] == -1 || boundaries[1] == -2
			|| boundaries[0] > boundaries[1])
			result = 0;
	}
	return (result);
}

int	c_in_10(char *characters_for_base, char c, int base_len)
{
	int	i;
	int	result;

	result = -1;
	if (characters_for_base && c != '\0' && base_len > 0)
	{
		i = 0;
		while (i < base_len && characters_for_base[i])
		{
			if (c == characters_for_base[i])
				return (i);
			i++;
		}
	}
	return (result);
}

int	ft_atoi_base(char *str, char *base)
{
	int				len;
	long			res;
	unsigned int	boundaries[2];
	unsigned int	i;

	len = ft_error_or_base(base);
	if (len)
	{
		res = (long) ft_error_or_sign(boundaries, str, base, len);
		if (res == 0)
			return (0);
		else
		{
			i = boundaries[0];
			res *= c_in_10(base, str[i], len);
			while (i <= boundaries[1])
				res = (res * len) + c_in_10(base, str[i], len);
		}
		if ((int) res < INT_MIN || (int) res > INT_MAX)
			return (0);
		else
			return ((int) res);
	}
	else
		return (0);
}
e3r11p9% vi ft_convert_base2.c                                      
e3r11p9% norminette -R CheckForbiddenSourceHeader ft_convert_base2.c
ft_convert_base2.c: OK!
e3r11p9% cat ft_convert_base2.c                                     
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_convert_base2.c                                 :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: hauerbac <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2023/03/01 12:00:09 by hauerbac          #+#    #+#             */
/*   Updated: 2023/03/01 13:26:52 by hauerbac         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include <limits.h>

int	ft_error_or_base(const char *str);

unsigned int	ft_spaces_truncating(const char *str)
{
	unsigned int	i;

	i = 0;
	if (str)
	{
		while (str[i]
			&& (str[i] == ' ' || str[i] == '\f'
				|| str[i] == '\n' || str[i] == '\r'
				|| str[i] == '\t' || str[i] == '\v'))
			i++;
	}
	return (i);
}

int	ft_char_is_into_base(char *characters_for_base, char c, int base_len)
{
	int	i;
	int	result;

	result = 0;
	if (characters_for_base && c != '\0' && base_len > 0)
	{
		i = 0;
		while (i < base_len && characters_for_base[i])
		{
			if (c == characters_for_base[i])
				return (1);
			i++;
		}
	}
	return (result);
}

int	ft_error_or_sign(unsigned int boundaries[2], const char *str,
		char *base, int base_len)
{
	int				result;
	unsigned int	i;

	result = 0;
	boundaries[0] = -1;
	boundaries[1] = -2;
	if (str)
	{
		result = 1;
		i = ft_spaces_truncating(str);
		while (str[i] && (str[i] == '+' || str[i] == '-'))
		{
			if (str[i] == '-')
				result = -1 * result;
			i++;
		}
		if (str[i] && ft_char_is_into_base(base, str[i], base_len))
			boundaries[0] = (unsigned int)i;
		while (str[i] && ft_char_is_into_base(base, str[i], base_len))
			boundaries[1] = (unsigned int)i++;
		if (boundaries[0] == -1 || boundaries[1] == -2
			|| boundaries[0] > boundaries[1])
			result = 0;
	}
	return (result);
}

int	c_in_10(char *characters_for_base, char c, int base_len)
{
	int	i;
	int	result;

	result = -1;
	if (characters_for_base && c != '\0' && base_len > 0)
	{
		i = 0;
		while (i < base_len && characters_for_base[i])
		{
			if (c == characters_for_base[i])
				return (i);
			i++;
		}
	}
	return (result);
}

int	ft_atoi_base(char *str, char *base)
{
	int				len;
	long			res;
	unsigned int	boundaries[2];
	unsigned int	i;

	len = ft_error_or_base(base);
	if (len)
	{
		res = (long) ft_error_or_sign(boundaries, str, base, len);
		if (res == 0)
			return (0);
		else
		{
			i = boundaries[0];
			res *= c_in_10(base, str[i], len);
			while (i <= boundaries[1])
				res = (res * len) + c_in_10(base, str[i], len);
		}
		if ((int) res < INT_MIN || (int) res > INT_MAX)
			return (0);
		else
			return ((int) res);
	}
	else
		return (0);
}
e3r11p9% gcc -Wall -Wextra -Werror -o test_ft_convert_base ft_convert_base.c ft_convert_base2.c test_ft_convert_base.c 
ft_convert_base.c: In function â€˜ft_itoa_baseâ€™:
ft_convert_base.c:94:4: error: too few arguments to function â€˜ft_itoa_baseâ€™
   94 |    ft_itoa_base(nb_into_long / base_len, base);
      |    ^~~~~~~~~~~~
ft_convert_base.c:74:7: note: declared here
   74 | char *ft_itoa_base(int nb, char *base, int base_len)
      |       ^~~~~~~~~~~~
ft_convert_base.c:95:4: error: too few arguments to function â€˜ft_itoa_baseâ€™
   95 |    ft_itoa_base(nb_into_long % base_len, base);
      |    ^~~~~~~~~~~~
ft_convert_base.c:74:7: note: declared here
   74 | char *ft_itoa_base(int nb, char *base, int base_len)
      |       ^~~~~~~~~~~~
ft_convert_base2.c: In function â€˜ft_error_or_signâ€™:
ft_convert_base2.c:75:21: error: comparison of integer expressions of different signedness: â€˜unsigned intâ€™ and â€˜intâ€™ [-Werror=sign-compare]
   75 |   if (boundaries[0] == -1 || boundaries[1] == -2
      |                     ^~
ft_convert_base2.c:75:44: error: comparison of integer expressions of different signedness: â€˜unsigned intâ€™ and â€˜intâ€™ [-Werror=sign-compare]
   75 |   if (boundaries[0] == -1 || boundaries[1] == -2
      |                                            ^~
cc1: all warnings being treated as errors
e3r11p9% vi ft_convert_base.c                                      
e3r11p9% norminette -R CheckForbiddenSourceHeader ft_convert_base.c             
ft_convert_base.c: OK!
e3r11p9% vi ft_convert_base2.c                                      
e3r11p9% norminette -R CheckForbiddenSourceHeader ft_convert_base2.c
ft_convert_base2.c: OK!
e3r11p9% cat ft_convert_base2.c                                     
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_convert_base2.c                                 :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: hauerbac <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2023/03/01 12:00:09 by hauerbac          #+#    #+#             */
/*   Updated: 2023/03/01 15:04:19 by hauerbac         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include <limits.h>

int	ft_error_or_base(const char *str);

unsigned int	ft_spaces_truncating(const char *str)
{
	unsigned int	i;

	i = 0;
	if (str)
	{
		while (str[i]
			&& (str[i] == ' ' || str[i] == '\f'
				|| str[i] == '\n' || str[i] == '\r'
				|| str[i] == '\t' || str[i] == '\v'))
			i++;
	}
	return (i);
}

int	ft_char_is_into_base(char *characters_for_base, char c, int base_len)
{
	int	i;
	int	result;

	result = 0;
	if (characters_for_base && c != '\0' && base_len > 0)
	{
		i = 0;
		while (i < base_len && characters_for_base[i])
		{
			if (c == characters_for_base[i])
				return (1);
			i++;
		}
	}
	return (result);
}

int	ft_error_or_sign(int boundaries[2], const char *str,
		char *base, int base_len)
{
	int	result;
	int	i;

	result = 0;
	boundaries[0] = -1;
	boundaries[1] = -2;
	if (str)
	{
		result = 1;
		i = ft_spaces_truncating(str);
		while (str[i] && (str[i] == '+' || str[i] == '-'))
		{
			if (str[i] == '-')
				result = -1 * result;
			i++;
		}
		if (str[i] && ft_char_is_into_base(base, str[i], base_len))
			boundaries[0] = i;
		while (str[i] && ft_char_is_into_base(base, str[i], base_len))
			boundaries[1] = i++;
		if (boundaries[0] == -1 || boundaries[1] == -2
			|| boundaries[0] > boundaries[1])
			result = 0;
	}
	return (result);
}

int	c_in_10(char *characters_for_base, char c, int base_len)
{
	int	i;
	int	result;

	result = -1;
	if (characters_for_base && c != '\0' && base_len > 0)
	{
		i = 0;
		while (i < base_len && characters_for_base[i])
		{
			if (c == characters_for_base[i])
				return (i);
			i++;
		}
	}
	return (result);
}

int	ft_atoi_base(char *str, char *base)
{
	int		len;
	long	res;
	int		boundaries[2];
	int		i;

	len = ft_error_or_base(base);
	if (len)
	{
		res = (long) ft_error_or_sign(boundaries, str, base, len);
		if (res == 0)
			return (0);
		else
		{
			i = boundaries[0];
			res *= c_in_10(base, str[i], len);
			while (i <= boundaries[1])
				res = (res * len) + c_in_10(base, str[i], len);
		}
		if ((int) res < INT_MIN || (int) res > INT_MAX)
			return (0);
		else
			return ((int) res);
	}
	else
		return (0);
}
e3r11p9% gcc -Wall -Wextra -Werror -o test_ft_convert_base ft_convert_base.c ft_convert_base2.c test_ft_convert_base.c 
ft_convert_base.c: In function â€˜ft_itoa_baseâ€™:
ft_convert_base.c:94:4: error: too few arguments to function â€˜ft_itoa_baseâ€™
   94 |    ft_itoa_base(nb_into_long / base_len, base);
      |    ^~~~~~~~~~~~
ft_convert_base.c:74:7: note: declared here
   74 | char *ft_itoa_base(int nb, char *base, int base_len)
      |       ^~~~~~~~~~~~
ft_convert_base.c:95:4: error: too few arguments to function â€˜ft_itoa_baseâ€™
   95 |    ft_itoa_base(nb_into_long % base_len, base);
      |    ^~~~~~~~~~~~
ft_convert_base.c:74:7: note: declared here
   74 | char *ft_itoa_base(int nb, char *base, int base_len)
      |       ^~~~~~~~~~~~
ft_convert_base2.c: In function â€˜ft_error_or_signâ€™:
ft_convert_base2.c:75:21: error: comparison of integer expressions of different signedness: â€˜unsigned intâ€™ and â€˜intâ€™ [-Werror=sign-compare]
   75 |   if (boundaries[0] == -1 || boundaries[1] == -2
      |                     ^~
ft_convert_base2.c:75:44: error: comparison of integer expressions of different signedness: â€˜unsigned intâ€™ and â€˜intâ€™ [-Werror=sign-compare]
   75 |   if (boundaries[0] == -1 || boundaries[1] == -2
      |                                            ^~
cc1: all warnings being treated as errors
e3r11p9% vi ft_convert_base.c                                      
e3r11p9% norminette -R CheckForbiddenSourceHeader ft_convert_base.c             
ft_convert_base.c: OK!
e3r11p9% gcc -Wall -Wextra -Werror -o test_ft_convert_base ft_convert_base.c ft_convert_base2.c test_ft_convert_base.c
/usr/bin/ld: /tmp/ccsbo1b5.o: in function `ft_atoi_base':
ft_convert_base2.c:(.text+0x33a): undefined reference to `ft_error_or_base'
collect2: error: ld returned 1 exit status
e3r11p9% cat ft_convert_base.c
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_convert_base.c                                  :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: hauerbac <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2023/03/01 14:33:49 by hauerbac          #+#    #+#             */
/*   Updated: 2023/03/01 14:56:05 by hauerbac         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include <stdlib.h>
#include <stddef.h>

int	ft_atoi_base(char *str, char *base);

int	ft_error_or_strlen(const char *str)
{
	int	base_len;
	int	i;

	base_len = -1;
	i = 0;
	while (str && str[i] != '\0')
	{
		if (str[i] == ' ' || str[i] == '\f'
			|| str[i] == '\n' || str[i] == '\r'
			|| str[i] == '\t' || str[i] == '\v')
			return (0);
		i++;
	}
	base_len = i;
	return (base_len);
}

int	ft_error_or_correct_base(const char *str, int base_len)
{
	int	i;
	int	j;

	i = 0;
	while (i < base_len)
	{
		if (str[i] == '+' || str[i] == '-')
			return (0);
		else if (i > 0 && str[i])
		{
			j = 0;
			while (j < i && str[j])
			{
				if (str[j] == str[i])
					return (0);
				j++;
			}
		}
		i++;
	}
	if (i == base_len)
		return (base_len);
	return (0);
}

int	ft_error_or_base_len(const char *str)
{
	int	base_len;

	base_len = ft_error_or_strlen(str);
	if (base_len < 2)
		return (0);
	return (ft_error_or_correct_base(str, base_len));
}

char	*ft_itoa_base(int nb, char *base, int base_len)
{
	char	*result;
	long	nb_into_long;
	int		i;

	result = (char *) malloc((11 + 1) * sizeof(char));
	if (result)
	{
		nb_into_long = nb;
		i = 0;
		if (nb_into_long < 0)
		{
			result[i++] = '-';
			nb_into_long *= -1;
		}
		if (nb_into_long < base_len)
			result[i++] = base[nb_into_long];
		else
		{
			ft_itoa_base(nb_into_long / base_len, base, base_len);
			ft_itoa_base(nb_into_long % base_len, base, base_len);
		}
		result[i] = '\0';
	}
	return (result);
}

char	*ft_convert_base(char *nbr, char *base_from, char *base_to)
{
	int	base_from_len;
	int	base_to_len;
	int	nb_from_base_from;

	base_from_len = ft_error_or_base_len(base_from);
	base_to_len = ft_error_or_base_len(base_to);
	if (base_from_len && base_to_len && nbr)
	{
		nb_from_base_from = ft_atoi_base(nbr, base_from);
		return (ft_itoa_base(nb_from_base_from, base_to, base_to_len));
	}
	return (NULL);
}
e3r11p9% vi ft_convert_base2.c                                      
e3r11p9% norminette -R CheckForbiddenSourceHeader ft_convert_base2.c
ft_convert_base2.c: OK!
e3r11p9% cat ft_convert_base2.c                                     
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_convert_base2.c                                 :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: hauerbac <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2023/03/01 12:00:09 by hauerbac          #+#    #+#             */
/*   Updated: 2023/03/01 15:12:14 by hauerbac         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include <limits.h>

int	ft_error_or_base_len(const char *str);

unsigned int	ft_spaces_truncating(const char *str)
{
	unsigned int	i;

	i = 0;
	if (str)
	{
		while (str[i]
			&& (str[i] == ' ' || str[i] == '\f'
				|| str[i] == '\n' || str[i] == '\r'
				|| str[i] == '\t' || str[i] == '\v'))
			i++;
	}
	return (i);
}

int	ft_char_is_into_base(char *characters_for_base, char c, int base_len)
{
	int	i;
	int	result;

	result = 0;
	if (characters_for_base && c != '\0' && base_len > 0)
	{
		i = 0;
		while (i < base_len && characters_for_base[i])
		{
			if (c == characters_for_base[i])
				return (1);
			i++;
		}
	}
	return (result);
}

int	ft_error_or_sign(int boundaries[2], const char *str,
		char *base, int base_len)
{
	int	result;
	int	i;

	result = 0;
	boundaries[0] = -1;
	boundaries[1] = -2;
	if (str)
	{
		result = 1;
		i = ft_spaces_truncating(str);
		while (str[i] && (str[i] == '+' || str[i] == '-'))
		{
			if (str[i] == '-')
				result = -1 * result;
			i++;
		}
		if (str[i] && ft_char_is_into_base(base, str[i], base_len))
			boundaries[0] = i;
		while (str[i] && ft_char_is_into_base(base, str[i], base_len))
			boundaries[1] = i++;
		if (boundaries[0] == -1 || boundaries[1] == -2
			|| boundaries[0] > boundaries[1])
			result = 0;
	}
	return (result);
}

int	c_in_10(char *characters_for_base, char c, int base_len)
{
	int	i;
	int	result;

	result = -1;
	if (characters_for_base && c != '\0' && base_len > 0)
	{
		i = 0;
		while (i < base_len && characters_for_base[i])
		{
			if (c == characters_for_base[i])
				return (i);
			i++;
		}
	}
	return (result);
}

int	ft_atoi_base(char *str, char *base)
{
	int		len;
	long	res;
	int		boundaries[2];
	int		i;

	len = ft_error_or_base_len(base);
	if (len)
	{
		res = (long) ft_error_or_sign(boundaries, str, base, len);
		if (res == 0)
			return (0);
		else
		{
			i = boundaries[0];
			res *= c_in_10(base, str[i], len);
			while (i <= boundaries[1])
				res = (res * len) + c_in_10(base, str[i], len);
		}
		if ((int) res < INT_MIN || (int) res > INT_MAX)
			return (0);
		else
			return ((int) res);
	}
	else
		return (0);
}
e3r11p9% cat test_ft_convert_base.c
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   test_ft_convert_base.c                             :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: hauerbac <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2023/03/01 14:53:06 by hauerbac          #+#    #+#             */
/*   Updated: 2023/03/01 15:18:37 by hauerbac         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include <stdio.h>

char	*ft_convert_base(char *nbr, char *base_from, char *base_to);

int	main(void)
{
	printf("42 en base 10: %s", ft_convert_base("42", "0123456789", "0123456789"));
	printf("\n2a == 42 en base 16: %s", ft_convert_base("2a", "0123456789abcdef", "0123456789"));
	printf("\n-2a == -42 en base 16: %s", ft_convert_base("-2a", "0123456789abcdef", "0123456789"));
	printf("\n (42 en base vide): %s", ft_convert_base("42", "0123456789", ""));
	printf("\n (42 en base de taille 1): %s", ft_convert_base("42", "0", "0123456789"));
	printf("\n (42 en base 16 avec + et -): %s", ft_convert_base("42", "0123456789", "+-0123456789abcdef"));
	printf("\n (42 en base 16 avec une tabulation): %s", ft_convert_base("42", "0123456789", "\t0123456789abcdef"));
	printf("\n101010 == 42 en base 2: %s", ft_convert_base("42", "0123456789", "01"));
	printf("\nvn == 42 en base 8 (\"poneyvif\"): %s", ft_convert_base("vn", "poneyvif", "0123456789"));
}
e3r11p9% gcc -Wall -Wextra -Werror -o test_ft_convert_base ft_convert_base.c ft_convert_base2.c test_ft_convert_base.c
e3r11p9% ls -al                                                                                                     
total 40
drwxr-xr-x 2 hauerbac 2023_paris  4096 Mar  1 15:19 .
drwxr-xr-x 7 hauerbac 2023_paris  4096 Mar  1 08:41 ..
-rw-r--r-- 1 hauerbac 2023_paris  2990 Mar  1 15:12 ft_convert_base2.c
-rw-r--r-- 1 hauerbac 2023_paris  2758 Mar  1 14:56 ft_convert_base.c
-rwxr-xr-x 1 hauerbac 2023_paris 16552 Mar  1 15:19 test_ft_convert_base
-rw-r--r-- 1 hauerbac 2023_paris  1841 Mar  1 15:18 test_ft_convert_base.c
e3r11p9% ./test_ft_convert_base                                                                                     
^C
e3r11p9% lldb test_ft_convert_base                                                                                       
(lldb) target create "test_ft_convert_base"
Current executable set to '/mnt/nfs/homes/hauerbac/c_07/ex04/test_ft_convert_base' (x86_64).
(lldb) b main
Breakpoint 1: where = test_ft_convert_base`main + 8 at test_ft_convert_base.c:19:2, address = 0x00000000000018ff
(lldb) run
warning: (x86_64) /usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2 unsupported DW_FORM value: 0x1f
Process 794833 launched: '/mnt/nfs/homes/hauerbac/c_07/ex04/test_ft_convert_base' (x86_64)
warning: (x86_64) /lib64/ld-linux-x86-64.so.2 unsupported DW_FORM value: 0x1f
warning: (x86_64) /lib/x86_64-linux-gnu/libc.so.6 unsupported DW_FORM value: 0x1f
Process 794833 stopped
* thread #1, name = 'test_ft_convert', stop reason = breakpoint 1.1
    frame #0: 0x00005555555558ff test_ft_convert_base`main at test_ft_convert_base.c:19:2
   16  	
   17  	int	main(void)
   18  	{
-> 19  		printf("42 en base 10: %s", ft_convert_base("42", "0123456789", "0123456789"));
   20  		printf("\n2a == 42 en base 16: %s", ft_convert_base("2a", "0123456789abcdef", "0123456789"));
   21  		printf("\n-2a == -42 en base 16: %s", ft_convert_base("-2a", "0123456789abcdef", "0123456789"));
   22  		printf("\n (42 en base vide): %s", ft_convert_base("42", "0123456789", ""));
(lldb) gui
(lldb) q
Quitting LLDB will kill one or more processes. Do you really want to proceed: [Y/n] y
e3r11p9% vi ft_convert_base2.c                                      
e3r11p9% norminette -R CheckForbiddenSourceHeader ft_convert_base2.c
ft_convert_base2.c: OK!
e3r11p9% cat ft_convert_base2.c                                     
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_convert_base2.c                                 :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: hauerbac <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2023/03/01 12:00:09 by hauerbac          #+#    #+#             */
/*   Updated: 2023/03/01 15:28:52 by hauerbac         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include <limits.h>

int	ft_error_or_base_len(const char *str);

unsigned int	ft_spaces_truncating(const char *str)
{
	unsigned int	i;

	i = 0;
	if (str)
	{
		while (str[i]
			&& (str[i] == ' ' || str[i] == '\f'
				|| str[i] == '\n' || str[i] == '\r'
				|| str[i] == '\t' || str[i] == '\v'))
			i++;
	}
	return (i);
}

int	ft_char_is_into_base(char *characters_for_base, char c, int base_len)
{
	int	i;
	int	result;

	result = 0;
	if (characters_for_base && c != '\0' && base_len > 0)
	{
		i = 0;
		while (i < base_len && characters_for_base[i])
		{
			if (c == characters_for_base[i])
				return (1);
			i++;
		}
	}
	return (result);
}

int	ft_error_or_sign(int boundaries[2], const char *str,
		char *base, int base_len)
{
	int	result;
	int	i;

	result = 0;
	boundaries[0] = -1;
	boundaries[1] = -2;
	if (str)
	{
		result = 1;
		i = ft_spaces_truncating(str);
		while (str[i] && (str[i] == '+' || str[i] == '-'))
		{
			if (str[i] == '-')
				result = -1 * result;
			i++;
		}
		if (str[i] && ft_char_is_into_base(base, str[i], base_len))
			boundaries[0] = i;
		while (str[i] && ft_char_is_into_base(base, str[i], base_len))
			boundaries[1] = i++;
		if (boundaries[0] == -1 || boundaries[1] == -2
			|| boundaries[0] > boundaries[1])
			result = 0;
	}
	return (result);
}

int	c_in_10(char *characters_for_base, char c, int base_len)
{
	int	i;
	int	result;

	result = -1;
	if (characters_for_base && c != '\0' && base_len > 0)
	{
		i = 0;
		while (i < base_len && characters_for_base[i])
		{
			if (c == characters_for_base[i])
				return (i);
			i++;
		}
	}
	return (result);
}

int	ft_atoi_base(char *str, char *base)
{
	int		len;
	long	res;
	int		boundaries[2];
	int		i;

	len = ft_error_or_base_len(base);
	if (len)
	{
		res = (long) ft_error_or_sign(boundaries, str, base, len);
		if (res == 0)
			return (0);
		else
		{
			i = boundaries[0];
			res *= c_in_10(base, str[i++], len);
			while (i <= boundaries[1])
				res = (res * len) + c_in_10(base, str[i++], len);
		}
		if ((int) res < INT_MIN || (int) res > INT_MAX)
			return (0);
		else
			return ((int) res);
	}
	else
		return (0);
}
e3r11p9% gcc -Wall -Wextra -Werror -o test_ft_convert_base ft_convert_base.c ft_convert_base2.c test_ft_convert_base.c   
e3r11p9% ls -al                                                                                                          
total 40
drwxr-xr-x 2 hauerbac 2023_paris  4096 Mar  1 15:30 .
drwxr-xr-x 7 hauerbac 2023_paris  4096 Mar  1 08:41 ..
-rw-r--r-- 1 hauerbac 2023_paris  2994 Mar  1 15:28 ft_convert_base2.c
-rw-r--r-- 1 hauerbac 2023_paris  2758 Mar  1 14:56 ft_convert_base.c
-rwxr-xr-x 1 hauerbac 2023_paris 16552 Mar  1 15:30 test_ft_convert_base
-rw-r--r-- 1 hauerbac 2023_paris  1841 Mar  1 15:18 test_ft_convert_base.c
e3r11p9% ./test_ft_convert_base                                                                                          
42 en base 10: 
2a == 42 en base 16: 
-2a == -42 en base 16: -
 (42 en base vide): (null)
 (42 en base de taille 1): (null)
 (42 en base 16 avec + et -): (null)
 (42 en base 16 avec une tabulation): (null)
101010 == 42 en base 2: 
vn == 42 en base 8 ("poneyvif"): %                                                                                             
 e3r11p9% vi ft_convert_base.c                                      
e3r11p9% norminette -R CheckForbiddenSourceHeader ft_convert_base.c
ft_convert_base.c: Error!
Error: LINE_TOO_LONG        (line: 119, col:  82):	line too long
e3r11p9% vi ft_convert_base.c                                      
e3r11p9% norminette -R CheckForbiddenSourceHeader ft_convert_base.c
ft_convert_base.c: OK!
e3r11p9% gcc -Wall -Wextra -Werror -o test_ft_convert_base -g ft_convert_base.c ft_convert_base2.c test_ft_convert_base.c
ft_convert_base.c: In function â€˜ft_itoa_baseâ€™:
ft_convert_base.c:95:29: error: passing argument 1 of â€˜ft_itoa_baseâ€™ makes pointer from integer without a cast [-Werror=int-conversion]
   95 |   ft_itoa_base(nb_into_long / base_len, base, base_len);
      |                ~~~~~~~~~~~~~^~~~~~~~~~
      |                             |
      |                             long int
ft_convert_base.c:74:26: note: expected â€˜char *â€™ but argument is of type â€˜long intâ€™
   74 | char *ft_itoa_base(char *result, int nb, char *base, int base_len)
      |                    ~~~~~~^~~~~~
ft_convert_base.c:95:41: error: passing argument 2 of â€˜ft_itoa_baseâ€™ makes integer from pointer without a cast [-Werror=int-conversion]
   95 |   ft_itoa_base(nb_into_long / base_len, base, base_len);
      |                                         ^~~~
      |                                         |
      |                                         char *
ft_convert_base.c:74:38: note: expected â€˜intâ€™ but argument is of type â€˜char *â€™
   74 | char *ft_itoa_base(char *result, int nb, char *base, int base_len)
      |                                  ~~~~^~
ft_convert_base.c:95:47: error: passing argument 3 of â€˜ft_itoa_baseâ€™ makes pointer from integer without a cast [-Werror=int-conversion]
   95 |   ft_itoa_base(nb_into_long / base_len, base, base_len);
      |                                               ^~~~~~~~
      |                                               |
      |                                               int
ft_convert_base.c:74:48: note: expected â€˜char *â€™ but argument is of type â€˜intâ€™
   74 | char *ft_itoa_base(char *result, int nb, char *base, int base_len)
      |                                          ~~~~~~^~~~
ft_convert_base.c:95:3: error: too few arguments to function â€˜ft_itoa_baseâ€™
   95 |   ft_itoa_base(nb_into_long / base_len, base, base_len);
      |   ^~~~~~~~~~~~
ft_convert_base.c:74:7: note: declared here
   74 | char *ft_itoa_base(char *result, int nb, char *base, int base_len)
      |       ^~~~~~~~~~~~
ft_convert_base.c:96:29: error: passing argument 1 of â€˜ft_itoa_baseâ€™ makes pointer from integer without a cast [-Werror=int-conversion]
   96 |   ft_itoa_base(nb_into_long % base_len, base, base_len);
      |                ~~~~~~~~~~~~~^~~~~~~~~~
      |                             |
      |                             long int
ft_convert_base.c:74:26: note: expected â€˜char *â€™ but argument is of type â€˜long intâ€™
   74 | char *ft_itoa_base(char *result, int nb, char *base, int base_len)
      |                    ~~~~~~^~~~~~
ft_convert_base.c:96:41: error: passing argument 2 of â€˜ft_itoa_baseâ€™ makes integer from pointer without a cast [-Werror=int-conversion]
   96 |   ft_itoa_base(nb_into_long % base_len, base, base_len);
      |                                         ^~~~
      |                                         |
      |                                         char *
ft_convert_base.c:74:38: note: expected â€˜intâ€™ but argument is of type â€˜char *â€™
   74 | char *ft_itoa_base(char *result, int nb, char *base, int base_len)
      |                                  ~~~~^~
ft_convert_base.c:96:47: error: passing argument 3 of â€˜ft_itoa_baseâ€™ makes pointer from integer without a cast [-Werror=int-conversion]
   96 |   ft_itoa_base(nb_into_long % base_len, base, base_len);
      |                                               ^~~~~~~~
      |                                               |
      |                                               int
ft_convert_base.c:74:48: note: expected â€˜char *â€™ but argument is of type â€˜intâ€™
   74 | char *ft_itoa_base(char *result, int nb, char *base, int base_len)
      |                                          ~~~~~~^~~~
ft_convert_base.c:96:3: error: too few arguments to function â€˜ft_itoa_baseâ€™
   96 |   ft_itoa_base(nb_into_long % base_len, base, base_len);
      |   ^~~~~~~~~~~~
ft_convert_base.c:74:7: note: declared here
   74 | char *ft_itoa_base(char *result, int nb, char *base, int base_len)
      |       ^~~~~~~~~~~~
ft_convert_base.c: In function â€˜ft_convert_baseâ€™:
ft_convert_base.c:113:3: error: â€˜resultâ€™ undeclared (first use in this function)
  113 |   result = (char *) malloc((11 + 1) * sizeof(char));
      |   ^~~~~~
ft_convert_base.c:113:3: note: each undeclared identifier is reported only once for each function it appears in
ft_convert_base.c:120:18: error: passing argument 1 of â€˜ft_itoa_baseâ€™ makes pointer from integer without a cast [-Werror=int-conversion]
  120 |     ft_itoa_base(nb_from_base_from, base_to,
      |                  ^~~~~~~~~~~~~~~~~
      |                  |
      |                  int
ft_convert_base.c:74:26: note: expected â€˜char *â€™ but argument is of type â€˜intâ€™
   74 | char *ft_itoa_base(char *result, int nb, char *base, int base_len)
      |                    ~~~~~~^~~~~~
ft_convert_base.c:120:37: error: passing argument 2 of â€˜ft_itoa_baseâ€™ makes integer from pointer without a cast [-Werror=int-conversion]
  120 |     ft_itoa_base(nb_from_base_from, base_to,
      |                                     ^~~~~~~
      |                                     |
      |                                     char *
ft_convert_base.c:74:38: note: expected â€˜intâ€™ but argument is of type â€˜char *â€™
   74 | char *ft_itoa_base(char *result, int nb, char *base, int base_len)
      |                                  ~~~~^~
ft_convert_base.c:121:6: error: passing argument 3 of â€˜ft_itoa_baseâ€™ makes pointer from integer without a cast [-Werror=int-conversion]
  121 |      base_to_len));
      |      ^~~~~~~~~~~
      |      |
      |      int
ft_convert_base.c:74:48: note: expected â€˜char *â€™ but argument is of type â€˜intâ€™
   74 | char *ft_itoa_base(char *result, int nb, char *base, int base_len)
      |                                          ~~~~~~^~~~
ft_convert_base.c:120:5: error: too few arguments to function â€˜ft_itoa_baseâ€™
  120 |     ft_itoa_base(nb_from_base_from, base_to,
      |     ^~~~~~~~~~~~
ft_convert_base.c:74:7: note: declared here
   74 | char *ft_itoa_base(char *result, int nb, char *base, int base_len)
      |       ^~~~~~~~~~~~
ft_convert_base.c:119:18: error: left-hand operand of comma expression has no effect [-Werror=unused-value]
  119 |    return (result,
      |                  ^
cc1: all warnings being treated as errors
e3r11p9% vi ft_convert_base.c                                                      
e3r11p9% norminette -R CheckForbiddenSourceHeader ft_convert_base.c                                                      
ft_convert_base.c: OK!
e3r11p9% gcc -Wall -Wextra -Werror -o test_ft_convert_base -g ft_convert_base.c ft_convert_base2.c test_ft_convert_base.c
ft_convert_base.c: In function â€˜ft_convert_baseâ€™:
ft_convert_base.c:113:3: error: â€˜resultâ€™ undeclared (first use in this function)
  113 |   result = (char *) malloc((11 + 1) * sizeof(char));
      |   ^~~~~~
ft_convert_base.c:113:3: note: each undeclared identifier is reported only once for each function it appears in
ft_convert_base.c:120:18: error: passing argument 1 of â€˜ft_itoa_baseâ€™ makes pointer from integer without a cast [-Werror=int-conversion]
  120 |     ft_itoa_base(nb_from_base_from, base_to,
      |                  ^~~~~~~~~~~~~~~~~
      |                  |
      |                  int
ft_convert_base.c:74:26: note: expected â€˜char *â€™ but argument is of type â€˜intâ€™
   74 | char *ft_itoa_base(char *result, int nb, char *base, int base_len)
      |                    ~~~~~~^~~~~~
ft_convert_base.c:120:37: error: passing argument 2 of â€˜ft_itoa_baseâ€™ makes integer from pointer without a cast [-Werror=int-conversion]
  120 |     ft_itoa_base(nb_from_base_from, base_to,
      |                                     ^~~~~~~
      |                                     |
      |                                     char *
ft_convert_base.c:74:38: note: expected â€˜intâ€™ but argument is of type â€˜char *â€™
   74 | char *ft_itoa_base(char *result, int nb, char *base, int base_len)
      |                                  ~~~~^~
ft_convert_base.c:121:6: error: passing argument 3 of â€˜ft_itoa_baseâ€™ makes pointer from integer without a cast [-Werror=int-conversion]
  121 |      base_to_len));
      |      ^~~~~~~~~~~
      |      |
      |      int
ft_convert_base.c:74:48: note: expected â€˜char *â€™ but argument is of type â€˜intâ€™
   74 | char *ft_itoa_base(char *result, int nb, char *base, int base_len)
      |                                          ~~~~~~^~~~
ft_convert_base.c:120:5: error: too few arguments to function â€˜ft_itoa_baseâ€™
  120 |     ft_itoa_base(nb_from_base_from, base_to,
      |     ^~~~~~~~~~~~
ft_convert_base.c:74:7: note: declared here
   74 | char *ft_itoa_base(char *result, int nb, char *base, int base_len)
      |       ^~~~~~~~~~~~
ft_convert_base.c:119:18: error: left-hand operand of comma expression has no effect [-Werror=unused-value]
  119 |    return (result,
      |                  ^
cc1: all warnings being treated as errors
e3r11p9% vi ft_convert_base.c                                                      
e3r11p9% norminette -R CheckForbiddenSourceHeader ft_convert_base.c                                                      
ft_convert_base.c: OK!
e3r11p9% gcc -Wall -Wextra -Werror -o test_ft_convert_base -g ft_convert_base.c ft_convert_base2.c test_ft_convert_base.c
ft_convert_base.c: In function â€˜ft_convert_baseâ€™:
ft_convert_base.c:121:18: error: passing argument 1 of â€˜ft_itoa_baseâ€™ makes pointer from integer without a cast [-Werror=int-conversion]
  121 |     ft_itoa_base(nb_from_base_from, base_to,
      |                  ^~~~~~~~~~~~~~~~~
      |                  |
      |                  int
ft_convert_base.c:74:26: note: expected â€˜char *â€™ but argument is of type â€˜intâ€™
   74 | char *ft_itoa_base(char *result, int nb, char *base, int base_len)
      |                    ~~~~~~^~~~~~
ft_convert_base.c:121:37: error: passing argument 2 of â€˜ft_itoa_baseâ€™ makes integer from pointer without a cast [-Werror=int-conversion]
  121 |     ft_itoa_base(nb_from_base_from, base_to,
      |                                     ^~~~~~~
      |                                     |
      |                                     char *
ft_convert_base.c:74:38: note: expected â€˜intâ€™ but argument is of type â€˜char *â€™
   74 | char *ft_itoa_base(char *result, int nb, char *base, int base_len)
      |                                  ~~~~^~
ft_convert_base.c:122:6: error: passing argument 3 of â€˜ft_itoa_baseâ€™ makes pointer from integer without a cast [-Werror=int-conversion]
  122 |      base_to_len));
      |      ^~~~~~~~~~~
      |      |
      |      int
ft_convert_base.c:74:48: note: expected â€˜char *â€™ but argument is of type â€˜intâ€™
   74 | char *ft_itoa_base(char *result, int nb, char *base, int base_len)
      |                                          ~~~~~~^~~~
ft_convert_base.c:121:5: error: too few arguments to function â€˜ft_itoa_baseâ€™
  121 |     ft_itoa_base(nb_from_base_from, base_to,
      |     ^~~~~~~~~~~~
ft_convert_base.c:74:7: note: declared here
   74 | char *ft_itoa_base(char *result, int nb, char *base, int base_len)
      |       ^~~~~~~~~~~~
ft_convert_base.c:120:18: error: left-hand operand of comma expression has no effect [-Werror=unused-value]
  120 |    return (result,
      |                  ^
cc1: all warnings being treated as errors
e3r11p9% vi ft_convert_base.c                                                      
e3r11p9% norminette -R CheckForbiddenSourceHeader ft_convert_base.c                                                      
ft_convert_base.c: OK!
e3r11p9% gcc -Wall -Wextra -Werror -o test_ft_convert_base -g ft_convert_base.c ft_convert_base2.c test_ft_convert_base.c
e3r11p9% ls -al                                                                                                       
total 44
drwxr-xr-x 2 hauerbac 2023_paris  4096 Mar  1 16:08 .
drwxr-xr-x 7 hauerbac 2023_paris  4096 Mar  1 08:41 ..
-rw-r--r-- 1 hauerbac 2023_paris  2994 Mar  1 15:28 ft_convert_base2.c
-rw-r--r-- 1 hauerbac 2023_paris  2937 Mar  1 16:08 ft_convert_base.c
-rwxr-xr-x 1 hauerbac 2023_paris 20704 Mar  1 16:08 test_ft_convert_base
-rw-r--r-- 1 hauerbac 2023_paris  1841 Mar  1 15:18 test_ft_convert_base.c
e3r11p9% ./test_ft_convert_base                                                                                    
42 en base 10: 42
2a == 42 en base 16: 42
-2a == -42 en base 16: -22
 (42 en base vide): (null)
 (42 en base de taille 1): (null)
 (42 en base 16 avec + et -): (null)
 (42 en base 16 avec une tabulation): (null)
101010 == 42 en base 2: 101010
vn == 42 en base 8 ("poneyvif"): 42%                                                                                           
 e3r11p9% vi ft_convert_base2.c                                      
e3r11p9% norminette -R CheckForbiddenSourceHeader ft_convert_base2.c
ft_convert_base2.c: OK!
e3r11p9% cat ft_convert_base2.c                                     
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_convert_base2.c                                 :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: hauerbac <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2023/03/01 12:00:09 by hauerbac          #+#    #+#             */
/*   Updated: 2023/03/01 17:23:11 by hauerbac         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include <limits.h>

int	ft_error_or_base_len(const char *str);

unsigned int	ft_spaces_truncating(const char *str)
{
	unsigned int	i;

	i = 0;
	if (str)
	{
		while (str[i]
			&& (str[i] == ' ' || str[i] == '\f'
				|| str[i] == '\n' || str[i] == '\r'
				|| str[i] == '\t' || str[i] == '\v'))
			i++;
	}
	return (i);
}

int	ft_char_is_into_base(char *characters_for_base, char c, int base_len)
{
	int	i;
	int	result;

	result = 0;
	if (characters_for_base && c != '\0' && base_len > 0)
	{
		i = 0;
		while (i < base_len && characters_for_base[i])
		{
			if (c == characters_for_base[i])
				return (1);
			i++;
		}
	}
	return (result);
}

int	ft_error_or_sign(int boundaries[2], const char *str,
		char *base, int base_len)
{
	int	result;
	int	i;

	result = 0;
	boundaries[0] = -1;
	boundaries[1] = -2;
	if (str)
	{
		result = 1;
		i = ft_spaces_truncating(str);
		while (str[i] && (str[i] == '+' || str[i] == '-'))
		{
			if (str[i] == '-')
				result = -1 * result;
			i++;
		}
		if (str[i] && ft_char_is_into_base(base, str[i], base_len))
			boundaries[0] = i;
		while (str[i] && ft_char_is_into_base(base, str[i], base_len))
			boundaries[1] = i++;
		if (boundaries[0] == -1 || boundaries[1] == -2
			|| boundaries[0] > boundaries[1])
			result = 0;
	}
	return (result);
}

int	c_in_10(char *characters_for_base, char c, int base_len)
{
	int	i;
	int	result;

	result = -1;
	if (characters_for_base && c != '\0' && base_len > 0)
	{
		i = 0;
		while (i < base_len && characters_for_base[i])
		{
			if (c == characters_for_base[i])
				return (i);
			i++;
		}
	}
	return (result);
}

int	ft_atoi_base(char *str, char *base)
{
	int	res;
	int	len;
	int	error_or_sign;
	int	i;
	int	boundaries[2];

	res = 0;
	len = ft_error_or_base_len(base);
	if (len)
	{
		error_or_sign = (long) ft_error_or_sign(boundaries, str, base, len);
		if (error_or_sign != 0)
		{
			i = boundaries[0];
			res = c_in_10(base, str[i++], len);
			while (i <= boundaries[1])
				res = (res * len) + c_in_10(base, str[i++], len);
			res *= error_or_sign;
		}
		if (res < INT_MIN || res > INT_MAX)
			return (0);
	}
	return (res);
}
e3r11p9% gcc -Wall -Wextra -Werror -o test_ft_convert_base -g ft_convert_base.c ft_convert_base2.c test_ft_convert_base.c
e3r11p9% ls -al                                                                                                          
total 56
drwxr-xr-x 2 hauerbac 2023_paris  4096 Mar  1 17:24 .
drwxr-xr-x 7 hauerbac 2023_paris  4096 Mar  1 08:41 ..
-rw-r--r-- 1 hauerbac 2023_paris  2995 Mar  1 17:23 ft_convert_base2.c
-rw-r--r-- 1 hauerbac 2023_paris 12288 Mar  1 17:23 .ft_convert_base2.c.swp
-rw-r--r-- 1 hauerbac 2023_paris  2937 Mar  1 16:08 ft_convert_base.c
-rwxr-xr-x 1 hauerbac 2023_paris 20696 Mar  1 17:24 test_ft_convert_base
-rw-r--r-- 1 hauerbac 2023_paris  1845 Mar  1 16:44 test_ft_convert_base.c
e3r11p9% lldb test_ft_convert_base                                                                                       
(lldb) target create "test_ft_convert_base"
Current executable set to '/mnt/nfs/homes/hauerbac/c_07/ex04/test_ft_convert_base' (x86_64).
(lldb) b c_in_10
Breakpoint 1: where = test_ft_convert_base`c_in_10 + 20 at ft_convert_base2.c:87:9, address = 0x00000000000017e1
(lldb) run
warning: (x86_64) /usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2 unsupported DW_FORM value: 0x1f
Process 817745 launched: '/mnt/nfs/homes/hauerbac/c_07/ex04/test_ft_convert_base' (x86_64)
warning: (x86_64) /lib64/ld-linux-x86-64.so.2 unsupported DW_FORM value: 0x1f
warning: (x86_64) /lib/x86_64-linux-gnu/libc.so.6 unsupported DW_FORM value: 0x1f
Process 817745 stopped
* thread #1, name = 'test_ft_convert', stop reason = breakpoint 1.1
    frame #0: 0x00005555555557e1 test_ft_convert_base`c_in_10(characters_for_base="0123456789abcdef", c='2', base_len=16) at ft_convert_base2.c:87:9
   84  		int	i;
   85  		int	result;
   86  	
-> 87  		result = -1;
   88  		if (characters_for_base && c != '\0' && base_len > 0)
   89  		{
   90  			i = 0;
(lldb) gui
(lldb) q
Quitting LLDB will kill one or more processes. Do you really want to proceed: [Y/n] y
e3r11p9% ls -al
total 44
drwxr-xr-x 2 hauerbac 2023_paris  4096 Mar  1 17:25 .
drwxr-xr-x 7 hauerbac 2023_paris  4096 Mar  1 08:41 ..
-rw-r--r-- 1 hauerbac 2023_paris  2995 Mar  1 17:23 ft_convert_base2.c
-rw-r--r-- 1 hauerbac 2023_paris  2937 Mar  1 16:08 ft_convert_base.c
-rwxr-xr-x 1 hauerbac 2023_paris 20696 Mar  1 17:24 test_ft_convert_base
-rw-r--r-- 1 hauerbac 2023_paris  1845 Mar  1 16:44 test_ft_convert_base.c
e3r11p9% vi test_ft_convert_base.c                                                                                  
e3r11p9% cat test_ft_convert_base.c 
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   test_ft_convert_base.c                             :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: hauerbac <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2023/03/01 14:53:06 by hauerbac          #+#    #+#             */
/*   Updated: 2023/03/01 17:28:21 by hauerbac         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include <stdio.h>

char	*ft_convert_base(char *nbr, char *base_from, char *base_to);

int	main(void)
{
	printf("42 en base 10: %s", ft_convert_base("42", "0123456789", "0123456789"));
	printf("\n2a == 42 en base 16: %s", ft_convert_base("2a", "0123456789abcdef", "0123456789"));
	printf("\n-2a == -42 en base 16: %s", ft_convert_base("-2a", "0123456789abcdef", "0123456789"));
	printf("\n (42 en base vide): %s", ft_convert_base("42", "0123456789", ""));
	printf("\n (42 en base de taille 1): %s", ft_convert_base("42", "0", "0123456789"));
	printf("\n (42 en base 16 avec + et -): %s", ft_convert_base("42", "0123456789", "+-0123456789abcdef"));
	printf("\n (42 en base 16 avec une tabulation): %s", ft_convert_base("42", "0123456789", "\t0123456789abcdef"));
	printf("\n101010 == 42 en base 2: %s", ft_convert_base("42", "0123456789", "01"));
	printf("\nvn == 42 en base 8 (\"poneyvif\"): %s", ft_convert_base("vn", "poneyvif", "0123456789"));
}
e3r11p9% gcc -Wall -Wextra -Werror -o test_ft_convert_base ft_convert_base.c ft_convert_base2.c test_ft_convert_base.c 
e3r11p9% ls -al                                                                                                      
total 40
drwxr-xr-x 2 hauerbac 2023_paris  4096 Mar  1 17:28 .
drwxr-xr-x 7 hauerbac 2023_paris  4096 Mar  1 08:41 ..
-rw-r--r-- 1 hauerbac 2023_paris  2995 Mar  1 17:23 ft_convert_base2.c
-rw-r--r-- 1 hauerbac 2023_paris  2937 Mar  1 16:08 ft_convert_base.c
-rwxr-xr-x 1 hauerbac 2023_paris 16552 Mar  1 17:28 test_ft_convert_base
-rw-r--r-- 1 hauerbac 2023_paris  1841 Mar  1 17:28 test_ft_convert_base.c
e3r11p9% ./test_ft_convert_base                                                                                          
42 en base 10: 42
2a == 42 en base 16: 42
-2a == -42 en base 16: -42
 (42 en base vide): (null)
 (42 en base de taille 1): (null)
 (42 en base 16 avec + et -): (null)
 (42 en base 16 avec une tabulation): (null)
101010 == 42 en base 2: 101010
vn == 42 en base 8 ("poneyvif"): 42%                                                                                           
 e3r11p9% cat ft_convert_base.c
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_convert_base.c                                  :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: hauerbac <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2023/03/01 14:33:49 by hauerbac          #+#    #+#             */
/*   Updated: 2023/03/01 16:08:28 by hauerbac         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include <stdlib.h>
#include <stddef.h>

int	ft_atoi_base(char *str, char *base);

int	ft_error_or_strlen(const char *str)
{
	int	base_len;
	int	i;

	base_len = -1;
	i = 0;
	while (str && str[i] != '\0')
	{
		if (str[i] == ' ' || str[i] == '\f'
			|| str[i] == '\n' || str[i] == '\r'
			|| str[i] == '\t' || str[i] == '\v')
			return (0);
		i++;
	}
	base_len = i;
	return (base_len);
}

int	ft_error_or_correct_base(const char *str, int base_len)
{
	int	i;
	int	j;

	i = 0;
	while (i < base_len)
	{
		if (str[i] == '+' || str[i] == '-')
			return (0);
		else if (i > 0 && str[i])
		{
			j = 0;
			while (j < i && str[j])
			{
				if (str[j] == str[i])
					return (0);
				j++;
			}
		}
		i++;
	}
	if (i == base_len)
		return (base_len);
	return (0);
}

int	ft_error_or_base_len(const char *str)
{
	int	base_len;

	base_len = ft_error_or_strlen(str);
	if (base_len < 2)
		return (0);
	return (ft_error_or_correct_base(str, base_len));
}

char	*ft_itoa_base(char *result, int nb, char *base, int base_len)
{
	long	nb_into_long;
	int		i;

	nb_into_long = nb;
	i = 0;
	while (i < 11 && result[i] != '\0')
		i++;
	if (nb_into_long < 0)
	{
		result[i++] = '-';
		nb_into_long *= -1;
	}
	if (i < 11 && nb_into_long < base_len)
	{
		result[i++] = base[nb_into_long];
		result[i] = '\0';
	}
	else
	{
		ft_itoa_base(result, nb_into_long / base_len, base, base_len);
		ft_itoa_base(result, nb_into_long % base_len, base, base_len);
	}
	return (result);
}

char	*ft_convert_base(char *nbr, char *base_from, char *base_to)
{
	int		base_from_len;
	int		base_to_len;
	int		nb_from_base_from;
	char	*result;
	int		i;

	base_from_len = ft_error_or_base_len(base_from);
	base_to_len = ft_error_or_base_len(base_to);
	if (base_from_len && base_to_len && nbr)
	{
		nb_from_base_from = ft_atoi_base(nbr, base_from);
		result = (char *) malloc((11 + 1) * sizeof(char));
		if (result)
		{
			i = 0;
			while (i < 11 + 1)
				result[i++] = '\0';
			return (ft_itoa_base(result, nb_from_base_from,
					base_to, base_to_len));
		}
		return (NULL);
	}
	return (NULL);
}
e3r11p9% cd ..
e3r11p9% mkdir ex05
e3r11p9% cd ex05
e3r11p9% vi ft_split.c
e3r11p9% norminette -R CheckForbiddenSourceHeader ft_split.c                                                             
ft_split.c: Error!
Error: TOO_MANY_LINES       (line:  81, col:   1):	Function has more than 25 lines
Error: LINE_TOO_LONG        (line: 116, col:  82):	line too long
Error: TOO_MANY_LINES       (line: 128, col:   1):	Function has more than 25 lines
e3r11p9% vi ft_split.c                                      
e3r11p9% norminette -R CheckForbiddenSourceHeader ft_split.c
ft_split.c: OK!
e3r11p9% vi test_ft_split.c 
e3r11p9% gcc -Wall -Wextra -Werror -o test_ft_split ../ex03/ft_strjoin.c ft_split.c test_ft_split.c 
test_ft_split.c: In function â€˜mainâ€™:
test_ft_split.c:21:2: error: implicit declaration of function â€˜printfâ€™ [-Werror=implicit-function-declaration]
   21 |  printf("%s\n", ft_strjoin(6, tab, " "));
      |  ^~~~~~
test_ft_split.c:21:2: error: incompatible implicit declaration of built-in function â€˜printfâ€™ [-Werror]
test_ft_split.c:1:1: note: include â€˜<stdio.h>â€™ or provide a declaration of â€˜printfâ€™
  +++ |+#include <stdio.h>
    1 | /* ************************************************************************** */
cc1: all warnings being treated as errors
e3r11p9% vi test_ft_split.c                                                                        
e3r11p9% gcc -Wall -Wextra -Werror -o test_ft_split ../ex03/ft_strjoin.c ft_split.c test_ft_split.c
e3r11p9% ls -al
total 36
drwxr-xr-x 2 hauerbac 2023_paris  4096 Mar  1 21:15 .
drwxr-xr-x 8 hauerbac 2023_paris  4096 Mar  1 18:06 ..
-rw-r--r-- 1 hauerbac 2023_paris  2692 Mar  1 20:55 ft_split.c
-rwxr-xr-x 1 hauerbac 2023_paris 16512 Mar  1 21:15 test_ft_split
-rw-r--r-- 1 hauerbac 2023_paris  1642 Mar  1 21:15 test_ft_split.c
e3r11p9% ./test_ft_split 
Ceci est un succes ! 
Success 
Success 
OK
OK
OK
OK
e3r11p9% cat ft_split.c 
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_split.c                                         :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: hauerbac <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2023/03/01 20:46:27 by hauerbac          #+#    #+#             */
/*   Updated: 2023/03/01 20:55:25 by hauerbac         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include <stddef.h>
#include <stdlib.h>

int	ft_char_is_sep(char c, char *charset)
{
	int	i;

	i = 0;
	while (charset[i] && charset[i] != c)
		i++;
	if (charset[i] == '\0')
		return (0);
	return (1);
}

int	ft_nb_substrs(char *str, char *charset)
{
	int	nb;
	int	i;

	if (str)
	{
		i = 1;
		nb = 0;
		while (str[i])
		{
			if (ft_char_is_sep(str[i], charset))
			{
				if (!ft_char_is_sep(str[i - 1], charset))
					nb++;
			}
			i++;
		}
		return (nb + !ft_char_is_sep(str[i - 1], charset));
	}
	return (0);
}

char	*substr_before_set_from_pos(char *str, int *pos, char *charset)
{
	int		i;
	char	*substr;

	if (str && charset && *pos >= 0 && !ft_char_is_sep(str[*pos], charset))
	{
		i = *pos;
		while (str[i] && !ft_char_is_sep(str[i], charset))
			i++;
		substr = (char *) malloc(sizeof(char) * (i - *pos + 1 + 1));
		if (!substr)
			return (NULL);
		i = 0;
		while (str[*pos] && !ft_char_is_sep(str[*pos], charset))
		{
			substr[i] = str[*pos];
			(*pos)++;
			i++;
		}
		substr[i] = '\0';
		while (str[*pos] && ft_char_is_sep(str[*pos], charset))
			(*pos)++;
		return (substr);
	}
	return (NULL);
}

void	ft_free_tab(char **split, int to_free_until)
{
	int	i;

	if (split)
	{
		i = 0;
		while (i < to_free_until)
		{
			free(split[i]);
			i++;
		}
		free(split);
	}
}

char	**ft_split(char *str, char *charset)
{
	int		nb_substrs;
	char	**tab;
	int		index_char;
	int		i;

	nb_substrs = ft_nb_substrs(str, charset);
	tab = (char **) malloc(sizeof(char *) * (nb_substrs + 1));
	if (!tab)
		return (NULL);
	index_char = 0;
	while (ft_char_is_sep(str[index_char], charset))
		index_char++;
	i = 0;
	while (i < nb_substrs)
	{
		tab[i] = substr_before_set_from_pos(str, &index_char, charset);
		if (!tab[i])
		{
			ft_free_tab(tab, i);
			return (NULL);
		}
		i++;
	}
	tab[i] = 0;
	return (tab);
}
e3r11p9% cat test_ft_split.c
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   test_ft_split.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: hauerbac <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2023/03/01 21:14:31 by hauerbac          #+#    #+#             */
/*   Updated: 2023/03/01 21:15:50 by hauerbac         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include <stdio.h>

char	**ft_split(char *str, char *charset);
char	*ft_strjoin(int size, char **strs, char *sep);

int	main(void)
{
	char **tab;

	tab = ft_split("Ceci&est$un##############################################################################################################################################################succes@!", "&$#@");
	printf("%s\n", ft_strjoin(6, tab, " "));
	tab = ft_split("Success", "CUT");
	printf("%s\n", ft_strjoin(2, tab, " "));
	tab = ft_split("Success", "");
	printf("%s\n", ft_strjoin(2, tab, " "));
	tab = ft_split("", "");
	printf("OK\n");
	tab = ft_split( "", "CUT");
	printf("OK\n");
	tab = ft_split("       ", "       ");
	printf("OK\n");
	tab = ft_split("         ", "       ");
	printf("OK\n");
}
e3r11p9% cd ..
e3r11p9% ls
ex00  ex01  ex02  ex03	ex04  ex05
e3r11p9% pwd
/mnt/nfs/homes/hauerbac/c_07
e3r11p9% git clone git@vogsphere.42paris.fr:vogsphere/intra-uuid-d0345bda-4b9c-43bd-8387-f9ddc41e7b43-4725944-hauerbac git_c_07
Cloning into 'git_c_07'...
warning: You appear to have cloned an empty repository.
e3r11p9% mkdir git_c_07/ex00
e3r11p9% mkdir git_c_07/ex01
e3r11p9% mkdir git_c_07/ex02
e3r11p9% mkdir git_c_07/ex03
e3r11p9% mkdir git_c_07/ex04
e3r11p9% mkdir git_c_07/ex05
e3r11p9% cp 
e3r11p9% cp ex00/ft_strdup.c git_c_07/ex00/ft_strdup.c
e3r11p9% cd git_c_07                 
e3r11p9% git add ex00/ft_strdup.c
e3r11p9% git commit -m "Addition of ex00/ft_strdup.c file"
[master (root-commit) 8d9b2ad] Addition of ex00/ft_strdup.c file
 Committer: Helene Auerbach <hauerbac@e3r11p9.clusters.42paris.fr>
Your name and email address were configured automatically based
on your username and hostname. Please check that they are accurate.
You can suppress this message by setting them explicitly. Run the
following command and follow the instructions in your editor to edit
your configuration file:

    git config --global --edit

After doing this, you may fix the identity used for this commit with:

    git commit --amend --reset-author

 1 file changed, 62 insertions(+)
 create mode 100644 ex00/ft_strdup.c
e3r11p9% git push
Enumerating objects: 4, done.
Counting objects: 100% (4/4), done.
Delta compression using up to 4 threads
Compressing objects: 100% (2/2), done.
Writing objects: 100% (4/4), 746 bytes | 373.00 KiB/s, done.
Total 4 (delta 0), reused 0 (delta 0), pack-reused 0
remote: . Processing 1 references
remote: Processed 1 references in total
To vogsphere.42paris.fr:vogsphere/intra-uuid-d0345bda-4b9c-43bd-8387-f9ddc41e7b43-4725944-hauerbac
 * [new branch]      master -> master
e3r11p9% cd ..
e3r11p9% cp ex01/ft_range.c git_c_07/ex01/ex01/ft_range.c
cp: cannot create regular file 'git_c_07/ex01/ex01/ft_range.c': No such file or directory
e3r11p9% cp ex01/ft_range.c git_c_07/ex01/ft_range.c 
e3r11p9% cd git_c_07                                      
e3r11p9% git add ex01/ft_range.c                          
e3r11p9% git commit -m "Addition of ex01/ft_range.c file"
[master cb32ded] Addition of ex01/ft_range.c file
 Committer: Helene Auerbach <hauerbac@e3r11p9.clusters.42paris.fr>
Your name and email address were configured automatically based
on your username and hostname. Please check that they are accurate.
You can suppress this message by setting them explicitly. Run the
following command and follow the instructions in your editor to edit
your configuration file:

    git config --global --edit

After doing this, you may fix the identity used for this commit with:

    git commit --amend --reset-author

 1 file changed, 36 insertions(+)
 create mode 100644 ex01/ft_range.c
e3r11p9% git push
Enumerating objects: 5, done.
Counting objects: 100% (5/5), done.
Delta compression using up to 4 threads
Compressing objects: 100% (3/3), done.
Writing objects: 100% (4/4), 702 bytes | 702.00 KiB/s, done.
Total 4 (delta 0), reused 0 (delta 0), pack-reused 0
remote: . Processing 1 references
remote: Processed 1 references in total
To vogsphere.42paris.fr:vogsphere/intra-uuid-d0345bda-4b9c-43bd-8387-f9ddc41e7b43-4725944-hauerbac
   8d9b2ad..cb32ded  master -> master
e3r11p9% cd ..
e3r11p9% cp ex02/ft_ultimate_range.c git_c_07/ex02/ft_ultimate_range.c
e3r11p9% cat ex02/ft_ultimate_range.c
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_ultimate_range.c                                :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: hauerbac <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2023/02/23 10:23:31 by hauerbac          #+#    #+#             */
/*   Updated: 2023/02/28 18:18:23 by hauerbac         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include <stdlib.h>

int	*ft_range(int min, int max)
{
	int	range_len;
	int	*ptr;
	int	i;
	int	value;

	if (min < max)
	{
		range_len = max - min;
		ptr = (int *) malloc(range_len * sizeof(int));
		if (ptr)
		{
			value = min;
			i = 0;
			while (i < range_len && value < max)
				ptr[i++] = value++;
			if (i == range_len)
				return (ptr);
			else
				return (NULL);
		}
	}
	return (NULL);
}

int	ft_ultimate_range(int **range, int min, int max)
{
	int	range_len;
	int	*ptr;

	if (range == NULL)
		return (-1);
	if (min < max)
	{
		range_len = max - min;
		ptr = ft_range(min, max);
		*range = ptr;
		if (ptr)
			return (range_len);
		else
			return (-1);
	}
	else
		return (0);
}
e3r11p9% cd git_c_07                                     
e3r11p9% git add ex02/ft_ultimate_range.c                
e3r11p9% git commit -m "Addition of ex02/ft_ultimate_range.c file"    
[master 3925f52] Addition of ex02/ft_ultimate_range.c file
 Committer: Helene Auerbach <hauerbac@e3r11p9.clusters.42paris.fr>
Your name and email address were configured automatically based
on your username and hostname. Please check that they are accurate.
You can suppress this message by setting them explicitly. Run the
following command and follow the instructions in your editor to edit
your configuration file:

    git config --global --edit

After doing this, you may fix the identity used for this commit with:

    git commit --amend --reset-author

 1 file changed, 60 insertions(+)
 create mode 100644 ex02/ft_ultimate_range.c
e3r11p9% git push                                                     
Enumerating objects: 5, done.
Counting objects: 100% (5/5), done.
Delta compression using up to 4 threads
Compressing objects: 100% (3/3), done.
Writing objects: 100% (4/4), 823 bytes | 823.00 KiB/s, done.
Total 4 (delta 0), reused 0 (delta 0), pack-reused 0
remote: . Processing 1 references
remote: Processed 1 references in total
To vogsphere.42paris.fr:vogsphere/intra-uuid-d0345bda-4b9c-43bd-8387-f9ddc41e7b43-4725944-hauerbac
   cb32ded..3925f52  master -> master
e3r11p9% cd ..
e3r11p9% cp ex03/ft_strjoin.c git_c_07/ex03/ft_strjoin.c
e3r11p9% cd git_c_07                                              
e3r11p9% git add ex03/ft_strjoin.c                                
e3r11p9% git commit -m "Addition of ex03/ft_strjoin.c file"       
[master a16778f] Addition of ex03/ft_strjoin.c file
 Committer: Helene Auerbach <hauerbac@e3r11p9.clusters.42paris.fr>
Your name and email address were configured automatically based
on your username and hostname. Please check that they are accurate.
You can suppress this message by setting them explicitly. Run the
following command and follow the instructions in your editor to edit
your configuration file:

    git config --global --edit

After doing this, you may fix the identity used for this commit with:

    git commit --amend --reset-author

 1 file changed, 97 insertions(+)
 create mode 100644 ex03/ft_strjoin.c
e3r11p9% git push                                          
Enumerating objects: 5, done.
Counting objects: 100% (5/5), done.
Delta compression using up to 4 threads
Compressing objects: 100% (3/3), done.
Writing objects: 100% (4/4), 1.01 KiB | 518.00 KiB/s, done.
Total 4 (delta 1), reused 0 (delta 0), pack-reused 0
remote: . Processing 1 references
remote: Processed 1 references in total
To vogsphere.42paris.fr:vogsphere/intra-uuid-d0345bda-4b9c-43bd-8387-f9ddc41e7b43-4725944-hauerbac
   3925f52..a16778f  master -> master
e3r11p9% cd ..                                             
e3r11p9% cp ex04/ft_convert_base.c git_c_07/ex04/ft_convert_base.c
e3r11p9% cd git_c_07                                    
e3r11p9% git add ex04/ft_convert_base.c                    
e3r11p9% git commit -m "Addition of ex04/ft_convert_base.c file"  
[master f0769da] Addition of ex04/ft_convert_base.c file
 Committer: Helene Auerbach <hauerbac@e3r11p9.clusters.42paris.fr>
Your name and email address were configured automatically based
on your username and hostname. Please check that they are accurate.
You can suppress this message by setting them explicitly. Run the
following command and follow the instructions in your editor to edit
your configuration file:

    git config --global --edit

After doing this, you may fix the identity used for this commit with:

    git commit --amend --reset-author

 1 file changed, 126 insertions(+)
 create mode 100644 ex04/ft_convert_base.c
e3r11p9% git push                                                 
Enumerating objects: 5, done.
Counting objects: 100% (5/5), done.
Delta compression using up to 4 threads
Compressing objects: 100% (3/3), done.
Writing objects: 100% (4/4), 1.12 KiB | 1.12 MiB/s, done.
Total 4 (delta 1), reused 0 (delta 0), pack-reused 0
remote: . Processing 1 references
remote: Processed 1 references in total
To vogsphere.42paris.fr:vogsphere/intra-uuid-d0345bda-4b9c-43bd-8387-f9ddc41e7b43-4725944-hauerbac
   a16778f..f0769da  master -> master
e3r11p9% cd ..                                                    
e3r11p9% cp ex05/ft_split.c git_c_07/ex05/ft_split.c
e3r11p9% cd git_c_07                                            
e3r11p9% git add ex05/ft_split.c                                
e3r11p9% git commit -m "Addition of ex05/ft_split.c file"       
[master ceb1179] Addition of ex05/ft_split.c file
 Committer: Helene Auerbach <hauerbac@e3r11p9.clusters.42paris.fr>
Your name and email address were configured automatically based
on your username and hostname. Please check that they are accurate.
You can suppress this message by setting them explicitly. Run the
following command and follow the instructions in your editor to edit
your configuration file:

    git config --global --edit

After doing this, you may fix the identity used for this commit with:

    git commit --amend --reset-author

 1 file changed, 122 insertions(+)
 create mode 100644 ex05/ft_split.c
e3r11p9% git push                                        
Enumerating objects: 5, done.
Counting objects: 100% (5/5), done.
Delta compression using up to 4 threads
Compressing objects: 100% (3/3), done.
Writing objects: 100% (4/4), 1.05 KiB | 1.05 MiB/s, done.
Total 4 (delta 1), reused 0 (delta 0), pack-reused 0
remote: . Processing 1 references
remote: Processed 1 references in total
To vogsphere.42paris.fr:vogsphere/intra-uuid-d0345bda-4b9c-43bd-8387-f9ddc41e7b43-4725944-hauerbac
   f0769da..ceb1179  master -> master
e3r11p9% cd ..
e3r11p9% ls
ex00  ex01  ex02  ex03	ex04  ex05  git_c_07
e3r11p9% git clone git@vogsphere.42paris.fr:vogsphere/intra-uuid-d0345bda-4b9c-43bd-8387-f9ddc41e7b43-4725944-hauerbac test
Cloning into 'test'...
remote: Enumerating objects: 24, done.
remote: Counting objects: 100% (24/24), done.
remote: Compressing objects: 100% (17/17), done.
remote: Total 24 (delta 7), reused 0 (delta 0)
Receiving objects: 100% (24/24), 4.67 KiB | 796.00 KiB/s, done.
Resolving deltas: 100% (7/7), done.
e3r11p9% ls -alR test/*
test/ex00:
total 12
drwxr-xr-x 2 hauerbac 2023_paris 4096 Mar  1 21:30 .
drwxr-xr-x 9 hauerbac 2023_paris 4096 Mar  1 21:30 ..
-rw-r--r-- 1 hauerbac 2023_paris 1518 Mar  1 21:30 ft_strdup.c

test/ex01:
total 12
drwxr-xr-x 2 hauerbac 2023_paris 4096 Mar  1 21:30 .
drwxr-xr-x 9 hauerbac 2023_paris 4096 Mar  1 21:30 ..
-rw-r--r-- 1 hauerbac 2023_paris 1235 Mar  1 21:30 ft_range.c

test/ex02:
total 12
drwxr-xr-x 2 hauerbac 2023_paris 4096 Mar  1 21:30 .
drwxr-xr-x 9 hauerbac 2023_paris 4096 Mar  1 21:30 ..
-rw-r--r-- 1 hauerbac 2023_paris 1575 Mar  1 21:30 ft_ultimate_range.c

test/ex03:
total 12
drwxr-xr-x 2 hauerbac 2023_paris 4096 Mar  1 21:30 .
drwxr-xr-x 9 hauerbac 2023_paris 4096 Mar  1 21:30 ..
-rw-r--r-- 1 hauerbac 2023_paris 2380 Mar  1 21:30 ft_strjoin.c

test/ex04:
total 12
drwxr-xr-x 2 hauerbac 2023_paris 4096 Mar  1 21:30 .
drwxr-xr-x 9 hauerbac 2023_paris 4096 Mar  1 21:30 ..
-rw-r--r-- 1 hauerbac 2023_paris 2937 Mar  1 21:30 ft_convert_base.c

test/ex05:
total 12
drwxr-xr-x 2 hauerbac 2023_paris 4096 Mar  1 21:30 .
drwxr-xr-x 9 hauerbac 2023_paris 4096 Mar  1 21:30 ..
-rw-r--r-- 1 hauerbac 2023_paris 2692 Mar  1 21:30 ft_split.c
e3r11p9% rm -r test/*
zsh: sure you want to delete all 6 files in /mnt/nfs/homes/hauerbac/c_07/test [yn]? y
e3r11p9% 
e3r11p9% ls
ex00  ex01  ex02  ex03	ex04  ex05  git_c_07  test
e3r11p9% rm -r test  
rm: remove write-protected regular file 'test/.git/objects/pack/pack-a023f98b5d2e16c35d13f98afea795bbf4eb9c1c.idx'? y
rm: remove write-protected regular file 'test/.git/objects/pack/pack-a023f98b5d2e16c35d13f98afea795bbf4eb9c1c.pack'? y
e3r11p9% ls
ex00  ex01  ex02  ex03	ex04  ex05  git_c_07
e3r11p9% cd ..
e3r11p9% ls
c_00	  c_02	    c_04      c_06	Documents	Pictures     rush_02_0.tar  rush_02_2.tar  samed.tar	 shell_01
c_00.tar  c_02.tar  c_04.tar  c_06.tar	Downloads	Public	     rush_02_1	    rush_02_H	   sgoinfre	 shell_01.tar
c_01	  c_03	    c_05      c_07	fev2023_23.tar	rush_00      rush_02_1.tar  rush_02_H.tar  shell_00	 Templates
c_01.tar  c_03.tar  c_05.tar  Desktop	Music		rush_00.tar  rush_02_2	    samed	   shell_00.tar  Videos

 
