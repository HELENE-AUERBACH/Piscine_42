C Piscine - C 00 :


---------------------------------------------------------------------------------------------------------------------------------------
C Piscine - C 01 :

1. Introduction to pointers :

2. Assignment :
int	*ptr; pour declarer un pointeur sur int
int	a;
ptr = &a; pour recuperer l'adresse de a dans ptr (emplacement memoire qui peut etre affichee)
char	c;
char	*ptr2;
ptr2 = &c;

3. Dereferencing (Déréférencer) :
pour le deferencement (obtenir la valeur pointee) :
int	a;
int	*ptr;
a = 3;
ptr = &a;
*ptr est un int
*ptr = 42; pour modifier la valeur de a de 3 en 42
int	**ptr2;
ptr2 = &ptr;
**ptr2 = -42; pour modifier la valeur de a de 42 en -42

4. Pointer arithmetic :
int	a;
int	b;
L'adresse de a est 4 octets plus bas dans la stack que l'adresse de b car un int fait 4 octets (l'adresse de b vient avant celle de a quand b vient "apres" a dans la stack)
int	*ptr;
ptr = &b;
Donc l'adresse de a sera ptr + 4 octets, soit ptr + 1 (car le compilateur va multiplier la valeur 1 par la taille d'un int) permet d'aller de b vers a
et *(ptr + 1) donnera la valeur de a

char	ca;
char	cb;
char	*ptr2;
ca = '3';
cb = 'o';
ptr2 = &cb;
ptr2 + 1 est l'adresse du caractere ca (qui se trouve a 1 octet de l'adresse de cb)
*(ptr2 + 1) donne le caractere ca
On peut sommer une adresse avec la valeur d'une variable de type int

5. Arrays (Les tableaux) :
int	tab[10}; pour avoir un pointeur implicite nomme tab sur le 1er des dix int du tableau
tab[0] pour acceder au 1er int car c'est equivalent a *(tab + 0)
tab[n - 1] pour acceder a la valeur du dernier element (d'index n -1) du tableau tab de n elements

int	*tabptr[2]; tabptr est un pointeur de pointeurs sur int
tabptr[0] = tab;
tabptr[0][3] = 42; est equivalent a tab[3] = 42; ou encore a *(tabptr[0] + 3) = 42; ou encore a *(*(tabptr + 0) + 3) = 42;

Attention : int tab2[10][10]; tab2 est seulement un pointeur sur int

6. Character string (Les chaines de caractères) :
int	tab[10}; pour avoir un pointeur implicite nomme tab sur le 1er des dix int du tableau
tab[0] pour acceder au 1er int car c'est equivalent a *(tab + 0)
tab[n - 1] pour acceder a la valeur du dernier element (d'index n -1) du tableau tab de n elements

int	*tabptr[2]; tabptr est un pointeur de pointeurs sur int
tabptr[0] = tab;
tabptr[0][3] = 42; est equivalent a tab[3] = 42; ou encore a *(tabptr[0] + 3) = 42; ou encore a *(*(tabptr + 0) + 3) = 42;

Attention : int tab2[10][10]; tab2 est seulement un pointeur sur int

7. Pointer usage (L'utilisation des pointeurs) :
On passe les arguments par copie, donc on passe une copie dans les fonctions differente des variables du main
Pour modifier la valeur d'une variable du main dans une fonction, il faut passer l'adresse de cette variable en argument a la fonction qui prend un pointeur en parametre

8. void * :
void	*superptr; declare un pointeur sur tout : il peut prendre n'importe quelle adresse pour passer l'adresse d'un pointeur a un autre sans connaitre le type, pour transporter des adresses
int	a;
int	*ptr;
int	**ptr2;
a = 3;
ptr = &a;
ptr2 = &ptr;
superptr = &ptr2;
ptr = superptr;
Attention : On ne peut pas deferencer superptr
---------------------------------------------------------------------------------------------------------------------------------------
C Piscine - C 02, C 03, C 04 :

---------------------------------------------------------------------------------------------------------------------------------------
C Piscine - C 05 :

1. Introduction :

2. Recursion - Theory (Récursivité - Théorie) :

3. Recursion - Practice (Récursivité - Pratique) :

---------------------------------------------------------------------------------------------------------------------------------------
C Piscine - C 06, C 07 :

1. Compilation's steps :


2. Dynamic memory allocation (Allocation dynamique de mémoire) :
#include <stdlib.h>
#define LEN	42

int	main(void)
{
	int		i;
	char	*str;

	str = (char *) malloc(sizeof(*str) * (LEN + 1));
	i = 0;
	while (i < LEN)
	{
		str[i] = '0' + (i % 10); // genere la suite de caracteres constitues des chiffres de 0 a 9
		i++;
	}
	str[i] = '\0';
	free(str); // libere la memoire allouee
	while (1)
		;
	return (0);
}

Compilation d'un seul fichier : gcc -c ft_putstr.c genere le ft_putstr.o
Linkage avec : gcc ft_putstr.o main.o pour generer le a.out
Lancement en tache de fond : ./a.out &
afin de pouvoir inspecter avec la commande top
---------------------------------------------------------------------------------------------------------------------------------------
C Piscine - C 06, C 09 :

1. Introduction :


2. Librairies :
ar rc libstr.a ft_putchar.o ft_putstr.o pour regrouper les fonctions presentes dans les fichiers ft_putchar.c et ft_putstr.c (fichiers deja compiles en objets .o) dans une librairie statique nommee libstr.a

gcc main.c -L. -lstr pour compiler en recherchant une librairie dans le repertoire courant et dont le nom commence obligatoirement par lib

ranlib libstr.a pour creer un index dans la librairie qui sera utilise par gcc afin de retrouver rapidement les fonctions appelees dans la librairie (d'ou une optimisation du temps de compilation)

3. Main's argument (argc, argv) (Les paramètres (argv/argc))  :

---------------------------------------------------------------------------------------------------------------------------------------
C Piscine - C 08 :

1. Preprocessing - Introduction (Préprocesseur - Introduction) :
Le preprocesseur vient avant la compilation, qui vient ell-meme avant le link.
Le preprocesseur permet de generer du code parfois, de faire des "define" de macros (comme il en existe sous Excel) et aussi de proteger nos fichiers contre plusieurs inclusions.
Enfin, nous finirons par les structures qui sont un nouveau moyen de packager les donnees, et par les typedef qui permettent de creer nos propres types de variables.

2. Preprocessing - #include (Préprocesseur - #include) :
La commande du preprocesseur #include permet d'inclure un fichier dans un autre fichier avant la compilation, donc pendant la phase de pre-processeur.
Par exemple, le prototype de write existe deja dans le fichier unistd.h.
Entre chevrons <> signifie que l'on va aller chercher le fichier specifie entre les chevrons dans le path des fichiers que recherche le compilateur (ce path peut etre precise a partir des commandes du compilateur).
L'autre ecriture entre guillemets permet d'inclure les fichiers qui sont en local dans notre dossier.

En plus de nous eviter de rajouter le bon prototype de write a la main au debut de notre fichier main.c, cela permet d'etre portatif car, avec l'include, a chaque fois, unistd.h sera mis a jour en fonction de la distribution sur laquelle nous nous trouverons.

La commande du preprocesseur cpp permet de voir ce qui se passe avant la compilation.
Exemple : cpp main.c

Il est deconseiller d'inclure d'autres fichiers que des .h.

3. Preprocessing - file.h :
L'interet de faire des .h est de proteger nos fonctions (et le reste) contre les erreurs de prototypes (et le reste).

Par exemple, sans #include, si une dizaine de fichiers .c appellent tous une fonction ft_fct, nous serions obliges de mettre a jour a chaque fois le prototype dans chacun des 10 fichiers a chaque modification du prototype de ft_fct (au lieu de ne mettre a jour que le seul fichier .h), et, si nous oublions de mettre a jour l'un des fichiers, la compilation se passe quand meme bien, mais nous aurions fait un peu n'importe quoi.

Par securite (afin que les erreurs de type soient detectees a la compilation), il faut inclure le fichier .h contenant les prototypes dans le(s) fichier(s) .c qui utilise(nt) les fonctions prototypees, ainsi que dans le fichier .c qui definit ces fonctions, et dans le fichier main.c s'il appelle ces fonctions.

4. Preprocessing - #define :
La commande du preprocesseur #define permet de definir des macros. Le nom de la macro sera remplace mot a mot (guillemets inclus) par ce qui a ete ecrit a droite de ce nom (a part quelques cas particuliers) au moment de la precompilation (c'est-a-dire pendant la phase du preprocesseur). Le nom d'une macro est en general en majuscules.
L'interet est de modifier la definition de la macro dans le seul fichier .h afin de mettre automatiquement a jour toutes ses references dans les fichiers .c l'utilisant.

#define TOTO int

TOTO	main(void)
{
	return (0);
}
--------------------------------
#define TOTO "Bonjour bievenue"

int	main(void)
{
	char	*str;
	
	str = TOTO;
	return (0);
}

Le second avantage est d'utiliser des parentheses afin de definir des macros "intelligentes" en passant des parametres (qui seront remplaces "betement") ; par exemple, pour declarer deux variables int a et b (mais, attention, le code sera beaucoup moins lisible avec cette macro!) :
#define TOTO(x) int x;

int main(void)
{
	TOTO(a)
	TOTO(b)
	return (0);
}

Remarque : il n'y a meme pas besoin de ; a la fin de l'instruction TOTO(a) dans l'exemple precedent.

Le #define va aussi de nous permettre de faire des jointures avec des strings, par exemple :
#define TOTO(x) #x
#define TITI(x) TOTO(x); TOTO(x)

int main(void)
{
	char *str;

	str = TOTO(b);
	write(1, str, 1); // affichera le caractere b
	str = TITI(bonjour les amis); // sera remplace par le preprocesseur par str = #bonjour les amis; #bonjour les amis;
	return (0);
}

5. Preprocessing - #ifdef/#ifndef :
S'il existe un define TOTO, alors le main apparaitra, sinon le main n'apparaitra meme pas.

#ifdef TOTO

int main(void)
{
	return (0);
}

#endif
--------------------
S'il n'existe pas un define TOTO, alors le main apparaitra, sinon le main n'apparaitra meme pas.

#ifndef TOTO

int main(void)
{
	return (0);
}

#endif
--------------------
S'il existe un define TOTO, alors : s'il n'existe pas un define TITI, alors le main apparaitra, sinon le main n'apparaitra meme pas.
Or, comme TOTO est defini (meme si c'est a rien comme dans l'exemple ci-dessous => cela veut dire que TOTO ne sera remplace par rien), cela revient a : s'il n'existe pas un define TITI, alors le main apparaitra, sinon le main n'apparaitra meme pas.

#define TOTO

#ifdef TOTO
# ifndef TITI

int main(void)
{
	return (0);
}

# endif
#endif

On peut ainsi proteger nos fichiers .h.

Remarque : l'utilisation des elif (qui sont l'equivalent d'un "else if") n'est pas conseillee.

6. Preprocessing - Multiple inclusions :
Une inclusion multiple de fichiers .h :

Dans le fichier test1.h : #include "test2.h"
Dans le fichier test2.h : #include "test1.h"
Dans le main.c : #include "test1.h" => on a un gros souci de boucle infinie!

Avec le preprocesseur, on peut proteger nos fichiers .h contre les multiples inclusions :

Dans le fichier test1.h : 
#ifndef __FT_TEST1_H__
#define __FT_TEST1_H__

#include "test2.h"

void	pouet1(void);

#endif

Dans le fichier test2.h :
#include "test1.h"
void	pouet2(void);

donne le resultat :
# 1 "main.c"
# 1 "<built-in>"
# 1 "<command-line>"
# 1 "main.c"



# 1 "test1.h" 1


# 1 "test2.h" 1

# 1 "test1.h" 1
# 2 "test2.h" 2
void	pouet2(void);
# 5 "test1.h" 2

void	pouet1(void);

# 14 "main.c" 2

int	main(void)
{
	return (0);
}


On aurait aussi pu proteger le fichier test2.h avec dans le fichier test2.h :
#ifndef __FT_TEST2_H__
#define __FT_TEST2_H__

#include "test1.h"
void	pouet2(void);
#endif

Mais, attention, une fois qu'une macro est definie dans l'un des fichiers .h, elle est definie pour toujours dans le fichier .c par les includes des fichiers .h dans ce fichier .c. Et donc, si autre chose utilise la meme macro (c'est-a-dire le meme define), le ifndef ne fonctionnera pas et le ifdef fonctionnera.

7. Data structures - Typedef :
"typedef" est un mot clef du langage C qui permet de redefinir un type afin de creer son propre type. Comme ce n'est pas lie au preprocesseur, mais a l'executable, il faut un point virgule de fin d'instruction. Contrairement au #define (traite par le preprocesseur), c'est au moment de la compilation que le typedef est pris en compte. Donc, le typedef subit aussi le scope de l'"endroit" ou il est declare.

typedef int*	int_p;
#define INTP	int*

typedef int cacahuete2;
void	ft_fct(void)
{
	//cacahuete	a; // Ici, ft_fct ne peut pas etre compilee car cacahuete est declare dans le scope du main uniquement.
	cacahuete2	a;
	int			*b, c; // Ici, b est un pointeur sur int et c est un int.
	INTP		d, e; // Ici, d est un pointeur sur int et e est un int.
	int_p		f, g; // Ici, f et g sont tous les deux des pointeurs sur int

	a = 10;
}

typedef int cacahuete;

int main(void)
{
	cacahuete	a;

	a = 10;
	return (0);
}

Dans le fichier unistd.h se trouvent les typedef de ssize_t et size_t utilises dans le prototype de write :
ssize_t	write(int fildes, const void *buf, size_t nbyte);
Donc, si demain ils veulent changer pour faire en sorte que "size_t" ne soit plus un "unsigned int", mais un "long unsigned int" par exemple, il leur suffira de le changer a un seul endroit (dans le fichier unistd.h), et nous, nous n'aurons rien a modifier (si nous avons bien utilise des "size_t" dans notre code, cela deviendra automatiquement des "long unsigned int") et il y aura vraiment un controle a la compilation (et le nom du type "size_t" sera indique dans le message d'erreur du compilateur, ce qui permettra de retrouver plus facilement les variables du mauvais type).

8. Data structures - Struct :
"struct" est un mot clef du langage C qui permet de creer des ensembles de data (de n'importe quel type, y compris d'autres structures, du moment que les noms des variables "data" sont differents du nom de la structure "englobante", ainsi qu'entre elles) liees ensemble. Les structures sont tres utilisees en C.

Exemple de calculs geometriques sur des points :
/*
struct	s_point; // simple declaration de l'existence de la structure
*/
//Definition de la structure (attention, cela se termine par un point-virgule) :
struct	s_point
{
	int	x;
	int	y;
};

typedef struct	s_point2
{
	int	x;
	int	y;
}			t_point2;

int	main(void)
{
	struct s_point	a; // attention a ne pas oublier de remettre "struct" (en plus du nom de la structure) dans le type de la variable que l'on declare (contrairement a d'autres langages)
	struct s_point	b;
	t_point2		c; // Avantage du "typedef" avec les structures!
	t_point2		*ptr;

	a.x = 10; // la notation avec le point permet d'acceder a la variable x de la variable a qui est une structure
	a.y = 42;
	b = a; // b est une copie de a : donc, si l'on modifie a par la suite, b ne sera pas touchee (et vice-versa) car b.x == 10 et b.y == 42
	c.x = 24;
	c.y = 42;
	ptr = &c;
	(*ptr).x = 10; // revient a c.x = 10;
	ptr->x = 24; // la notation -> est une seconde notation (qui remlace l'etoile et le point) pour deferencer un pointeur sur une structure, cela revient donc a c.x = 24;
	return (0);
}

Attention, comme, lors d'un appel de fonction, on copie, si l'on met en parametre d'une fonction une structure, on aura le meme probleme de devoir copier (pour ce qui concerne l'exemple ci-dessus 2 "int") et cela risquera de prendre beaucoup de memoire si la structure est gigantesque!
Donc, en general, on utilise souvent des pointeurs sur structures pour les passer en arguments a l'appel d'une fonction.

9. Data structures - Enum :
Les enums permettent de mettre des mots a la place de chiffres. Elles sont comme des listes de "int" dont les valeurs (qui commencent a 0 si l'on ne precise pas une valeur initiale, puis sont incrementees de 1 dans l'ordre de leur declaration) ont une certaine signification et cette serie de nombres sera generee a la compilation.
Pour nommer des erreurs (codes numeriques : 0, 1, 2, 3, ...) (sans faire des "define" les uns en dessous des autres et sans risaue de se retrouver avec deux fois le meme "define" qui auraient le meme chiffre) , on utilise une enum :
/*
enum	e_list; // simple declaration
*/
enum	e_list
{
	val1,
	val2,
	val3
};

enum	e_list2
{
	e_list2_val1 = 4,
	e_list2_val2 = 7, // Attention : le compilateur ne dira rien selon les versions si l'on remet la meme valeur 4 pour val2 que pour val1
	e_list2_val3
};

int	main(void)
{
	enum e_list	a;
	enum e_list2	b;

	a = val1; // desormais, val1 qui faisait partie de l'enum est devenu une sorte de mot clef, c'est-a-dire que "val1" vaut actuellement "0", "val2 "1" et "val3" "2".
	b = e_list2_val3;
	return (b); //"e_list2_val3" vaut "8"
}

10. Data structures - Union (Structures de données - Les unions) :
Les unions permettent d'acceder au meme espace memoire de plusieurs manieres differentes (alors que la structure positionne ses elements les uns a cote des autres).

#include "tools.h"

struct	s_test
{
	int		i;
	char	c;
	float	f;
	char	tab[4];
};

union	u_test
{
	int		i;
	char	c;
	float	f;
	char	tab[4];
};

int main(void)
{
	union u_test	a;

	a.i = 424242;
	ft_putnbr(sizeof(struct s_test)); //16 octets (4 octets pour l'int + 1 octet pour le char + 4 octets pour le float + 4 octets pour le tableau de 4 chars) car le compilateur fait du padding entre le char et le float afin d'acceder plus rapidement : il positionne les elements a des adresses multiples de 4 car le processeur est "32 bits" (avec un processeur "purement 64 bits", on ferait des acces sur 8) => padding sur 4
	ft_putnbr(sizeof(union u_test)); //4 octets car une union prend la taille du plus grand element (+ eventuellement du padding)
	ft_putnbr(a.i); // 424242
	ft_putnbr(a.tab[0]); // 50 car c'est le debut de la decomposition du int 424242 == 50 + (121 * 256) + (6 * 256 * 256) (car les octets vont pour le premier de 256 puissance 0, puis 256 puissance 1, ..., a 256 puissance 3 dans notre exemple)
	ft_putchar('\n');
	ft_putnbr(a.tab[1]); // 121
	ft_putchar('\n');
	ft_putnbr(a.tab[2]); // 6
	ft_putchar('\n');
	ft_putnbr(a.tab[3]); // 0
	ft_putchar('\n');
	return (0);
}
---------------------------------------------------------------------------------------------------------------------------------------
C Piscine - C 09, C 11 :

1. Day 10 Introduction :


2. Compilation Problematic :
gcc est un compilateur complexe avec beaucoup d'options.
Makefile est un outil qui permet de resoudre ce probleme avec une granularite fine afin de faire exactement ce dont nous avons besoin.

3. Makefile - Introduction :
Il existe des outils dont le role est de scripter notre compilation a l'aide d'un langage a domaine specifique.
La commande make en fait partie. Elle s'utilise conjointement avec un ou plusieurs fichiers Makefile (fichiers nommes "Makefile") qui vont decrire, a l'aide d'un ensemble de regles et quelques variables, comment compiler notre programme. La commande make fait appel au Makefile, le lit et l'execute. Dans le Makefile, les regles vont pouvoir s'appeler entre elles, vont pouvoir faire reference a des variables, etc.. Toutes les regles qui se trouvent dqns le Makefile n'ont pas pour but d'etre executees a chaque fois qu'on va invoquerla commande "make". Bien au contraire, generalement c'est une seule de ces regles qui va etre executee, et ses dependances, afin de realiser les actions qu'on souhaitait faire avec cette regle en particulier.
Par exemple :
make clean fait appel a la regle clean decrite dans le Makefile.

4. Makefile - Rules (Makefile - Les règles) :
Les regles du Makefile sont composees d'un nom, d'une liste de dependances, et de la definition de la regle qui est en realite une succession de lignes de shell a executer, qui doivent toutes commencer par une tabulation. Lorsqu'une regle de Makefile est executee (dans l'exemple ci-dessous par la commande "make regle_a"), chaque ligne de shell va etre imprimee dans notre terminal avant d'etre executee. Il est possible d'inhiber ce comportement en faisant preceder la ligne de shell par le caractere @, ce qui permettra d'executer directement la ligne de shell sans affichage de cette ligne.

Par exemple:
regle_a:
	echo "regle A"

regle_b: regle_a
	echo "regle B"

Comme la regle regle_b a dans ses dependances la regle regle_a, la commande "make regle_b" donne le resultat suivant :
echo "regle A"
regle A
echo "regle B"
regle B

5. Makefile - Variables :
Les variables ont un nom en majuscules par convention, suivi du signe = (separe par des espaces), puis de la definition de la variable. Pour faire appel a une variable dans une regle, il faut utiliser la syntaxe $().

Par exemple :
TEXT = "42 is for the braves"

regle_a:
	echo $(TEXT)

Attention : si l'on invoque make sans argument, la premiere regle rencontree dans le Makefile sera celle qui sera utilisee car elle est consideree comme etant la regle de compilation par defaut.
Donc, nous aurons le resultat suivant dans notre exemple :
>make
echo "42 is for the braves"
42 is for the braves

6. Makefile - Example :
Tout comme pour les macros du preprocesseur en C, si l'on a besoin de plusieurs lignes pour lister nos fichiers source, il faut les echapper avec le caractere \.
Les regles standard sont all (par convention, elle est placee en premier afin d'appeler la regle qui va effectivement effectuer la compilation et qui, elle, portera le meme nom que le programme cible/le programme executable a generer avec l'option -o), et les regles utilitaires clean (qui se contente de supprimer tous les fichiers objet *.o generes par la compilation et eventuellement d'autres fichiers comme les ~), fclean (qui appelle clean en dependance, puis appelle la suppression de l'executable genere) et re (qui permet de reset la compilation, c'est-a-dire de reprendre tout a zero dans un environnement propre en appelant d'abord la regle fclean, puis la regle all).

Exemple de Makefile insuffisant et incorrect pour rendre nos projets :
NAME = awesomeprog

SRC = source.c \
	toto.c


all: $(NAME)

$(NAME):
	gcc -o $(NAME) $(SRC)

clean:
	/bin/rm -f *.o

fclean: clean
	/bin/rm -f $(NAME)

re: fclean all

7. Pointers to functions - Introduction (Pointeurs sur fonction - Introduction) :
Il est possible de referencer l'adresse d'une fonction dans un pointeur : c'est un pointeur sur fonction.

8. Pointers to functions - Syntax (Pointeurs sur fonction - Syntaxe) :
int	x; // declaration d'une variable nommee x de type int
int	*y; // declaration d'une variable de type pointeur sur int nommee y

void	f(char c); // prototype de fonction nommee f prenant un parametre nomme c

void	(*funptr)(char); // Pourun pointeur sur fonction, on peut omettre le nom du parametre de la fonction nommee funptr. Attention a ne pas oublier la notation (*...)!
---------------------------------------------------
#include <unistd.h> /* for write */

typedef	void (*funptr)(char); // on indique le nom du type que l'on desire "aliasser" a la place de la variable si l'on avait utiliser la syntaxe de declaration du pointeur sur fonction

void	ft_putchar(char c)
{
	write(1, &c, 1);
	return;
}

int	main()
{
	void	(*f)(char); // declaration d'une variable nommee f de type pointeur sur fonction prenant en parametre un char
	funptr	f2;// On peut utiliser typedef afin de rendre la syntaxe plus pratique a utiliser.

	f = &ft_putchar; // assignation de l'adresse d'une fonction au pointeur sur fonction f
	f('Z'); // appel de la fonction ft_putchar via le pointeur sur fonction f avec l'argument 'Z'
	f2 = &ft_putchar;
	f2('Z');
	return (0);
}

9. Pointers to functions - Example :
Il existe des cas ou les pointeurs sur fonctions apportent une reelle aide, et surtout une lisibilite et une maintanibilite du code.
Exemple en pseudo-code ou l'on possede trois fonctions qui nous permettent d'ecrire une donnee arbitraire quelconque :
- put_stdout	-> ecrit sur la sortie standard
- put_file		-> ecrit dans un fichier
- put_network -> ecrit sur le reseau
On ecrit une fonction pour savoir sur quelle sortie ecrire concretement (parametre where) et quelle donnee ecrire (what).  Le probleme d'une approche naive est, qu'a chaque ajout d'un nouveau "where" comme STDERR, il faut ajouter un else if (or, une "foret" de if est inacceptable):
function put(where, what)
{
	if (where == STDOUT)
		put_stdout(what);
	else if (where == FILE)
		put_file(what);
	else if (where == NETWORK)
		put_network(what);
	else
		error();
}
On peut regrouper des pointeurs sur des fonctions dans une table et associer a chaque entree de cette table a quel moment on utilisera la fonction :
fun_tab = [	(STDOUT, &put_stdout);
			(FILE, &put_file);
			(NETWORK, &put_network); ]
function put (where, what)
{
	for (where_r, put_function) in fun_tab //where_r == "Where de reference"
	{
		if (where == where_r)
			put_function(what);
	}
}

10. Pointers to functions - Conclusion :
Les pointeurs sur fonctions sont reserves a des cas d'utilisation bien precis et nous les retrouverons sous une forme legerement differente en C++.
---------------------------------------------------------------------------------------------------------------------------------------
C Piscine - C 10  :

1. Files - Introduction :
Le systeme garde en memoire une sorte de table qui associe chaque (entier) file descriptor ouvert par un processus avec le fichier. Le file descriptor sert pour manipuler le fichier.
Le set des file descriptors standards comprend : 
* 0 ou "stdin" qui est l'entree standard (typiquement lorsque l'on utilise le clavier)
* 1 ou "stdout" qui est la sortie standard (l'affichage sur le terminal)
* 2 ou "stderr" qui est la sortie d'errreur

2. File manipulation - Open :
man 2 open :
int open(char *path, int flags[, mode_t perm]);
path : chemin relatif ou absolu du fichier a ouvrir
flags : mode d'ouverture (lecture seule O_RDONLY, ecriture seule O_WRONLY, ou les deux O_RDWR, et O_CREAT pour creer le fichier s'il n'existe pas, O_TRUNC pour ecrire depuis le premier octet si le fichier existe, O_APPEND pour ecrire depuis le dernier octet si le fichier existe, etc.). Les flags peuvent etre additionnes avec un ou binaire.
perm : permissions en cas de creation de fichier
Valeur de retour : soit un entier int correspondant au file descriptor ouvert, soit -1 en cas d'erreur.

man 2 close :
int close(int fd);
fd : file descriptor a fermer
Valeur de retour : soit 0, soit -1 en cas d'erreur

#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include "j12.h"

int main()
{
	int fd;

	fd = open("alph", O_RDONLY); // Le fichier nomme "alph" contient quelques lettres
	ft_putnbr(fd);
	return (0);
}


#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include "j12.h"

int main()
{
	int fd;

	fd = open("42", O_WRONLY | O_CREAT, S_IRUSR | S_IWUSR); // On ouvre le fichier nomme "42" en ecriture en le creant car il n'existe pas avec les droits d'ecriture et de lecture dessus
	if (fd == -1)
	{
		ft_putstr("open() failed\n");
		return (1);
	}
	ft_putnbr(fd);
	if (close(fd) == -1)
	{
		ft_putstr("close() failed\n");
		return (1);
	}
	return (0);
}

3. File manipulation - Write :
man 2 write :
int write(int fd, char *buf, int count);
fd : file descriptor sur lequel ecrire
buf : buffer source
count : Nombre d'octets a ecrire
valeur de retour : soit le nombre d'octets ecrits, soit -1 en cas d'erreur.

#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include "j12.h"

void ft_putstr_fd(int fd, char *str)
{
	write(fd, str, ft_strlen(str));
}

int main()
{
	int fd;

	fd = open("42", O_WRONLY | O_CREAT, S_IRUSR | S_IWUSR); // On ouvre le fichier nomme "42" en ecriture en le creant car il n'existe pas avec les droits d'ecriture et de lecture dessus, puis en mode append pour ecrire a la fin du fichier (depuis le dernier octet du fichier).
	if (fd == -1)
	{
		ft_putstr("open() failed\n");
		return (1);
	}
	ft_putnbr(fd);
	ft_putstr_fd(fd, "Hello world!\n");
	if (close(fd) == -1)
	{
		ft_putstr("close() failed\n");
		return (1);
	}
	return (0);
}

4. File manipulation - Read :
man 2 read :
int read(int fd, char *buf, int count);
fd : file descriptor depuis lequel lire
buf : buffer de destination
count : nombre d'octets a lire
valeur de retour : soit le nombre d'octets lus, soit -1 en cas d'erreur

#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include "j12.h"

#define BUF_SIZE 4096
#define BUF_SIZE2 10
int main()
{
	int fd;
	int ret;
	char buf[BUF_SIZE + 1]; // On peut aussi utiliser malloc

	fd = open("42", O_RDONLY); // On ouvre le fichier nomme "42" en lecture seule
	if (fd == -1)
	{
		ft_putstr("open() error\n");
		return (1);
	}
	ret = read(fd, buf, BUF_SIZE); // on demande a read de lire 4096 octets depuis le fichier 42 et de les stocker dans buf
/* Dans certains cas, on ne connait pas le nombre d'octets a lire a l'avance. Il faudra alors utiliser une imbrication de boucles de read car read renvoit 0 en fin de fichier.
	while (ret = read(fd, buf, BUF_SIZE2))
	{
		buf[ret] = '\0';
		ft_putnbr(ret); // on affiche le nombre de caracteres lus
		ft_putstr(buf); // on affiche le buffer
	}
	ft_putnbr(ret); // on affiche le nombre de caracteres lus
	if (close(fd) == -1)
	{
		ft_putstr("close() failed\n");
		return (1);
	}
*/
	buf[ret] = '\0'; // ne pas oublier le caractere NULL pour finir la chaine de caracteres
	ft_putnbr(ret); // on affiche le nombre de caracteres lus
	ft_putstr(buf); // on affiche le buffer
	if (close(fd) == -1)
	{
		ft_putstr("close() failed\n");
		return (1);
	}
	return (0);
}

5. File manipulation - Lseek :
Lorsaue l'on effectue des operations sur un file descriptor et que celui-ci n'a pas ete ferme, il y a une sorte de tete de lecture qui pointe sur l'octet en cours. L'offset est la difference entre l'octet en cours et l'octet "0" (le premier).

man 2 lseek : pour repositionner l'offset
int lseek(int fd, int offset, int mode);
fd : file descritor
offset :offset de resultat ou de calcul
mode : mode de calcul du nouvel offset
valeur de retour : soit le nouvel offset, soit -1 en cas d'erreur.

#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include "j12.h"

#define BUF_SIZE 10
int main()
{
	int fd;
	int ret;
	char buf[BUF_SIZE + 1]; // On peut aussi utiliser malloc

	fd = open("42", O_RDONLY); // On ouvre le fichier nomme "42" en lecture seule
	if (fd == -1)
	{
		ft_putstr("open() error\n");
		return (1);
	}
	while (ret = read(fd, buf, BUF_SIZE))
	{
		buf[ret] = '\0';
		ft_putnbr(ret); // on affiche le nombre de caracteres lus
		ft_putstr(buf); // on affiche le buffer
		lseek(fd, -10, SEEK_END); // en revenant en arriere de 10 octets, on obtient une boucle infinie
	}
	ft_putnbr(ret); // on affiche le nombre de caracteres lus
	if (close(fd) == -1)
	{
		ft_putstr("close() failed\n");
		return (1);
	}
	buf[ret] = '\0'; // ne pas oublier le caractere NULL pour finir la chaine de caracteres
	ft_putnbr(ret); // on affiche le nombre de caracteres lus
	ft_putstr(buf); // on affiche le buffer
	if (close(fd) == -1)
	{
		ft_putstr("close() failed\n");
		return (1);
	}
	return (0);
}
---------------------------------------------------------------------------------------------------------------------------------------
C Piscine - C 12 :

1. Chained list - Introduction :
Les listes chainees sont dans leur forme la plus simple un ensemble de maillons epars en memoire relies entre eux et formant ainsi une chaine. Ces maillons, basiquement des structures, contiennent en leur sein des donnees arbitrairement choisies et un lien, ou pointeur, vers le prochain element (structure de la liste). Ainsi, l'ajout, la suppression, ou la modification de l'ordre d'un element dans la liste se revele assez simle et tient du jeu de pointeurs, contrairement au tableau qui, lorsqu'on souhaite y ajouter un element, necessite d'alloure en memoire une zone plus large que le premier tableau, d'y copier tous les elements du premier tableau, d'y ajouter le nouvel element, et enfin de free le premier tableau.
Meme si cela ne pose pas de probleme lorsque l'on manipule de petites quantites de donnees, malloc eprouvera des difficultes a trouver une zone contigue et assez large en memoire lorsque vous manipulerez de plus grandes quantites de donnees. La liste chainee se contente quant a elle d'etre simplemnt reliee au nouvel element.

2.Chained list - Examples (Exemple pratique) :
Dans le fichier list.h (protege des inclusions multiples :
#ifndef __list_h__
#define __list_h__

typedef struct s_list t_list; /* On peut creer un typedef sur la declaration future de notre liste */

struct s_list
{
	char	*str;
	t_list	*next; /* au lieu de : struct s_list	*next; */
};

t_list	*add_link(t_list *list, char *str);
void	print_list(t_list *list);

#endif

Dans le fichier add_link.c :
#include <stdlib.h>
#include "list.h"

t_list	*add_link(t_list *list, char *str)
{
	t_list	*tmp;

	tmp = malloc(sizeof(t_list));
	if (tmp)
	{
		tmp->str = str;
		tmp->next = list;
	}
	return tmp;
}

Dans le fichier print_list.c :
#include "list.h"

void	print_list(t_list *list)
{
	while (list)
	{
		ft_putstr(list->str);
		list = list->next;
	}
}

Dans le fichier list.c :
#include <stdlib.h> /* pour NULL */
#include "list.h"

int	main(void)
{
	t_list	*list;

	list = NULL;
	list = add_link(list, "toto\n");
	list = add_link(list, "tata\n");
	list = add_link(list, "tutu\n");
	print_list(list);	/* affiche le contenu de la liste */
	return (0);
}

A l'execution :
tutu
tata
toto
car
[toto]->X
[tata]->[toto]->X
[tutu]->[tata]->[toto]->X

3.Chained list - Tips (Chained list - Conseils) :
Une autre facon d'ecrire add_link :
Dans le fichier add_link.c :
#include <stdlib.h>
#include "list.h"

int	add_link(t_list **list, char *str)
{
	*list = malloc(sizeof(t_list)); /* Ainsi, list pointera vers une zone memoire valide, et sera directement "sette" (initialise) dans la fonction main */
...
}

Dans le fichier list.c :
#include <stdlib.h> /* pour NULL */
#include "list.h"

int	main(void)
{
	/* Rappels sur les pointeurs :
	int	i;
	i = 10;
	int	*p;
	p = &i;
	int	**pp;
	pp = &p;
	*/

	t_list	*list;

	list = NULL;
	add_link(&list, "toto\n"); /* La fonction appelee peut modifier l'adresse de notre pointeur dans la fonction appelante */
	add_link(&list, "tata\n");
	add_link(&list, "tutu\n");
	print_list(list);	/* affiche le contenu de la liste */
	return (0);
}
---------------------------------------------------------------------------------------------------------------------------------------
C Piscine - C 13 :

1. Binary trees - Introduction (Les arbres binaires - Intro) :


2. Binary trees - Usage (Utilisation) :
Un arbre binaire est une structure de donnees qui permet de stocker, d'organiser des elements de n'importe quel type (de la meme maniere qu'une liste chainee, si ce n'est que la liste chainee n'a qu'un seul element suivant) et qui a deux elements suivants "left" et "right" par noeud, de telle sorte que tous les elements plus petits qu'un noeud se retrouvent a gauche de ce noeud et tous les elements plus grands ou egaux que ce noeud se retrouvent a droite de ce noeud. Donc, la recherche dans un arbre binaire est beaucoup plus rapide que dans une liste chainee, surtout pour un grand grand nombre de donnees, et c'est la raison pour laquelle certains types de bases de donnees l'utilisent entre autres. Et certains types de parsers utilisent aussi les arbres binaires pour stocker des tokens par exemple.

Exemple de liste chainee triee :
0->1->1->2->3->4->X => 6 sauts pour atteindre 4

Exemple d'arbre : => 3 sauts  pour atteindre 4 dans l'arbre (soit deux fois moins que dans la liste)
                2
             /	   \
            1       3
          /   \       \
         0     1       4

Structure pour un noeud d'un arbre binaire avec en plus le parent/pere du noeud (soit l'equivalent d'un "previous" dans une liste doublement chainee) :
typedef struct		s_btree
{
	struct s_btree	*parent;
	struct s_btree	*right;
	struct s_btree	*left;
	void		*data;
}			t_btree;

Il y a plusieurs techniques de parcours d'un arbre binaire en fonction de ce que l'on desire faire sachant qu'il existe differentes variantes :
1. le parcours en profondeur infixe pour sortir les elements tries : parcours du sous_arbre gauche, puis parcours du noeud lui-meme, et enfin parcours du sous-arbre droit ;
	=> dans l'exemple :  0, 1, 1, 2, 3, 4.
2. le parcours en profondeur prefixe : parcours du noeud lui-meme, puis parcours du sous_arbre gauche, et enfin parcours du sous-arbre droit ;
	=> dans l'exemple :  2, 1, 0, 1, 3, 4.
3. le parcours en profondeur suffixe : parcours du sous_arbre gauche, puis parcours du sous-arbre droit, et enfin parcours du noeud lui-meme ;
	=> dans l'exemple :  0, 1, 1, 4, 3, 2.
4. le parcours en largeur (soit par etages) : parcours du noeud lui-meme, puis parcours de ses fils directs, puis parcours de ses petits-fils directs, etc. ;
	=> dans l'exemple :  2, 1, 3, 0, 1 4.
	
Le parcours en largeur est un petit plus complique a implementer en C.
Dans le cas du parcours en profondeur, on utilise un DFS.
Dans le cas du parcours en largeur, on utilise un BFS.

Le defaut des arbres binaires par rapport a une liste chainee est que l'insertion est un peu plus compliquee dans un arbre binaire car il faut utiliser de la dichotomie.
Dans l'exemple, l'arbre devient apres l'insertion de la valeur -1, puis a nouveau de la valeur 0 :
                2
             /	   \
            1       3
          /   \       \
         0     1       4
       /   \
     -1     0

Ce type d'arbre n'est pas tres bien car, selon l'ordre d'insertion des valeurs, on peut arriver plus a un "peigne" qu'a un arbre (par exemple : insertion des valeurs 10, 9, 8, 7, 6, ... jusqu'a l'infini) ; ce qui nous fait perdre tout l'interet d'utiliser un arbre pour aller beaucoup plus vite et, de plus, on perd de la memoire a avoir deux noeuds a chaque fois bien qu'on ne se serve que d'un noeud.

3. Binary trees - Balancing (Equilibrage) :
Pour resoudre le probleme d'equilibrage (avoir le meme nombre d'elements de chaque cote) des arbres binaires presente a la fin de la video precedente, et obtenir un arbre dans lequel le temps de recherche est toujours optimum, il faut utiliser un "arbre rouge et noir", mais il va falloir "se casser un peu la tete" pour equilibrer l'arbre, et l'insertion et la suppression seront un peu plus longues.

Dans le fichier ft_tree.h :
enum	e_rb_color
	{
		RB_BLACK,
		RB_RED
	};

typedef struct			s_rb_node
{
	struct s_rb_node	*parent;
	struct s_rb_node	*right;
	struct s_rb_node	*left;
	void			*data;
	enum e_rb_node	color;
}					t_rb_node;

Hormis, le champ en plus "color", la structure est la meme, ce qui va permettre que l'on dise au compilateur que "s_rb_node" est en fait une "struct s_btree" et ainsi nous permettre de reutiliser toutes nos fonctions de parcours codees pour les btree simples. Cela s'appelle du polymorphisme : c'est une forme assez primaire en C (on peut faire bien plus de choses).

Les arbres rouge et noir ont plusieurs proprietes :
1. le "root" (le noeud racine) de l'arbre est noir ;
2. toutes les feuilles, y compris celles qui sont NULL (les feuilles "vides"), sont egalement noires (comme le root) ;
3. un noeud rouge n'a que des fils noirs (soit ils sont tous les deux NULL, soit ce sont tous les deux ou pour l'un deux seulement de vrai(s) noeud(s) noir(s));
4. depuis n'importe quel noeud de l'arbre,le nombre de noeuds noirs (la distance) entre le noeud de depart et l'une des feuilles est la meme pour toutes les feuilles de ce noeud-la.

Exemple d'un cas simple d'insertion qui fait intervenir les deux operations que nous devrons utiliser, a savoir d'une part la recoloration du noeud, et d'autre part la rotation d'un noeud de l'arbre :
1. Pour inserer dans un arbre rouge et noir, on procede tout d'abord a une insertion comme dans un arbre binaire classique, donc par dichotomie (remarque : par defaut, tous les noeuds sont rouges).
2. Dans le cas de l'exemple ci-dessous (qui est l'un des cas particuliers parmi 4 ou 5), on doit faire tourner l'arbre d'une rotation vers la droite autour de G afin d'equilibrer l'arbre.
3. On doit alors proceder a une inversion de couleur entre "P" et "G" afin d'obtenir que le nouveau "root" (le nouveau noeud racine) soit bien noir.
4. Enfin, a chaque fois que l'on fait une insertion (dans les autres cas particuliers), il faut se rappeler recursivement sur le reste de l'arbre afin de verifier que toutes les proprietes sont bien a nouveau verifiees (un changement precedent peut obliger a refaire des changements : normalemetn, on s'en sort avec 2 rotations et 2-3 recolorations au maximum dans le pire des cas).

0. Begin :
	     G(B)
	  /	   \
        P(R)	   U(B)
	/
     N(R)

1. Intermediate :
       P(R)
      /	   \
    N(R)   G(B)
	    \
            U(B)

2. End :
         P(B)
       /     \
     N(R)    G(R)
               \
              U(B)

Notation utilisee :
1. G : grandparent (grand-pere du noeud) ;
2. P : parent ;
3. U : uncle ;
4. N : noeud que l'on vient d'inserer ;
5. B : black ;
6. R : red.

Conseils :
1. Coder une fonction qui affiche l'arbre (y compris les noeuds NULL en continuant a les deplier afin que cela soit plus lisible) aidera a debugger nos fonctions et voir si une insertion/suppression "marche" bien et si l'arbre est equilibre.
2. Bien lire les explications sur les arbres binaires sur Internet.
---------------------------------------------------------------------------------------------------------------------------------------


---------------------------------------------------------------------------------------------------------------------------------------



---------------------------------------------------------------------------------------------------------------------------------------



---------------------------------------------------------------------------------------------------------------------------------------




---------------------------------------------------------------------------------------------------------------------------------------



---------------------------------------------------------------------------------------------------------------------------------------


